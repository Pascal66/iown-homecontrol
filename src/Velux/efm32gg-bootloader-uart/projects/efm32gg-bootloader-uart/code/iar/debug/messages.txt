Be004:  %nd has overlaid vector with %nd2, second vector deleted
Be005:  segment/section specification not supported in memory_attribute pragma
Be006:  possible conflict for segment/section %sq1:
Be007:  a #pragma %s is active but is not applicable to this object because of a mismatch in memory attributes
Be008:  a #pragma dataseg is active but is not applicable to this object because it is not __no_init
Be009:  memory attributes not allowed on auto variables or parameters
Be010:  segment/section name not allowed (object must have static storage duration and be const or __no_init)
Be011:  location address not allowed for functions
Be013:  a vector is only allowed on an interrupt or trap function
Be014:  an interrupt function can not have parameters (implicit or explicit)
Be015:  an interrupt function can not be a non-static member function of a class
Be016:  location address misaligned
Be017:  an interrupt function can only return void
Be018:  main can not be interrupt, trap, or monitor
Be019:  auto variables cannot have a stricter alignment than the stack alignment (which is %s in this case)
Be020:  illegal location address for variable %nf
Be021:  location address not allowed for objects with auto storage duration
Be022:  location address not allowed for initialized variables (writable variables without the __no_init attribute)
Be023:  a __persistent variable may not be const, __no_init, or located
Be024:  __ro_placement variables must be const
Be025:  variable must be __no_init in order to have a location address
Be026:  variable cannot be placed into the register %sq
Be027:  inline assembler operand has impossible constraints (could not find an available register in register set %s)
Be028:  inline assembler statement has impossible constraints
Be029:  inline assembler statement has too few arguments
Be030:  unsupported inline assembler argument reference: %s
Be031:  an inline function cannot be root as well
Be032:  segment-located initialized variable, initialization requires manual handling
Be033:  segment-located zero-initialized variable, zero-initialization requires manual handling
Be034:  possible conflict for segment/section %sq1: %p %s2
Be035:  %nd is %s2%s1
Be036:  function has more than 250 parameters
Be037:  invalid modifier used in replacement pattern for constraint '%s'
LMS001:  %s
LMS002:  %s
LMS003:  %s
Go001:  Unknown token %sq encountered in #pragma optimize, discarded
Go002:  Unknown syntax in #pragma optimize, discarded
Go003:  Optimization can only be lowered from the default, not raised.
Go004:  Could not inline %n (inlined function is too complex or inlining is turned off)
Go005:  Cannot inline %n at this level of optimization
Go006:  Undefined behavior: %n modified more than once between two sequence points
Go007:  Undefined behavior: destination modified more than once between two sequence points
Go008:  Order of evaluation for read and modification of %n is undefined
Go009:  Order of evaluation for read and modification is undefined
Go010:  Order of evaluation for volatile accesses is undefined
Go011:  Optimization switch "%s1" is deprecated. Please use %s2.
Go012:  Optimization level %sq not recognized
Go013:  Deprecated optimization level %sq encountered in #pragma optimize, please use one of none, low, medium or high
Go014:  Unrolling factor %s1 in #pragma unroll has been truncated to %s2 to fit code generation pattern
Go015:  Could not unroll loop
Go016:  The Go does not know how to generate debug code for %sq
Go017:  Argument must be instrumented pointer variable or dereference of pointer value
Go018:  No bounds available - no checking for this dereference
Go019:  Cannot generate an entry without bounds for this function
Go020:  #pragma define_with_bounds is meaningless on this function
Go021:  No definition for no_bounds version of %n
Go022:  Conflicting optimization flags: %sq1 and %sq2
Go023:  Dynamic initialization of __ro_placement variable not allowed
Go024:  Stack smash protection is not enabled, pragma ignored.
Go025:  Multiple pragmas to control stack protection.
Go026:  Stack protection not supported.
Go027:  Type conversion between scalar and non-scalar type.
Go028:  Shifting by a negative amount or an amount greater than or equal to the width in bits of the shifted value is undefined.
Go029:  Variable %sq1 is used uninitialized at this location in the sourcecode.
Go030:  Variable %sq1 may be used uninitialized at this location in the sourcecode.
Ms001:  diagnostic tag %sq does not exist
Ms002:  diagnostic tag %sq can not have its level changed
Ms003:  could not open file %sq for writing
Ms004:  problem writing to file %sq
Ms005:  problem closing file %sq
Ms006:  illegal path %sq
Ms007:  could not open file %sq
Ms009:  comment unclosed at end of file
Ms010:  missing closing quote
Ms011:  illegal integer
Ms012:  illegal hexadecimal number
Ms013:  unrecognized text encoding (%sq)
Ms014:  some characters could not be correctly encoded in %sq1, and have been replaced with '@'. The first such character has unicode code point %s2
Ms015:  Path too long?
Ms016:  Error limit (%s) reached
Ms017:  the output file %sq would overwrite one of the input files
Og002:  Couldn't open file %sq for writing
Og003:  Problem writing to file %sq
Og004:  Problem closing file %sq
Og005:  Unknown symbol in inline assembly: %sq
Og006:  Error in inline assembly: %sq
Og007:  Assembler list file generation not allowed in this version of the compiler
Og008:  Code size limit exceeded. %s1 code bytes is more than the limit of %s2 bytes.
Og009:  Public equ %sq is in conflict with another symbol
Og010:  Inline assembler instruction has more than one size: %sq. Use size specific syntax
Og011:  Label %sq defined more than once in inline assembler statement
Og012:  Code size limit from %s
Og013:  Some debug information was not output correctly because there were line numbers greater than 16777216
Og014:  Warning in inline assembly: %sq
Og015:  Unable to produce correct debug information for some bitfields due to limitations in the UBROF file format. Example: field %sq (%p)
Pa001:  type attributes are incompatible with previous declaration
Pa002:  the type attribute %sq is not allowed on this declaration
Pa003:  type attribute specified more than once
Pa004:  illegal declaration
Pa005:  illegal literal
Pa006:  old unsupported #pragma encountered
Pa007:  unrecognized syntax in #pragma
Pa008:  illegal usage of location operator in declaration
Pa009:  cannot create a pointer to the type %t
Pa010:  type attributes on parameters are ignored
Pa011:  memory attribute duplicated
Pa013:  type attribute duplicated
Pa014:  object attribute duplicated
Pa016:  unrecognized syntax in memory #pragma
Pa017:  unrecognized syntax in dataseg #pragma
Pa018:  unrecognized syntax in constseg #pragma
Pa019:  unrecognized syntax in function #pragma
Pa020:  more than one #pragma type_attribute active for this declaration
Pa021:  more than one #pragma object active for this declaration
Pa022:  more than one #pragma locate active for this declaration
Pa023:  more than one #pragma vector active for this declaration
Pa024:  duplicate type qualifier
Pa025:  location specified using #pragma location is different from that specified here
Pa026:  vector supplied both from #pragma function_attribute and ##pragma vector, #pragma vector used
Pa027:  expected data object attributes from #pragma object_attribute
Pa028:  expected function object attributes from #pragma object_attribute
Pa029:  unknown diagnostic tag
Pa030:  this diagnostic cannot have its level changed
Pa031:  IAR keyword %sq1 used with IAR extended language disabled%s2
Pa032:  the type "long long" does not exist
Pa033:  no integer type can hold all these values
Pa034:  an initialized variable can not have the __no_init attribute
Pa036:  initializer must have a constant value
Pa037:  function type not callable
Pa038:  the type %t cannot be constructed/destructed in %s memory
Pa039:  use of address of unaligned structure member
Pa040:  expected a string literal
Pa041:  the type attribute %sq is not allowed on function types
Pa042:  the type attribute %sq is not allowed on object types
Pa043:  the keyword %sq1 is not available with the current settings%s2
Pa044:  no more than one representation changing cast allowed in constant expression
Pa045:  %n has no prototype
Pa046:  function type has no prototype
Pa047:  expected a "}%%"
Pa048:  object attribute not allowed
Pa049:  multiple lines not allowed in inline assembler statement
Pa051:  not a function or a variable
Pa052:  #pragma %sq can only be used on a definition%s2
Pa053:  %s1 has not been declared using #pragma %s2
Pa054:  incompatible with previous %s declaration %p
Pa055:  expected a type attribute
Pa058:  illegal use of a __single_inheritance class
Pa059:  inheritance kind %sq is too restrictive for %n
Pa060:  more than one pragma of this kind active for this declaration
Pa061:  invalid data alignment value
Pa062:  expected a non-negative integer constant
Pa063:  data alignment (%s1) is different from previous declaration (%s2)
Pa064:  type qualifiers are in conflict with those of base %t
Pa065:  pragma %sq (%p) may not be used here
Pa066:  first parameter of non-default allocation function must be the appropriate index type
Pa067:  allocation function requires "void MEM *" return type, for the appropriate memory MEM
Pa068:  first parameter of deallocation function must be of type "void MEM *", for some memory MEM
Pa069:  dynamic memory allocation is not available for %sq memory
Pa070:  member functions for objects of type %t are not allowed
Pa071:  both, or neither, must be system includes
Pa072:  memory attribute not allowed
Pa073:  invalid type conversion (from %t1 to %t2)
Pa074:  "#pragma language = save" %p still open
Pa075:  no matching save pragma
Pa076:  illegal atttributes for virtual member function - a default function pointer cannot point to this function
Pa077:  pointer to member of type %t is not allowed - a default function pointer cannot point to this function type
Pa078:  undefined behavior: an lvalue is modified more than once without an intervening sequence point in this statement
Pa079:  undefined behavior: %nd (or a value reached by some form of indirection through it) is modified more than once without an intervening sequence point in this statement
Pa080:  undefined behavior: the order of read and modification is undefined in this statement
Pa081:  undefined behavior: the order of read and modification of %nd (or a value reached by some form of indirection through it) is undefined in this statement
Pa082:  undefined behavior: the order of volatile accesses is undefined in this statement
Pa083:  undefined behavior: the order of volatile accesses to %nd (or a value reached by some form of indirection through it) is undefined in this statement
Pa084:  pointless integer comparison, the result is always %s
Pa085:  undefined behavior: %sq (or a value reached by some form of indirection through it) is modified more than once without an intervening sequence point in this statement
Pa086:  undefined behavior: the order of read and modification of %sq (or a value reached by some form of indirection through it) is undefined in this statement
Pa087:  undefined behavior: the order of volatile accesses to %sq (or a value reached by some form of indirection through it) is undefined in this statement
Pa088:  non-constructor dynamic initialization of const variables not allowed in this memory
Pa089:  enumerated type mixed with another enumerated type
Pa091:  operator operates on value promoted to int (with possibly unexpected result)
Pa092:  implicit conversion to integer does not preserve the value
Pa093:  implicit conversion from floating point to integer
Pa094:  the object attribute %sq is not allowed here
Pa095:  dynamic initialization not allowed in %sq memory
Pa096:  delete of class with virtual functions but no virtual destructor
Pa097:  this call could cause an exception to escape from a nothrow function
Pa098:  construction of this object could cause an exception to escape from a nothrow function
Pa099:  destruction of this object could cause an exception to escape from a nothrow function
Pa100:  this try has no catch-all clause. This could permit an exception to escape from a nothrow function
Pa101:  this throw would escape from a nothrow function
Pa103:  %s1 is only valid in parameter declarations
Pa104:  argument must be between %s1 and %s2, inclusive
Pa105:  this directive is inside an active namespace scope
Pa106:  the preceding STDC pragma argument is unsupported
Pa107:  this runtime model attribute declaration is in conflict with previous declaration %p
Pa108:  no variant of the generic intrinsic function %sq available for the type %t
Pa109:  the unary minus operator is applied to an unsigned expression (with possibly unexpected results)
Pa110:  c99 inline definition not allowed
Pa111:  [error pragma]: %s
Pa112:  throw not allowed in exception neutral mode
Pa113:  rtti not allowed in C++/EC++ neutral mode
Pa114:  the address of this object cannot be used in static initialization
Pa115:  no support for exported templates
Pa116:  throw used outside of a try block in a __nounwind function
Pa117:  declaration for virtual function %nf1 is incompatible with that of overridden function %nfd2
Pa119:  virtual functions cannot be used in this mode as the virtual function tables cannot be statically initialized. Example: vtable for %t
Pa120:  failed to obtain absolute path to %sq
Pa121:  register location not allowed for functions
Pa122:  expected an integer constant or a string
Pa123:  expected an integer constant, a string, or a register name
Pa124:  constant value outside range of bit field
Pa125:  relational operator used with pointer values
Pa126:  not a variable
Pa127:  not a function
Pa128:  truncating cast in constant expression
Pa129:  type attribute not allowed
Pa130:  value is not used
Pa131:  this is a function pointer constant. Did you intend a function call?
Pa132:  unrecognized inline asm argument
Pa133:  %nfdT
Pa134:  left and right operands are identical
Pa135:  expected an object attribute
Pa136:  expected an object or type attribute or "@"
Pa137:  use of C-style cast
Pa138:  __no_alloc/__no_alloc16 can only be used on constants
Pa139:  cannot assign to or use the value of a __no_alloc variable
Pa140:  references to __no_alloc variables not allowed
Pa141:  expected a "@"
Pa142:  cannot have both __no_init and __inited
Pa143:  __no_alloc string literals with different segment/section names cannot be concatenated (%sq1 vs %sq2)
Pa144:  %t1 was not defined with __packed
Pa145:  %t1 was previously declared with __packed
Pa146:  no such instrumentation topic: %sq
Pa147:  function must be 'no bounds' in order to use #pragma define_with_bounds
Pa148:  pragma has no effect on %nd, as it is not bounds checked
Pa149:  some enum values are not handled in this switch statement: %s
Pa150:  static initialization with an address value requires a destination of at least the same size as the address
Pa151:  use of the %sq1 pragma is deprecated%s2
Pa152:  constant expression too complex: addition and subtraction only allowed before a representation-changing cast to integer type, not after
Pa153:  these operand types cannot be used here (%t1 and %t2)
Pa154:  wide character use not allowed
Pa155:  unexpected syntax in --deprecate_warnings: %sq
Pa156:  #pragma %s is deprecated. It will be removed in a future release
Pa157:  use of Migration Preprocessor Extensions. This feature is deprecated and will be removed in a future release
Pa158:  the effect of placing the type attribute %sq before the type in this declaration is different when using or not using Uniform Attribute Syntax
Pa159:  no matching cstat_disable/cstat_enable pragma for id %sq
Pa161:  cannot create an alternate def for %n
Pa162:  Cannot enable both C-STAT abstract syntax tree generation (--cstat_ast) and multiple file compilation (--mfc)
Pa163:  #pragma %sq cannot be used on a tentative definition
Pa164:  this kind of constant is not allowed here
Pa165:  incompatible declarations
Pa167:  the %sq attribute is not supported
Pa168:  function alignment not supported
Pa169:  the attribute %sq is not available with the current settings
Pa170:  thread local variables must be in the default data memory
Pa171:  the first character in a header name shall not be a digit
Pa172:  nonstandard format string conversion or modifier: %sq
Pa173:  expression must be a pointer to an atomic type
Pa174:  inline assembler statement has no declared side-effect. All optimizations around it will be disabled. Either add side-effect declarations or add volatile.
Pa175:  operation not available for _Atomic types
Pa176:  operation only available for integral or pointer _Atomic types
Pa177:  The "out_of_image" attribute can only be applied to external variables with an absolute location
Pa178:  copy or assignment of structure with _Atomic member not allowed
Pa179:  the second argument must be an integer constant
Pa180:  dynamic initialization of variables with thread storage duration not supported
Pa181:  incompatible redefinition of macro %no (defined %pc)
Pa182:  bit mask appears to contain significant bits that do not affect the result
Pa183:  #warning directive: %s
Pa184:  section/segment size operator is not a constant
Pa185:  path differs in case from that used in file system
Pa186:  %sq
Pa187:  reference or pointer needs dynamic initialization
Pa188:  neon vector attribute requires an integral or floating point type
Pa189:  neon polyvector attribute requires an unsigned integer type
Pa190:  neon vector size must be 64 or 128 bits
Pa191:  in #if %p
Pa192:  in #else/#elif %p
Pa193:    of #if %p
Pa194:  header name ends with whitespace
Pa195:  aspect implementations must be marked can_be_null
Pa196:  header name ends with '.'
Pa197:  templates not supported here
Pa198:  vector types not supported
Pa199:  vector element type or size not supported
Pa200:  vector operation not supported
Pe001:  last line of file ends without a newline
Pe002:  last line of file ends with a backslash
Pe003:  #include file %sq includes itself
Pe004:  out of memory
Pe006:  comment unclosed at end of file
Pe007:  unrecognized token
Pe008:  missing closing quote
Pe009:  nested comment is not allowed
Pe010:  "#" not expected here
Pe011:  unrecognized preprocessing directive
Pe012:  parsing restarts here after previous syntax error
Pe013:  expected a file name
Pe014:  extra text after expected end of preprocessing directive
Pe017:  expected a "]"
Pe018:  expected a ")"
Pe019:  extra text after expected end of number
Pe020:  identifier %sq is undefined
Pe021:  type qualifiers are meaningless in this declaration
Pe022:  invalid hexadecimal number
Pe023:  integer constant is too large
Pe024:  invalid octal digit
Pe025:  quoted string should contain at least one character
Pe026:  too many characters in character constant
Pe027:  character value is out of range
Pe028:  expression must have a constant value
Pe029:  expected an expression
Pe030:  floating constant is out of range
Pe031:  expression must have integral type
Pe032:  expression must have arithmetic type
Pe033:  expected a line number
Pe034:  invalid line number
Pe035:  #error directive: %s
Pe036:  the #if for this directive is missing
Pe037:  the #endif for this directive is missing
Pe038:  directive is not allowed -- an #else has already appeared
Pe039:  division by zero
Pe040:  expected an identifier
Pe041:  expression must have arithmetic or pointer type
Pe042:  operand types are incompatible (%t1 and %t2)
Pe044:  expression must have pointer type
Pe045:  #undef may not be used on this predefined name
Pe046:  %no is predefined; attempted redefinition ignored
Pe047:  incompatible redefinition of macro %nod
Pe049:  duplicate macro parameter name
Pe050:  "##" may not be first in a macro definition
Pe051:  "##" may not be last in a macro definition
Pe052:  expected a macro parameter name
Pe053:  expected a ":"
Pe054:  too few arguments in invocation of %n
Pe055:  too many arguments in invocation of %n
Pe056:  operand of sizeof may not be a function
Pe057:  this operator is not allowed in a constant expression
Pe058:  this operator is not allowed in a preprocessing expression
Pe059:  function call is not allowed in a constant expression
Pe060:  this operator is not allowed in an integral constant expression
Pe061:  integer operation result is out of range
Pe062:  shift count is negative
Pe063:  shift count is too large
Pe064:  declaration does not declare anything
Pe065:  expected a ";"
Pe066:  enumeration value is out of "int" range
Pe067:  expected a "}"
Pe068:  integer conversion resulted in a change of sign
Pe069:  integer conversion resulted in truncation
Pe070:  incomplete type is not allowed
Pe071:  operand of sizeof may not be a bit field
Pe075:  operand of "*" must be a pointer
Pe076:  argument to macro is empty
Pe077:  this declaration has no storage class or type specifier
Pe078:  a parameter declaration may not have an initializer
Pe079:  expected a type specifier
Pe080:  a storage class may not be specified here
Pe081:  more than one storage class may not be specified
Pe082:  storage class is not first
Pe083:  type qualifier specified more than once
Pe084:  invalid combination of type specifiers
Pe085:  invalid storage class for a parameter
Pe086:  invalid storage class for a function
Pe087:  a type specifier may not be used here
Pe088:  array of functions is not allowed
Pe089:  array of void is not allowed
Pe090:  function returning function is not allowed
Pe091:  function returning array is not allowed
Pe092:  identifier-list parameters may only be used in a function definition
Pe093:  function type may not come from a typedef
Pe094:  the size of an array must be greater than zero
Pe095:  array is too large
Pe096:  a translation unit must contain at least one declaration
Pe097:  a function may not return a value of this type
Pe098:  an array may not have elements of this type
Pe099:  a declaration here must declare a parameter
Pe100:  duplicate parameter name
Pe101:  %sq has already been declared in the current scope (%p)
Pe102:  forward declaration of enum type is nonstandard
Pe103:  class is too large
Pe104:  struct or union is too large
Pe105:  invalid size for bit field
Pe106:  invalid type for a bit field
Pe107:  zero-length bit field must be unnamed
Pe108:  signed bit field of length 1
Pe109:  expression preceding parentheses of apparent call must have (pointer-to-) function type
Pe110:  expected either a definition or a tag name
Pe111:  statement is unreachable
Pe112:  expected "while"
Pe114:  %n was referenced but not defined
Pe115:  a continue statement may only be used within a loop
Pe116:  a break statement may only be used within a loop or switch
Pe117:  non-void %n should return a value
Pe118:  a void function may not return a value
Pe119:  cast to type %t is not allowed
Pe120:  return value type (%t1) does not match the function type (%t2)
Pe121:  a case label may only be used within a switch
Pe122:  a default label may only be used within a switch
Pe124:  default label has already appeared in this switch
Pe125:  expected a "("
Pe126:  expression must be an lvalue
Pe127:  expected a statement
Pe128:  loop is not reachable
Pe129:  a block-scope function may only have extern storage class
Pe130:  expected a "{"
Pe131:  expression must have pointer-to-class type
Pe132:  expression must have pointer-to-struct-or-union type
Pe133:  expected a member name
Pe134:  expected a field name
Pe135:  %nd has no member %sq
Pe136:  %nd has no field %sq
Pe137:  expression must be a modifiable lvalue
Pe138:  taking the address of a register variable is not allowed
Pe139:  taking the address of a bit field is not allowed
Pe140:  too many arguments in function call
Pe141:  unnamed prototyped parameters not allowed when body is present
Pe142:  expression must have pointer-to-object type
Pe143:  program too large or complicated to compile
Pe144:  a value of type %t1 cannot be used to initialize an entity of type %t2
Pe145:  %n may not be initialized
Pe146:  too many initializer values
Pe147:  declaration is incompatible with %nfd
Pe148:  %n has already been initialized (%p)
Pe149:  a global-scope declaration may not have this storage class
Pe150:  a type name may not be redeclared as a parameter
Pe151:  a typedef name may not be redeclared as a parameter
Pe152:  conversion of nonzero integer to pointer
Pe153:  expression must have class type
Pe154:  expression must have struct or union type
Pe155:  old-fashioned assignment operator
Pe156:  old-fashioned initializer
Pe157:  expression must be an integral constant expression
Pe158:  expression must be an lvalue or a function designator
Pe159:  declaration is incompatible with previous %nod
Pe160:  external name conflicts with external name of %nd
Pe161:  unrecognized #pragma
Pe163:  could not open temporary file %sq: %s2
Pe164:  name of directory for temporary files is too long (%sq)
Pe165:  too few arguments in function call
Pe166:  invalid floating constant
Pe167:  argument of type %t1 is incompatible with parameter of type %t2
Pe168:  a function type is not allowed here
Pe169:  expected a declaration
Pe170:  pointer points outside of underlying object
Pe171:  invalid type conversion
Pe172:  external/internal linkage conflict with previous declaration %p
Pe173:  floating-point value does not fit in required integral type
Pe174:  expression has no effect
Pe175:  subscript out of range
Pe177:  %n was declared but never referenced
Pe178:  "&" applied to an array has no effect
Pe179:  right operand of "%%" is zero
Pe180:  argument is incompatible with formal parameter
Pe181:  argument is incompatible with corresponding format string conversion
Pe182:  could not open source file %sq (no directories in search list)
Pe183:  type of cast must be integral
Pe184:  type of cast must be arithmetic or pointer
Pe185:  dynamic initialization in unreachable code
Pe186:  pointless comparison of unsigned integer with zero
Pe187:  use of "=" where "==" may have been intended
Pe188:  enumerated type mixed with another type
Pe189:  error while writing %s file
Pe190:  invalid intermediate language file
Pe191:  type qualifier is meaningless on cast type
Pe192:  unrecognized character escape sequence
Pe193:  zero used for undefined preprocessing identifier %sq
Pe194:  expected an asm string
Pe195:  an asm function must be prototyped
Pe196:  an asm function may not have an ellipsis
Pe219:  error while deleting file %sq: %s2
Pe220:  integral value does not fit in required floating-point type
Pe221:  floating-point value does not fit in required floating-point type
Pe222:  floating-point operation result is out of range
Pe223:  function %sq declared implicitly
Pe224:  the format string requires additional arguments
Pe225:  the format string ends before this argument
Pe226:  invalid format string conversion
Pe227:  macro recursion
Pe228:  trailing comma is nonstandard
Pe229:  bit field cannot contain all values of the enumerated type
Pe230:  nonstandard type for a bit field
Pe231:  declaration is not visible outside of function
Pe232:  old-fashioned typedef of "void" ignored
Pe233:  left operand is not a struct or union containing this field
Pe234:  pointer does not point to struct or union containing this field
Pe235:  variable %sq was declared with a never-completed type
Pe236:  controlling expression is constant
Pe237:  selector expression is constant
Pe238:  invalid specifier on a parameter
Pe239:  invalid specifier outside a class declaration
Pe240:  duplicate specifier in declaration
Pe241:  a union is not allowed to have a base class
Pe242:  multiple access control specifiers are not allowed
Pe243:  class or struct definition is missing
Pe244:  qualified name is not a member of class %t or its base classes
Pe245:  a nonstatic member reference must be relative to a specific object
Pe246:  a nonstatic data member may not be defined outside its class
Pe247:  %n has already been defined (%p)
Pe248:  pointer to reference is not allowed
Pe249:  reference to reference is not allowed
Pe250:  reference to void is not allowed
Pe251:  array of reference is not allowed
Pe252:  reference %n requires an initializer
Pe253:  expected a ","
Pe254:  type name is not allowed
Pe255:  type definition is not allowed
Pe256:  invalid redeclaration of type name %nod
Pe257:  const %n requires an initializer
Pe258:  "this" may only be used inside a nonstatic member function
Pe259:  constant value is not known
Pe260:  explicit type is missing ("int" assumed)
Pe261:  access control not specified (%sq by default)
Pe262:  not a class or struct name
Pe263:  duplicate base class name
Pe264:  invalid base class
Pe265:  %nd is inaccessible
Pe266:  %no is ambiguous
Pe267:  old-style parameter list (anachronism)
Pe268:  declaration may not appear after executable statement in block
Pe269:  conversion to inaccessible base class %t is not allowed
Pe274:  improperly terminated macro invocation
Pe276:  name followed by "::" must be a class or namespace name
Pe277:  invalid friend declaration
Pe278:  a constructor or destructor may not return a value
Pe279:  invalid destructor declaration
Pe280:  declaration of a member with the same name as its class
Pe281:  global-scope qualifier (leading "::") is not allowed
Pe282:  the global scope has no %sq
Pe283:  qualified name is not allowed
Pe284:  NULL reference is not allowed
Pe285:  initialization with "{...}" is not allowed for object of type %t
Pe286:  base class %t is ambiguous
Pe287:  derived class %t1 contains more than one instance of class %t2
Pe288:  cannot convert pointer to base class %t2 to pointer to derived class %t1 -- base class is virtual
Pe289:  no instance of constructor %no matches the argument list
Pe290:  copy constructor for class %t is ambiguous
Pe291:  no default constructor exists for class %t
Pe292:  %sq is not a nonstatic data member or base class of class %t
Pe293:  indirect nonvirtual base class is not allowed
Pe294:  invalid union member -- class %t has a disallowed member function
Pe296:  invalid use of non-lvalue array
Pe297:  expected an operator
Pe298:  inherited member is not allowed
Pe299:  cannot determine which instance of %n is intended
Pe300:  a pointer to a bound function may only be used to call the function
Pe301:  typedef name has already been declared (with same type)
Pe302:  %n has already been defined
Pe304:  no instance of %n matches the argument list
Pe305:  type definition is not allowed in function return type declaration
Pe306:  default argument not at end of parameter list
Pe307:  redefinition of default argument
Pe308:  more than one instance of %n matches the argument list:
Pe309:  more than one instance of constructor %no matches the argument list:
Pe310:  default argument of type %t1 is incompatible with parameter of type %t2
Pe311:  cannot overload functions distinguished by return type alone
Pe312:  no suitable user-defined conversion from %t1 to %t2 exists
Pe314:  only nonstatic member functions may be virtual
Pe315:  the object has type qualifiers that are not compatible with the member function
Pe316:  program too large to compile (too many virtual functions)
Pe317:  return type is not identical to nor covariant with return type %t of overridden virtual function %no
Pe318:  override of virtual %n is ambiguous
Pe319:  pure specifier ("= 0") allowed only on virtual functions
Pe320:  badly-formed pure specifier (only "= 0" is allowed)
Pe321:  data member initializer is not allowed
Pe322:  object of abstract class type %t is not allowed:
Pe323:  function returning abstract class %t is not allowed:
Pe324:  duplicate friend declaration
Pe325:  inline specifier allowed on function declarations only
Pe326:  "inline" is not allowed
Pe327:  invalid storage class for an inline function
Pe328:  invalid storage class for a class member
Pe329:  local class member %n requires a definition
Pe330:  %nfd is inaccessible
Pe332:  class %t has no copy constructor to copy a const object
Pe333:  defining an implicitly declared member function is not allowed
Pe334:  class %t has no suitable copy constructor
Pe335:  linkage specification is not allowed
Pe336:  unknown external linkage specification
Pe337:  linkage specification is incompatible with previous %nod
Pe338:  more than one instance of overloaded function %no has "C" linkage
Pe339:  class %t has more than one default constructor
Pe340:  value copied to temporary, reference to temporary used
Pe341:  "operator%s" must be a member function
Pe342:  operator may not be a static member function
Pe343:  no arguments allowed on user-defined conversion
Pe344:  too many parameters for this operator function
Pe345:  too few parameters for this operator function
Pe346:  nonmember operator requires a parameter with class type
Pe347:  default argument is not allowed
Pe348:  more than one user-defined conversion from %t1 to %t2 applies:
Pe349:  no operator %sq matches these operands
Pe350:  more than one operator %sq matches these operands:
Pe351:  first parameter of allocation function must be of type "size_t"
Pe352:  allocation function requires "void *" return type
Pe353:  deallocation function requires "void" return type
Pe354:  first parameter of deallocation function must be of type "void *"
Pe356:  type must be an object type
Pe357:  base class %t has already been initialized
Pe358:  base class name required -- %t assumed (anachronism)
Pe359:  %n has already been initialized
Pe360:  name of member or base class is missing
Pe361:  assignment to "this" (anachronism)
Pe362:  "overload" keyword used (anachronism)
Pe363:  invalid anonymous union -- nonpublic member is not allowed
Pe364:  invalid anonymous union -- member function is not allowed
Pe365:  anonymous union at global or namespace scope must be declared static
Pe366:  %nf provides no initializer for:
Pe367:  implicitly generated constructor for class %t cannot initialize:
Pe368:  %n defines no constructor to initialize the following:
Pe369:  %n has an uninitialized const or reference member
Pe370:  %n has an uninitialized const field
Pe371:  class %t has no assignment operator to copy a const object
Pe372:  class %t has no suitable assignment operator
Pe373:  ambiguous assignment operator for class %t
Pe375:  declaration requires a typedef name
Pe377:  "virtual" is not allowed
Pe378:  "static" is not allowed
Pe379:  cast of bound function to normal function pointer (anachronism)
Pe380:  expression must have pointer-to-member type
Pe381:  extra ";" ignored
Pe382:  in-class initializer for nonstatic member is nonstandard
Pe384:  no instance of overloaded %no matches the argument list
Pe386:  no instance of %n matches the required type (%t)
Pe387:  delete array size expression used (anachronism)
Pe389:  a cast to abstract class %t is not allowed:
Pe390:  function "main" may not be called or have its address taken
Pe391:  a new-initializer may not be specified for an array
Pe392:  member function %no may not be redeclared outside its class
Pe393:  pointer to incomplete class type is not allowed
Pe394:  reference to local variable of enclosing function is not allowed
Pe395:  single-argument function used for postfix %sq (anachronism)
Pe397:  implicitly generated assignment operator cannot copy:
Pe398:  cast to array type is nonstandard (treated as cast to %t)
Pe399:  %n has an operator new%s() but no default operator delete%s()
Pe400:  %n has a default operator delete%s() but no operator new%s()
Pe401:  destructor for base class %nod is not virtual
Pe403:  invalid redeclaration of member %npd
Pe404:  function "main" may not be declared inline
Pe405:  member function with the same name as its class must be a constructor
Pe406:  using nested %n (anachronism)
Pe407:  a destructor may not have parameters
Pe408:  copy constructor for class %t may not have a parameter of type %t
Pe409:  %n returns incomplete type %t
Pe410:  protected %nd is not accessible through a %t pointer or object
Pe411:  a parameter is not allowed
Pe412:  an "asm" declaration is not allowed here
Pe413:  no suitable conversion function from %t1 to %t2 exists
Pe414:  delete of pointer to incomplete class
Pe415:  no suitable constructor exists to convert from %t1 to %t2
Pe416:  more than one constructor applies to convert from %t1 to %t2:
Pe417:  more than one conversion function from %t1 to %t2 applies:
Pe418:  more than one conversion function from %t to a built-in type applies:
Pe424:  a constructor or destructor may not have its address taken
Pe426:  temporary used for initial value of reference to non-const (anachronism)
Pe427:  qualified name is not allowed in member declaration
Pe428:  enumerated type mixed with another type (anachronism)
Pe429:  the size of an array in "new" must be non-negative
Pe430:  returning reference to local temporary
Pe432:  "enum" declaration is not allowed
Pe433:  qualifiers dropped in binding reference of type %t1 to initializer of type %t2
Pe434:  a reference of type %t1 (not const-qualified) cannot be initialized with a value of type %t2
Pe435:  a pointer to function may not be deleted
Pe436:  conversion function must be a nonstatic member function
Pe437:  a template declaration is not allowed here
Pe438:  expected a "<"
Pe439:  expected a ">"
Pe440:  template parameter declaration is missing
Pe441:  argument list for %nf is missing
Pe442:  too few arguments for %nf
Pe443:  too many arguments for %nf
Pe445:  %n1 is not used in declaring the parameter types of %n2
Pe446:  two nested types have the same name: %no1 and %nod2 (cfront compatibility)
Pe447:  global %no1 was declared after nested %nod2 (cfront compatibility)
Pe449:  more than one instance of %n matches the required type
Pe450:  the type "long long" is nonstandard
Pe451:  omission of %sq is nonstandard
Pe452:  return type may not be specified on a conversion function
Pe456:  excessive recursion at instantiation of %n
Pe457:  %sq is not a function or static data member
Pe458:  argument of type %t1 is incompatible with template parameter of type %t2
Pe459:  initialization requiring a temporary or conversion is not allowed
Pe460:  declaration of %sq hides function parameter
Pe461:  initial value of reference to non-const must be an lvalue
Pe463:  "template" is not allowed
Pe464:  %t is not a class template
Pe466:  "main" is not a valid name for a function template
Pe467:  invalid reference to %n (union/nonunion mismatch)
Pe468:  a template argument may not reference a local type
Pe469:  tag kind of %s is incompatible with declaration of %nfd
Pe470:  the global scope has no tag named %sq
Pe471:  %n has no tag member named %sq
Pe472:  member function typedef (allowed for cfront compatibility)
Pe473:  %n may be used only in pointer-to-member declaration
Pe475:  a template argument may not reference a non-external entity
Pe476:  name followed by "::~" must be a class name or a type name
Pe478:  type used as destructor name does not match type %t
Pe479:  %n redeclared "inline" after being called
Pe481:  invalid storage class for a template declaration
Pe482:  %nd is an inaccessible type (allowed for cfront compatibility)
Pe484:  invalid explicit instantiation declaration
Pe485:  %nf is not an entity that can be instantiated
Pe486:  compiler generated %n cannot be explicitly instantiated
Pe487:  inline %n cannot be explicitly instantiated
Pe489:  %n cannot be instantiated -- no template definition was supplied
Pe490:  %n cannot be instantiated -- it has been explicitly specialized
Pe493:  no instance of %n matches the specified type
Pe494:  declaring a void parameter list with a typedef is nonstandard
Pe495:  global %n1 used instead of %n2 (cfront compatibility)
Pe496:  template parameter %sq may not be redeclared in this scope
Pe497:  declaration of %sq hides template parameter
Pe498:  template argument list must match the parameter list
Pe500:  extra parameter of postfix "operator%s" must be of type "int"
Pe501:  an operator name must be declared as a function
Pe502:  operator name is not allowed
Pe503:  %n cannot be specialized in the current scope
Pe504:  nonstandard form for taking the address of a member function
Pe505:  too few template parameters -- does not match previous declaration (declared %p)
Pe506:  too many template parameters -- does not match previous declaration (declared %p)
Pe507:  function template for operator delete(void *) is not allowed
Pe508:  class template and template parameter may not have the same name
Pe510:  a template argument may not reference an unnamed type
Pe511:  this operation on an enumerated type requires an applicable user-defined operator function
Pe512:  type qualifier on a reference type is not allowed
Pe513:  a value of type %t1 cannot be assigned to an entity of type %t2
Pe514:  pointless comparison of unsigned integer with a negative constant
Pe515:  cannot convert to incomplete class %t
Pe516:  const object requires an initializer
Pe517:  object has an uninitialized const or reference member
Pe518:  nonstandard preprocessing directive
Pe519:  %n may not have a template argument list
Pe520:  initialization with "{...}" expected for aggregate object
Pe521:  pointer-to-member selection class types are incompatible (%t1 and %t2)
Pe522:  pointless friend declaration
Pe523:  "." used in place of "::" to form a qualified name
Pe524:  non-const function called for const object (anachronism)
Pe525:  a dependent statement may not be a declaration
Pe526:  a parameter may not have void type
Pe529:  this operator is not allowed in a template argument expression
Pe530:  try block requires at least one handler
Pe531:  handler requires an exception declaration
Pe532:  handler is masked by default handler
Pe533:  handler is potentially masked by previous handler for type %t
Pe534:  use of a local type to specify an exception
Pe535:  redundant type in exception specification
Pe536:  exception specification is incompatible with that of previous %nd%s
Pe540:  support for exception handling is disabled
Pe541:  allowing all exceptions is incompatible with previous %nd
Pe542:  could not create instantiation request file %sq
Pe543:  non-arithmetic operation not allowed in nontype template argument
Pe544:  use of a local type to declare a nonlocal variable
Pe545:  use of a local type to declare a function
Pe546:  transfer of control bypasses initialization of:
Pe548:  transfer of control into an exception handler
Pe549:  %n is used before its value is set
Pe550:  %n was set but never used
Pe551:  %n cannot be defined in the current scope
Pe552:  exception specification is not allowed
Pe553:  external/internal linkage conflict for %nfd
Pe554:  %nf will not be called for implicit or explicit conversions
Pe555:  tag kind of %s is incompatible with template parameter of type %t
Pe556:  function template for operator new(size_t) is not allowed
Pe558:  pointer to member of type %t is not allowed
Pe559:  ellipsis is not allowed in operator function parameter list
Pe560:  %no is reserved for future use as a keyword
Pe561:  invalid macro definition: %s
Pe562:  invalid macro undefinition: %s
Pe565:  IL file name must be specified if input is 
Pe570:  error in debug option argument
Pe571:  invalid option: %s
Pe572:  back end requires name of IL file
Pe573:  could not open IL file %s
Pe574:  invalid number: %s
Pe575:  incorrect host CPU id
Pe576:  invalid instantiation mode: %s
Pe578:  invalid error limit: %s
Pe585:  virtual function tables can only be suppressed when compiling C++
Pe586:  anachronism option can be used only when compiling C++
Pe587:  instantiation mode option can be used only when compiling C++
Pe588:  automatic instantiation mode can be used only when compiling C++
Pe589:  implicit template inclusion mode can be used only when compiling C++
Pe590:  exception handling option can be used only when compiling C++
Pe591:  strict mode is incompatible with K&R mode
Pe592:  strict mode is incompatible with cfront mode
Pe593:  missing source file name
Pe594:  output files may not be specified when compiling several input files
Pe595:  too many arguments on command line
Pe596:  an output file was specified, but none is needed
Pe597:  IL display requires name of IL file
Pe598:  a template parameter may not have void type
Pe599:  excessive recursive instantiation of %n due to instantiate-all mode
Pe600:  strict mode is incompatible with allowing anachronisms
Pe601:  a throw expression may not have void type
Pe602:  local instantiation mode is incompatible with automatic instantiation
Pe603:  parameter of abstract class type %t is not allowed:
Pe604:  array of abstract class %t is not allowed:
Pe605:  floating-point template parameter is nonstandard
Pe606:  this pragma must immediately precede a declaration
Pe607:  this pragma must immediately precede a statement
Pe608:  this pragma must immediately precede a declaration or statement
Pe609:  this kind of pragma may not be used here
Pe611:  overloaded virtual function %no1 is only partially overridden in %n2
Pe612:  specific definition of inline template function must precede its first use
Pe613:  invalid error tag in diagnostic control option: %s
Pe614:  invalid error number in diagnostic control option: %s
Pe617:  pointer-to-member-function cast to pointer to function
Pe618:  struct or union declares no named members
Pe619:  nonstandard unnamed field
Pe620:  nonstandard unnamed member
Pe624:  %sq is not a type name
Pe625:  cannot open precompiled header input file %sq: %s2
Pe626:  precompiled header file %sq is either invalid or not generated by this version of the compiler
Pe627:  precompiled header file %sq was not generated in this directory
Pe628:  header files used to generate precompiled header file %sq have changed
Pe629:  the command line options do not match those used when precompiled header file %sq was created
Pe630:  the initial sequence of preprocessing directives is not compatible with those of precompiled header file %sq
Pe631:  unable to obtain mapped memory
Pe632:  "%s": using precompiled header file "%s"
Pe633:  "%s": creating precompiled header file "%s"
Pe634:  memory usage conflict with precompiled header file %sq
Pe635:  invalid PCH memory size: %s 
Pe636:  PCH options must appear first in the command line
Pe637:  insufficient memory for PCH memory allocation
Pe638:  precompiled header files may not be used when compiling several input files
Pe639:  insufficient preallocated memory for generation of precompiled header file (%s bytes required)
Pe640:  very large entity in program prevents generation of precompiled header file
Pe641:  %sq is not a valid directory
Pe642:  cannot build temporary file name
Pe643:  "restrict" is not allowed
Pe644:  a pointer or reference to function type may not be qualified by "restrict"
Pe646:  a calling convention modifier may not be specified here
Pe647:  conflicting calling convention modifiers
Pe648:  strict mode is incompatible with Microsoft mode
Pe649:  cfront mode is incompatible with Microsoft mode
Pe650:  calling convention specified here is ignored
Pe651:  a calling convention may not be followed by a nested declarator
Pe652:  calling convention is ignored for this type
Pe654:  declaration modifiers are incompatible with previous declaration
Pe655:  the modifier %sq is not allowed on this declaration
Pe656:  transfer of control into a try block
Pe657:  inline specification is incompatible with previous %nod
Pe658:  closing brace of template definition not found
Pe659:  wchar_t keyword option can be used only when compiling C++
Pe660:  invalid packing alignment value
Pe661:  expected an integer constant
Pe662:  call of pure virtual function
Pe663:  invalid source file identifier string
Pe664:  a class template cannot be defined in a friend declaration
Pe665:  "asm" is not allowed
Pe666:  "asm" must be used with a function definition
Pe667:  "asm" function is nonstandard
Pe668:  ellipsis with no explicit parameters is nonstandard
Pe669:  "&..." is nonstandard
Pe670:  invalid use of "&..."
Pe672:  temporary used for initial value of reference to const volatile (anachronism)
Pe673:  a reference of type %t1 cannot be initialized with a value of type %t2
Pe674:  initial value of reference to const volatile must be an lvalue
Pe675:  SVR4 C compatibility option can be used only when compiling ANSI C
Pe676:  using out-of-scope declaration of %nd
Pe677:  strict mode is incompatible with SVR4 C mode
Pe678:  call of %nd cannot be inlined
Pe679:  %n cannot be inlined
Pe680:  invalid PCH directory: %s
Pe681:  expected __except or __finally
Pe682:  a __leave statement may only be used within a __try
Pe688:  %sq not found on pack alignment stack
Pe689:  empty pack alignment stack
Pe690:  RTTI option can be used only when compiling C++
Pe691:  %nfd, required for copy that was eliminated, is inaccessible
Pe692:  %nf, required for copy that was eliminated, is not callable because reference parameter cannot be bound to rvalue
Pe693:  <typeinfo> must be included before typeid is used
Pe694:  %s cannot cast away const or other type qualifiers
Pe695:  the type in a dynamic_cast must be a pointer or reference to a complete class type, or void *
Pe696:  the operand of a pointer dynamic_cast must be a pointer to a complete class type
Pe697:  the operand of a reference dynamic_cast must be an lvalue of a complete class type
Pe698:  the operand of a runtime dynamic_cast must have a polymorphic class type
Pe699:  bool option can be used only when compiling C++
Pe701:  an array type is not allowed here
Pe702:  expected an "="
Pe704:  %sq, declared in condition, may not be redeclared in this scope
Pe705:  default template arguments are not allowed for function templates
Pe706:  expected a "," or ">"
Pe707:  expected a template parameter list
Pe708:  incrementing a bool value is deprecated
Pe709:  bool type is not allowed
Pe710:  offset of base class %no1 within class %no2 is too large
Pe711:  expression must have bool type (or be convertible to bool)
Pe712:  array new and delete option can be used only when compiling C++
Pe713:  %n is not a variable name
Pe714:  __based modifier is not allowed here
Pe715:  __based does not precede a pointer operator, __based ignored
Pe716:  variable in __based modifier must have pointer type
Pe717:  the type in a const_cast must be a pointer, reference, or pointer to member to an object type
Pe718:  a const_cast can only adjust type qualifiers; it cannot change the underlying type
Pe719:  mutable is not allowed
Pe720:  redeclaration of %n is not allowed to alter its access
Pe721:  nonstandard format string conversion
Pe722:  use of alternative token "<:" appears to be unintended
Pe723:  use of alternative token "%%:" appears to be unintended
Pe724:  namespace definition is not allowed
Pe725:  name must be a namespace name
Pe726:  namespace alias definition is not allowed
Pe727:  namespace-qualified name is required
Pe728:  a namespace name is not allowed
Pe729:  invalid combination of DLL attributes
Pe730:  %n is not a class template
Pe731:  array with incomplete element type is nonstandard
Pe732:  allocation operator may not be declared in a namespace
Pe733:  deallocation operator may not be declared in a namespace
Pe734:  %np1 conflicts with using-declaration of %np2
Pe735:  using-declaration of %np1 conflicts with %npd2
Pe736:  namespaces option can be used only when compiling C++
Pe737:  using-declaration ignored -- it refers to the current namespace
Pe738:  a class-qualified name is required
Pe742:  %n has no actual member %sq
Pe744:  incompatible memory attributes specified
Pe745:  memory attribute ignored
Pe746:  memory attribute may not be followed by a nested declarator
Pe747:  memory attribute specified more than once
Pe748:  calling convention specified more than once
Pe749:  a type qualifier is not allowed
Pe750:  %npd1 was used before its template was declared
Pe751:  static and nonstatic member functions with same parameter types cannot be overloaded
Pe752:  no prior declaration of %np
Pe753:  a template-id is not allowed
Pe754:  a class-qualified name is not allowed
Pe755:  %n may not be redeclared in the current scope
Pe756:  qualified name is not allowed in namespace member declaration
Pe757:  %n is not a type name
Pe758:  explicit instantiation is not allowed in the current scope
Pe759:  %n cannot be explicitly instantiated in the current scope
Pe760:  %n explicitly instantiated more than once
Pe761:  typename may only be used within a template
Pe762:  special_subscript_cost option can be used only when compiling C++
Pe763:  typename option can be used only when compiling C++
Pe764:  implicit typename option can be used only when compiling C++
Pe765:  nonstandard character at start of object-like macro definition
Pe766:  exception specification for virtual %n1 is incompatible with that of overridden %n2
Pe767:  conversion from pointer to smaller integer
Pe768:  exception specification for implicitly declared virtual %n1 is incompatible with that of overridden %n2
Pe769:  %no1, implicitly called from %np2, is ambiguous
Pe770:  option "explicit" can be used only when compiling C++
Pe771:  "explicit" is not allowed
Pe772:  declaration conflicts with %sq (reserved class name)
Pe773:  only "()" is allowed as initializer for array %n
Pe774:  "virtual" is not allowed in a function template declaration
Pe775:  invalid anonymous union -- class member template is not allowed
Pe776:  template nesting depth does not match the previous declaration of %n
Pe777:  this declaration cannot have multiple "template <...>" clauses
Pe778:  option to control the for-init scope can be used only when compiling C++
Pe779:  %sq, declared in for-loop initialization, may not be redeclared in this scope
Pe780:  reference is to %nd1 -- under old for-init scoping rules it would have been %nd2
Pe781:  option to control warnings on for-init differences can be used only when compiling C++
Pe782:  definition of virtual %n is required here
Pe783:  empty comment interpreted as token-pasting operator "##"
Pe784:  a storage class is not allowed in a friend declaration
Pe785:  template parameter list for %no is not allowed in this declaration
Pe786:  %n is not a valid class member template
Pe787:  not a valid member class or function template declaration
Pe788:  a template declaration containing a template parameter list may not be followed by an explicit specialization declaration
Pe789:  explicit specialization of %n1 must precede the first use of %n2
Pe790:  explicit specialization is not allowed in the current scope
Pe791:  partial specialization of %n is not allowed
Pe792:  %nf is not an entity that can be explicitly specialized
Pe793:  explicit specialization of %n must precede its first use
Pe794:  template parameter %sq may not be used in an elaborated type specifier
Pe795:  specializing %n requires "template<>" syntax
Pe798:  option "old_specializations" can be used only when compiling C++
Pe799:  specializing %n without "template<>" syntax is nonstandard
Pe800:  this declaration may not have extern "C" linkage
Pe801:  %sq is not a class or function template name in the current scope
Pe802:  specifying a default argument when redeclaring an unreferenced function template is nonstandard
Pe803:  specifying a default argument when redeclaring an already referenced function template is not allowed
Pe804:  cannot convert pointer to member of base class %t2 to pointer to member of derived class %t1 -- base class is virtual
Pe805:  exception specification is incompatible with that of %nd%s
Pe806:  allowing all exceptions is incompatible with %nd
Pe807:  unexpected end of default argument expression
Pe808:  default-initialization of reference is not allowed
Pe809:  uninitialized %n has a const member
Pe810:  uninitialized base class %t has a const member
Pe811:  const %n requires an initializer -- class %t has no user-provided default constructor
Pe812:  const object requires an initializer -- class %t has no user-provided default constructor
Pe813:  option "implicit_extern_c_type_conversion" can be used only when compiling C++
Pe814:  strict mode is incompatible with long preserving rules
Pe815:  type qualifier on return type is meaningless
Pe816:  in a function definition a type qualifier on a "void" return type is not allowed
Pe817:  static data member declaration is not allowed in this class
Pe818:  template instantiation resulted in an invalid function declaration
Pe819:  "..." is not allowed
Pe820:  option "extern_inline" can be used only when compiling C++
Pe821:  extern inline %n was referenced but not defined
Pe822:  invalid destructor name for type %t
Pe824:  destructor reference is ambiguous -- both %n1 and %n2 could be used
Pe825:  virtual inline %n was never defined
Pe826:  %n was never referenced
Pe827:  only one member of a union may be specified in a constructor initializer list
Pe828:  support for "new[]" and "delete[]" is disabled
Pe829:  "double" used for "long double" in generated C code
Pe830:  %n has no corresponding operator delete%s (to be called if an exception is thrown during initialization of an allocated object)
Pe831:  support for placement delete is disabled
Pe832:  no appropriate operator delete is visible
Pe833:  pointer or reference to incomplete type is not allowed
Pe834:  invalid partial specialization -- %n is already fully specialized
Pe835:  incompatible exception specifications
Pe836:  returning reference to local variable
Pe837:  omission of explicit type is nonstandard ("int" assumed)
Pe838:  more than one partial specialization matches the template argument list of %n
Pe840:  a template argument list is not allowed in a declaration of a primary template
Pe841:  partial specializations may not have default template arguments
Pe842:  %n1 is not used in or cannot be deduced from the template argument list of %n2
Pe844:  the template argument list of the partial specialization includes a nontype argument whose type depends on a template parameter
Pe845:  this partial specialization would have been used to instantiate %n
Pe846:  this partial specialization would have made the instantiation of %n ambiguous
Pe847:  expression must have integral or enum type
Pe848:  expression must have arithmetic or enum type
Pe849:  expression must have arithmetic, enum, or pointer type
Pe850:  type of cast must be integral or enum
Pe851:  type of cast must be arithmetic, enum, or pointer
Pe852:  expression must be a pointer to a complete object type
Pe854:  a partial specialization nontype argument must be the name of a nontype parameter or a constant
Pe855:  return type is not identical to return type %t of overridden virtual function %no
Pe856:  option "guiding_decls" can be used only when compiling C++
Pe857:  a partial specialization of a class template must be declared in the namespace of which it is a member
Pe858:  %n is a pure virtual function
Pe859:  pure virtual %n has no overrider
Pe860:  __declspec attributes ignored
Pe861:  invalid character in input line
Pe862:  function returns incomplete type %t
Pe863:  effect of this "#pragma pack" directive is local to %n
Pe864:  %s is not a template
Pe865:  a friend declaration may not declare a partial specialization
Pe866:  exception specification ignored
Pe867:  declaration of "size_t" does not match the expected type %t
Pe868:  space required between adjacent ">" delimiters of nested template argument lists (">>" is the right shift operator)
Pe869:  could not set locale %sq to allow processing of multibyte characters
Pe870:  invalid multibyte character sequence
Pe871:  template instantiation resulted in unexpected function type of %t1 (the meaning of a name may have changed since the template declaration -- the type of the template is %t2)
Pe872:  ambiguous guiding declaration -- more than one function template %no matches type %t
Pe873:  non-integral operation not allowed in nontype template argument
Pe874:  option "embedded_c++" can be used only when compiling C++
Pe875:  Embedded C++ does not support templates. Use the Extended EC++ language setting to enable support
Pe876:  Embedded C++ does not support exception handling
Pe877:  Embedded C++ does not support namespaces. Use the Extended EC++ language setting to enable support
Pe878:  Embedded C++ does not support run-time type information
Pe879:  Embedded C++ does not support the new cast syntax. Use the Extended EC++ language setting to enable support
Pe880:  Embedded C++ does not support using-declarations. Use the Extended EC++ language setting to enable support
Pe881:  Embedded C++ does not support "mutable". Use the Extended EC++ language setting to enable support
Pe882:  Embedded C++ does not support multiple or virtual inheritance
Pe883:  invalid Microsoft version number: %s
Pe884:  pointer-to-member representation %sq has already been set for %n
Pe885:  %t1 cannot be used to designate constructor for %t2
Pe886:  invalid suffix on integral constant
Pe887:  operand of __uuidof must have a class or enum type for which __declspec(uuid("...")) has been specified
Pe888:  invalid GUID string in __declspec(uuid("..."))
Pe889:  option "vla" can be used only when compiling C
Pe890:  variable length array with unspecified bound is not allowed
Pe891:  an explicit template argument list is not allowed on this declaration
Pe892:  an entity with linkage cannot have a type involving a variable length array
Pe893:  a variable length array cannot have static storage duration
Pe894:  %n is not a template
Pe896:  expected a template argument
Pe898:  nonmember operator requires a parameter with class or enum type
Pe899:  option "enum_overloading" can be used only when compiling C++
Pe901:  qualifier of destructor name %t1 does not match type %t2
Pe902:  type qualifier ignored
Pe903:  option "nonstd_qualifier_deduction" can be used only when compiling C++
Pe904:  a function declared "dllimport" may not be defined
Pe905:  incorrect property specification; correct form is __declspec(property(get=name1,put=name2))
Pe906:  property has already been specified
Pe907:  __declspec(property) is not allowed on this declaration
Pe908:  member is declared with __declspec(property), but no "get" function was specified
Pe909:  the __declspec(property) "get" function %sq is missing
Pe910:  member is declared with __declspec(property), but no "put" function was specified
Pe911:  the __declspec(property) "put" function %sq is missing
Pe912:  ambiguous class member reference -- %nd1 used in preference to %nd2
Pe916:  cannot convert pointer to member of derived class %t1 to pointer to member of base class %t2 -- base class is virtual
Pe917:  invalid directory for instantiation files: %s
Pe918:  option "one_instantiation_per_object" can be used only when compiling C++
Pe921:  an instantiation information file name may not be specified when compiling several input files
Pe922:  option "one_instantiation_per_object" may not be used when compiling several input files
Pe923:  more than one command line option matches the abbreviation "--%s":
Pe925:  type qualifiers on function types are ignored
Pe927:  late/early tiebreaker option can be used only when compiling C++
Pe928:  incorrect use of va_start
Pe929:  incorrect use of va_arg
Pe930:  incorrect use of va_end
Pe931:  pending instantiations option can be used only when compiling C++
Pe932:  invalid directory for #import files: %s
Pe933:  an import directory can be specified only in Microsoft mode
Pe934:  a member with reference type is not allowed in a union
Pe935:  "typedef" may not be specified here
Pe936:  redeclaration of %n alters its access
Pe937:  a class or namespace qualified name is required
Pe938:  return type "int" omitted in declaration of function "main"
Pe939:  pointer-to-member representation %sq is too restrictive for %n
Pe940:  missing return statement at end of non-void %n
Pe941:  duplicate using-declaration of %no ignored
Pe942:  enum bit fields are always unsigned, but enum %t includes negative enumerator
Pe943:  option "class_name_injection" can be used only when compiling C++
Pe944:  option "arg_dep_lookup" can be used only when compiling C++
Pe945:  option "friend_injection" can be used only when compiling C++
Pe946:  name following "template" must be a template
Pe948:  nonstandard local-class friend declaration -- no prior declaration in the enclosing scope
Pe949:  specifying a default argument on this declaration is nonstandard
Pe950:  option "nonstd_using_decl" can be used only when compiling C++
Pe951:  return type of function "main" must be "int"
Pe952:  a nontype template parameter may not have class type
Pe953:  a default template argument cannot be specified on the declaration of a member of a class template outside of its class
Pe954:  a return statement is not allowed in a handler of a function try block of a constructor
Pe955:  ordinary and extended designators cannot be combined in an initializer designation
Pe956:  the second subscript must not be smaller than the first
Pe958:  option "extended_designators" can be used only when compiling C
Pe959:  declared size for bit field is larger than the size of the bit field type; truncated to %s bits
Pe960:  type used as constructor name does not match type %t
Pe961:  use of a type with no linkage to declare a variable with linkage
Pe962:  use of a type with no linkage to declare a function
Pe963:  return type may not be specified on a constructor
Pe964:  return type may not be specified on a destructor
Pe965:  incorrectly formed universal character name
Pe966:  universal character name specifies an invalid character
Pe967:  a universal character name cannot designate a character in the basic character set
Pe968:  this universal character is not allowed in an identifier
Pe969:  the identifier __VA_ARGS__ can only appear in the replacement lists of variadic macros
Pe970:  the qualifier on this friend declaration is ignored
Pe971:  array range designators cannot be applied to dynamic initializers
Pe972:  property name cannot appear here
Pe973:  "inline" used as a function qualifier is ignored
Pe974:  option "compound_literals" can be used only when compiling C
Pe975:  a variable-length array type is not allowed
Pe976:  a compound literal is not allowed in an integral constant expression
Pe977:  a compound literal of type %t is not allowed
Pe978:  a template friend declaration cannot be declared in a local class
Pe979:  ambiguous "?" operation: second operand of type %t1 can be converted to third operand type %t2, and vice versa
Pe980:  call of an object of a class type without appropriate operator() or conversion functions to pointer-to-function type
Pe982:  there is more than one way an object of type %t can be called for the argument list:
Pe983:  typedef name has already been declared (with similar type)
Pe984:  operator new and operator delete cannot be given internal linkage
Pe985:  storage class "mutable" is not allowed for anonymous unions
Pe986:  invalid precompiled header file
Pe987:  abstract class type %t is not allowed as catch type:
Pe988:  a qualified function type cannot be used to declare a nonmember function or a static member function
Pe989:  a qualified function type cannot be used to declare a parameter
Pe990:  cannot create a pointer or reference to qualified function type
Pe991:  extra braces are nonstandard
Pe992:  invalid macro definition: %s
Pe993:  subtraction of pointer types %t1 and %t2 is nonstandard
Pe994:  an empty template parameter list is not allowed in a template template parameter declaration
Pe995:  expected "class"
Pe996:  the "struct" keyword may not be used when declaring a template template parameter
Pe997:  %np2 is hidden by %no1 -- virtual function override intended?
Pe998:  a qualified name is not allowed for a friend declaration that is a function definition
Pe999:  %n1 is not compatible with %n2
Pe1000:  a storage class may not be specified here
Pe1001:  class member designated by a using-declaration must be visible in a direct base class
Pe1003:  Sun mode is incompatible with cfront mode
Pe1004:  strict mode is incompatible with Sun mode
Pe1005:  Sun mode is only allowed when compiling C++
Pe1006:  a template template parameter cannot have the same name as one of its template parameters
Pe1007:  recursive instantiation of default argument
Pe1009:  %n is not an entity that can be defined
Pe1010:  destructor name must be qualified
Pe1011:  friend class name may not be introduced with "typename"
Pe1012:  a using-declaration may not name a constructor or destructor
Pe1013:  a qualified friend template declaration must refer to a specific previously declared template
Pe1014:  invalid specifier in class template declaration
Pe1015:  argument is incompatible with formal parameter
Pe1016:  option "dep_name" can be used only when compiling C++
Pe1017:  loop in sequence of "operator->" functions starting at class %t1
Pe1018:  %n has no member class %sq
Pe1019:  the global scope has no class named %sq
Pe1020:  recursive instantiation of template default argument
Pe1021:  access declarations and using-declarations cannot appear in unions
Pe1022:  %no is not a class member
Pe1023:  nonstandard member constant declaration is not allowed
Pe1024:  option "ignore_std" can be used only when compiling C++
Pe1025:  option "parse_templates" can be used only when compiling C++
Pe1026:  option "dep_name" cannot be used with "no_parse_templates"
Pe1027:  language modes specified are incompatible
Pe1028:  invalid redeclaration of nested class
Pe1029:  type containing an unknown-size array is not allowed
Pe1030:  a variable with static storage duration cannot be defined within an inline function
Pe1031:  an entity with internal linkage cannot be referenced within an inline function with external linkage
Pe1032:  argument type %t does not match this type-generic function macro
Pe1034:  friend declaration cannot add default arguments to previous declaration
Pe1035:  %n cannot be declared in this scope
Pe1036:  the reserved identifier %sq may only be used inside a function
Pe1037:  this universal character cannot begin an identifier
Pe1038:  expected a string literal
Pe1039:  unrecognized STDC pragma
Pe1040:  expected "ON", "OFF", or "DEFAULT"
Pe1041:  a STDC pragma may only appear between declarations in the global scope or before any statements or declarations in a block scope
Pe1042:  incorrect use of va_copy
Pe1043:  %s can only be used with floating-point types
Pe1044:  complex type is not allowed
Pe1045:  invalid designator kind
Pe1046:  floating-point value cannot be represented exactly
Pe1047:  complex floating-point operation result is out of range
Pe1048:  conversion between real and imaginary yields zero
Pe1049:  an initializer cannot be specified for a flexible array member
Pe1050:  imaginary *= imaginary sets the left-hand operand to zero
Pe1051:  standard requires that %n be given a type by a subsequent declaration ("int" assumed)
Pe1052:  a definition is required for inline %n
Pe1053:  conversion from integer to smaller pointer
Pe1054:  a floating-point type must be included in the type specifier for a _Complex or _Imaginary type
Pe1055:  types cannot be declared in anonymous unions
Pe1056:  returning pointer to local variable
Pe1057:  returning pointer to local temporary
Pe1058:  option "export" can be used only when compiling C++
Pe1059:  option "export" cannot be used with "no_dep_name"
Pe1060:  option "export" cannot be used with "implicit_include"
Pe1061:  declaration of %n is incompatible with a declaration in another translation unit
Pe1062:  the other declaration is %p
Pe1065:  a field declaration cannot have a type involving a variable length array
Pe1066:  declaration of %n had a different meaning during compilation of %sq
Pe1067:  expected "template"
Pe1068:  "export" cannot be used on an explicit instantiation
Pe1069:  "export" cannot be used on this declaration
Pe1070:  a member of an unnamed namespace cannot be declared "export"
Pe1071:  a template cannot be declared "export" after it has been defined
Pe1072:  a declaration cannot have a label
Pe1073:  support for exported templates is disabled
Pe1075:  %n already defined during compilation of %sq
Pe1076:  %n already defined in another translation unit
Pe1077:  a nonstatic local variable may not be used in a __based specification
Pe1078:  the option to list makefile dependencies may not be specified when compiling more than one translation unit
Pe1080:  the option to generate preprocessed output may not be specified when compiling more than one translation unit
Pe1081:  a field with the same name as its class cannot be declared in a class with a user-declared constructor
Pe1082:  "implicit_include" cannot be used when compiling more than one translation unit
Pe1083:  exported template file %sq is corrupted
Pe1084:  %n cannot be instantiated -- it has been explicitly specialized in the translation unit containing the exported definition
Pe1086:  the object has type qualifiers that are not compatible with the member %n
Pe1087:  no instance of %n matches the argument list and object (the object has type qualifiers that prevent a match)
Pe1088:  an attribute specifies a mode incompatible with %t
Pe1089:  there is no type with the width specified
Pe1090:  invalid alignment value specified by attribute
Pe1091:  invalid attribute for %t
Pe1094:  attribute %sq does not take arguments
Pe1096:  expected an attribute name
Pe1097:  unknown attribute %sq
Pe1098:  attributes may not appear here
Pe1099:  invalid argument to attribute %sq
Pe1101:  in "goto *expr", expr must have type "void *"
Pe1102:  "goto *expr" is nonstandard
Pe1103:  taking the address of a label is nonstandard
Pe1104:  file name specified more than once: %s
Pe1105:  #warning directive: %s
Pe1107:  the "transparent_union" attribute only applies to unions, and %t is not a union
Pe1108:  the "transparent_union" attribute is ignored on incomplete types
Pe1109:  %t cannot be transparent because %n does not have the same size as the first field
Pe1110:  %t1 cannot be transparent because it has a field of type %t2 which is not the same size as the first field
Pe1112:  attribute %sq does not apply to local variables
Pe1113:  attributes are not permitted in a function definition
Pe1115:  the second constant in a case range must be larger than the first
Pe1116:  an asm name is not permitted in a function definition
Pe1117:  an asm name is ignored in a typedef
Pe1118:  unknown register name "%s"
Pe1120:  unknown asm constraint modifier '%s'
Pe1121:  unknown asm constraint letter '%s'
Pe1122:  asm operand has no constraint letter
Pe1123:  an asm output operand must have one of the '=' or '+' modifiers
Pe1124:  an asm input operand may not have the '=', '+' or '&' modifiers
Pe1127:  register "%s" used more than once
Pe1128:  register "%s" is both used and clobbered
Pe1129:  register "%s" clobbered more than once
Pe1130:  register "%s" has a fixed purpose and may not be used in an asm statement
Pe1131:  register "%s" has a fixed purpose and may not be clobbered in an asm statement
Pe1132:  an empty clobbers list must be omitted entirely
Pe1133:  expected an asm operand
Pe1134:  expected a register to clobber
Pe1135:  "format" attribute requires an ellipsis parameter
Pe1136:  first substitution argument is not the first variable argument
Pe1137:  format argument index is greater than number of parameters
Pe1138:  format argument does not have string type
Pe1139:  the "template" keyword used for syntactic disambiguation may only be used within a template
Pe1142:  attribute %sq does not apply to non-function type %t
Pe1143:  arithmetic on pointer to void or function type
Pe1144:  storage class must be auto or register
Pe1145:  %t1 would have been promoted to %t2 when passed through the ellipsis parameter; use the latter type instead
Pe1146:  %sq is not a base class member
Pe1147:  __super cannot appear after "::"
Pe1148:  __super may only be used in a class scope
Pe1149:  __super must be followed by "::"
Pe1151:  mangled name is too long
Pe1152:  declaration aliased to undefined entity %sq
Pe1153:  declaration does not match its alias %n
Pe1154:  entity declared as alias cannot have definition
Pe1155:  variable-length array field type will be treated as zero-length array field type
Pe1156:  nonstandard cast on lvalue ignored
Pe1157:  unrecognized flag name: %s
Pe1158:  void return type cannot be qualified
Pe1159:  the auto specifier is ignored here (invalid in standard C/C++)
Pe1160:  a reduction in alignment without the "packed" attribute is ignored
Pe1161:  a member template corresponding to %no is declared as a template of a different kind in another translation unit
Pe1162:  excess initializers are ignored
Pe1163:  va_start can appear only in a function with an ellipsis parameter
Pe1164:  the "short_enums" option is only valid in GNU C and GNU C++ modes
Pe1165:  invalid export information file %sq1 at line number %s2
Pe1166:  statement expressions are only allowed in block scope
Pe1168:  an asm name is ignored on a non-register automatic variable
Pe1170:  unrecognized UPC pragma
Pe1171:  shared block size does not match one previously specified
Pe1172:  bracketed expression is assumed to be a block size specification rather than an array dimension
Pe1173:  the block size of a shared array must be greater than zero
Pe1174:  multiple block sizes not allowed
Pe1175:  strict or relaxed requires shared
Pe1176:  THREADS not allowed in this context
Pe1177:  block size specified exceeds the maximum value of %s
Pe1178:  function returning shared is not allowed
Pe1180:  one dimension of an array of a shared type must be a multiple of THREADS when the number of threads is nonconstant
Pe1181:  shared type inside a struct or union is not allowed
Pe1182:  parameters may not have shared types
Pe1183:  a dynamic THREADS dimension requires a definite block size
Pe1184:  shared variables must be static or extern
Pe1185:  argument of upc_blocksizeof is a pointer to a shared type (not shared type itself)
Pe1186:  affinity expression ignored in nested upc_forall
Pe1187:  branching into or out of a upc_forall loop is not allowed
Pe1188:  affinity expression must have a shared type or point to a shared type
Pe1189:  affinity has shared type (not pointer to shared)
Pe1190:  shared void* types can only be compared for equality
Pe1191:  UPC mode is incompatible with C++ and K&R modes
Pe1192:  null (zero) character in input line ignored
Pe1193:  null (zero) character in string or character constant
Pe1194:  null (zero) character in header name
Pe1195:  declaration in for-initializer hides a declaration in the surrounding scope
Pe1196:  the hidden declaration is %p
Pe1197:  the prototype declaration of %nfd is ignored after this unprototyped redeclaration
Pe1199:  %npd must have external C linkage
Pe1200:  variable declaration hides declaration in for-initializer
Pe1201:  typedef %sq may not be used in an elaborated type specifier
Pe1202:  call of zero constant ignored
Pe1203:  parameter %sq may not be redeclared in a catch clause of function try block
Pe1204:  the initial explicit specialization of %n must be declared in the namespace containing the template
Pe1205:  "cc" clobber ignored
Pe1206:  "template" must be followed by an identifier
Pe1207:  MYTHREAD not allowed in this context
Pe1208:  layout qualifier cannot qualify pointer to shared
Pe1209:  layout qualifier cannot qualify an incomplete array
Pe1210:  declaration of %sq hides handler parameter
Pe1211:  nonstandard cast to array type ignored
Pe1212:  this pragma cannot be used in a _Pragma operator (a #pragma directive must be used)
Pe1213:  field uses tail padding of a base class
Pe1214:  GNU C++ compilers may use bit field padding
Pe1215:  %nd was declared deprecated
Pe1216:  an asm name is not allowed on a nonstatic member declaration
Pe1217:  unrecognized format function type %sq ignored
Pe1218:  base class %no1 uses tail padding of base class %no2
Pe1219:  the "init_priority" attribute can only be used for definitions of static data members and namespace scope variables of class types
Pe1220:  requested initialization priority is reserved for internal use
Pe1221:  this anonymous union/struct field is hidden by %nd
Pe1222:  invalid error number
Pe1223:  invalid error tag
Pe1224:  expected an error number or error tag
Pe1225:  size of class is affected by tail padding
Pe1226:  labels can be referenced only in function definitions
Pe1227:  transfer of control into a statement expression is not allowed
Pe1229:  this statement is not allowed inside of a statement expression
Pe1230:  a class that is not trivially copyable cannot be defined inside a statement expression
Pe1232:  a dynamically-initialized local static variable is not allowed inside of a statement expression
Pe1233:  a variable-length array is not allowed inside of a statement expression
Pe1234:  a statement expression is not allowed inside of a default argument
Pe1235:  nonstandard conversion between pointer to function and pointer to data
Pe1236:  interface types cannot have virtual base classes
Pe1237:  interface types cannot specify "private" or "protected"
Pe1238:  interface types can only derive from other interface types
Pe1239:  %t is an interface type
Pe1240:  interface types cannot have typedef members
Pe1241:  interface types cannot have user-declared constructors or destructors
Pe1242:  interface types cannot have user-declared member operators
Pe1243:  interface types cannot be declared in functions
Pe1245:  interface types cannot have data members
Pe1246:  interface types cannot contain friend declarations
Pe1248:  interface types cannot be nested class types
Pe1249:  interface types cannot have member templates
Pe1250:  interface types cannot have static member functions
Pe1251:  this pragma cannot be used in a __pragma operator (a #pragma directive must be used)
Pe1252:  qualifier must be base class of %t
Pe1253:  declaration must correspond to a pure virtual member function in the indicated base class
Pe1254:  integer overflow in internal computation due to size or complexity of %t
Pe1255:  integer overflow in internal computation
Pe1256:  __w64 can only be specified on int, long, and pointer types
Pe1257:  potentially narrowing conversion when compiled in an environment where int, long, or pointer types are 64 bits wide
Pe1258:  current value of pragma pack is %s
Pe1259:  arguments for pragma pack(show) are ignored
Pe1262:  earlier __declspec(align(...)) ignored
Pe1263:  expected an argument value for the %sq attribute parameter
Pe1264:  invalid argument value for the %sq attribute parameter
Pe1265:  expected a boolean value for the %sq attribute parameter
Pe1266:  a positional argument cannot follow a named argument in an attribute
Pe1267:  attribute %sq1 has no parameter named %sq2
Pe1268:  expected an argument list for the %sq attribute
Pe1269:  expected a "," or "]"
Pe1270:  attribute argument %sq has already been given a value
Pe1271:  a value cannot be assigned to the %sq attribute
Pe1272:  a throw expression may not have pointer-to-incomplete type
Pe1273:  alignment-of operator applied to incomplete type
Pe1274:  %sq may only be used as a standalone attribute
Pe1275:  %sq attribute cannot be used here
Pe1277:  attributes are not allowed here
Pe1278:  invalid argument value for the %sq attribute parameter
Pe1279:  too many attribute arguments
Pe1280:  conversion from inaccessible base class %t is not allowed
Pe1281:  option "export" requires distinct template signatures
Pe1282:  string literals with different character kinds cannot be concatenated
Pe1283:  GNU layout bug not emulated because it places virtual base %no1 outside %no2 object boundaries
Pe1284:  virtual base %no1 placed outside %no2 object boundaries
Pe1285:  nonstandard qualified name in namespace member declaration
Pe1286:  reduction in alignment ignored
Pe1287:  const qualifier ignored
Pe1289:  invalid GNU asm qualifiers
Pe1290:  a class type that is not trivially copyable passed through ellipsis
Pe1291:  a class type that cannot be trivially copied cannot be fetched by va_arg
Pe1292:  the 'u' or 'U' suffix must appear before the 'l' or 'L' suffix in a fixed-point literal
Pe1293:  option "fixed_point" can be used only when compiling C
Pe1294:  integer operand may cause fixed-point overflow
Pe1295:  fixed-point constant is out of range
Pe1296:  fixed-point value cannot be represented exactly
Pe1297:  constant is too large for long long; given unsigned long long type (nonstandard)
Pe1298:  layout qualifier cannot qualify pointer to shared void
Pe1299:  duplicate THREADS in multidimensional array type
Pe1300:  a strong using-directive may only appear in a namespace scope
Pe1301:  %nf declares a non-template function -- add <> to refer to a template instance
Pe1302:  operation may cause fixed-point overflow
Pe1303:  expression must have integral, enum, or fixed-point type
Pe1304:  expression must have integral or fixed-point type
Pe1305:  function declared with "noreturn" does return
Pe1306:  asm name ignored because it conflicts with a previous declaration
Pe1307:  class member typedef may not be redeclared
Pe1308:  taking the address of a temporary
Pe1309:  attributes are ignored on a class declaration that is not also a definition
Pe1310:  fixed-point value implicitly converted to floating-point type
Pe1311:  fixed-point types have no classification
Pe1312:  a template parameter may not have fixed-point type
Pe1313:  hexadecimal floating-point constants are not allowed
Pe1314:  option "named_address_spaces" can be used only when compiling C
Pe1315:  floating-point value does not fit in required fixed-point type
Pe1316:  value cannot be converted to fixed-point value exactly
Pe1317:  fixed-point conversion resulted in a change of sign
Pe1318:  integer value does not fit in required fixed-point type
Pe1319:  fixed-point operation result is out of range
Pe1320:  multiple named address spaces
Pe1321:  variable with automatic storage duration cannot be stored in a named address space
Pe1322:  type cannot be qualified with named address space
Pe1323:  function type cannot be qualified with named address space
Pe1324:  field type cannot be qualified with named address space
Pe1325:  fixed-point value does not fit in required floating-point type
Pe1326:  fixed-point value does not fit in required integer type
Pe1327:  value does not fit in required fixed-point type
Pe1328:  option "named_registers" can be used only when compiling C
Pe1329:  a named-register storage class is not allowed here
Pe1330:  %nd redeclared with incompatible named-register storage class
Pe1331:  named-register storage class cannot be specified for aliased variable
Pe1332:  named-register storage specifier is already in use
Pe1333:  option "embedded_c" cannot be combined with options to control individual Embedded C features
Pe1334:  invalid EDG_BASE directory: %s
Pe1336:  invalid predefined macro entry at line %s: %s2
Pe1337:  invalid macro mode name %sq
Pe1338:  incompatible redefinition of predefined macro %sq
Pe1339:  redeclaration of %nd is missing a named-register storage class
Pe1340:  named register is too small for the type of the variable
Pe1341:  arrays cannot be declared with named-register storage class
Pe1342:  const_cast to enum type is nonstandard
Pe1343:  option "embedded_c" can be used only when compiling C
Pe1344:  a named address space qualifier is not allowed here
Pe1345:  an empty initializer is invalid for an array with unspecified bound
Pe1346:  function returns incomplete class type %t
Pe1347:  %n has already been initialized; the out-of-class initializer will be ignored
Pe1348:  declaration hides %nd
Pe1349:  a parameter cannot be allocated in a named address space
Pe1350:  invalid suffix on fixed-point or floating-point constant
Pe1351:  a register variable cannot be allocated in a named address space
Pe1352:  expected "SAT" or "DEFAULT"
Pe1353:  %n has no corresponding member operator delete%s (to be called if an exception is thrown during initialization of an allocated object)
Pe1354:  a thread-local variable cannot be declared with "dllimport" or "dllexport"
Pe1355:  a function return type cannot be qualified with a named address space
Pe1356:  an initializer cannot be specified for a flexible array member whose elements have a nontrivial destructor
Pe1357:  an initializer cannot be specified for an indirect flexible array member
Pe1358:  invalid GNU version number: %s
Pe1359:  variable attributes appearing after a parenthesized initializer are ignored
Pe1360:  the result of this cast cannot be used as an lvalue
Pe1361:  negation of an unsigned fixed-point value
Pe1364:  register names can only be used for register variables
Pe1365:  named-register variables cannot have void type
Pe1367:  parameters cannot have link scope specifiers
Pe1368:  multiple link scope specifiers
Pe1369:  link scope specifiers can only appear on functions and variables with external linkage
Pe1370:  a redeclaration cannot weaken a link scope
Pe1371:  link scope specifier not allowed on this declaration
Pe1372:  nonstandard qualified name in global scope declaration
Pe1373:  implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
Pe1374:  explicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
Pe1375:  conversion from pointer to same-sized integral type (potential portability problem)
Pe1377:  friend specifier is not allowed in a class definition; friend specifier is ignored
Pe1378:  only static and extern variables can use thread-local storage
Pe1379:  multiple thread-local storage specifiers
Pe1380:  virtual %n was not defined (and cannot be defined elsewhere because it is a member of an unnamed namespace)
Pe1381:  carriage return character in source line outside of comment or character/string literal
Pe1382:  expression must have fixed-point type
Pe1383:  invalid use of access specifier is ignored
Pe1384:  pointer converted to bool
Pe1385:  pointer-to-member converted to bool
Pe1386:  storage specifier ignored
Pe1387:  dllexport and dllimport are ignored on class templates
Pe1388:  base class dllexport/dllimport specification differs from that of the derived class
Pe1389:  redeclaration cannot add dllexport/dllimport to %nod
Pe1390:  dllexport/dllimport conflict with %nod; dllexport assumed
Pe1391:  cannot define dllimport entity
Pe1392:  dllexport/dllimport requires external linkage
Pe1393:  a member of a class declared with dllexport/dllimport cannot itself be declared with such a specifier
Pe1394:  field of class type without a DLL interface used in a class with a DLL interface
Pe1395:  parenthesized member declaration is nonstandard
Pe1396:  white space between backslash and newline in line splice ignored
Pe1397:  dllexport/dllimport conflict with %nod; dllimport/dllexport dropped
Pe1398:  invalid member for anonymous member class -- class %t has a disallowed member function
Pe1399:  nonstandard reinterpret_cast
Pe1400:  positional format specifier cannot be zero
Pe1401:  a local class cannot reference a variable-length array type from an enclosing function
Pe1402:  member %nd already has an explicit dllexport/dllimport specifier
Pe1403:  a variable-length array is not allowed in a function return type
Pe1404:  variable-length array type is not allowed in pointer to member of type %t
Pe1405:  the result of a statement expression cannot have a type involving a variable-length array
Pe1406:  support for trigraphs is disabled
Pe1407:  the %sq attribute can only appear on functions and variables with external linkage
Pe1408:  strict mode is incompatible with treating namespace std as an alias for the global namespace
Pe1414:  invalid symbolic operand name %sq
Pe1415:  a symbolic match constraint must refer to one of the first ten operands
Pe1416:  use of __if_exists is not supported in this context
Pe1417:  __if_exists block not closed in the same scope in which it was opened
Pe1418:  thread-local variable cannot be dynamically initialized
Pe1419:  conversion drops "__unaligned" qualifier
Pe1420:  some enumerator values cannot be represented by the integral type underlying the enum type
Pe1421:  default argument is not allowed on a friend class template declaration
Pe1422:  multicharacter character literal (potential portability problem)
Pe1423:  expected a class, struct, or union type
Pe1424:  second operand of offsetof must be a field
Pe1425:  second operand of offsetof may not be a bit field
Pe1426:  cannot apply offsetof to a member of a virtual base
Pe1427:  offsetof applied to a type other than a standard-layout class
Pe1428:  default arguments are not allowed on a friend declaration of a member function
Pe1429:  default arguments are not allowed on friend declarations that are not definitions
Pe1430:  redeclaration of %nd previously declared as a friend with default arguments is not allowed
Pe1431:  invalid qualifier for %t (a derived class is not allowed here)
Pe1432:  invalid qualifier for definition of class %t
Pe1433:  no prior push_macro for %sq
Pe1434:  wide string literal not allowed
Pe1436:  %sq is only allowed in C
Pe1437:  __ptr32 and __ptr64 must follow a "*"
Pe1438:  __ptr32 and __ptr64 cannot both apply
Pe1439:  template argument list of %sq must match the parameter list
Pe1440:  an incomplete class type is not allowed
Pe1441:  complex integral types are not supported
Pe1442:  __real and __imag can only be applied to complex values
Pe1443:  __real/__imag applied to real value
Pe1444:  %nd was declared deprecated (%sq)
Pe1445:  invalid redefinition of %nd
Pe1446:  dllimport/dllexport applied to a member of an unnamed namespace
Pe1447:  __thiscall can only appear on nonstatic member function declarations
Pe1448:  __thiscall not allowed on function with ellipsis parameter
Pe1449:  explicit specialization of %n must precede its first use (%p)
Pe1450:  a sealed class type cannot be used as a base class
Pe1451:  duplicate class modifier
Pe1452:  a member function cannot have both the "abstract" and "sealed" modifiers
Pe1453:  a sealed member cannot be pure virtual
Pe1454:  nonvirtual function cannot be declared with "abstract" or "sealed" modifier
Pe1455:  member function declared with "override" does not override a base class member
Pe1456:  cannot override sealed %nd
Pe1457:  %nd was declared with the class modifier "abstract"
Pe1534:  duplicate function modifier
Pe1535:  invalid character for char16_t literal
Pe1537:  unrecognized calling convention %s, must be one of:
Pe1541:  underlying type of enum type must be an integral type
Pe1542:  some enumerator constants cannot be represented by %t
Pe1543:  %sq not allowed in current mode
Pe1544:  type traits helpers option can be used only when compiling C++
Pe1545:  attribute "sentinel" requires an ellipsis parameter
Pe1546:  argument must be a constant null pointer value
Pe1547:  insufficient number of arguments for sentinel value
Pe1548:  sentinel argument must correspond to an ellipsis parameter
Pe1549:  __declspec(implementation_key(...) can appear only between #pragma start_map_region and #pragma stop_map_region
Pe1550:  #pragma start_map_region already active: pragma ignored
Pe1551:  no #pragma start_map_region is currently active: pragma ignored
Pe1552:  %n cannot be used to name a destructor (a type name is required)
Pe1553:  nonstandard empty wide character literal treated as L'\0'
Pe1554:  "typename" may not be specified here
Pe1555:  a non-placement operator delete must be visible in a class with a virtual destructor
Pe1556:  name linkage conflicts with previous declaration of %nd
Pe1557:  alias creates cycle of aliased entities
Pe1559:  a variable with static storage duration allocated in a specific register cannot be declared with an initializer
Pe1560:  a variable allocated in a specific register must be trivially copyable
Pe1561:  predefined meaning of %no discarded
Pe1563:  class type not suitable for use with designators
Pe1565:  anonymous union qualifier is nonstandard
Pe1566:  anonymous union qualifier is ignored
Pe1568:  __declspec(%s) ignored (it has no meaning for a C struct)
Pe1569:  specifiers after comma between declarations are nonstandard
Pe1570:  nonstandard specifier ignored
Pe1571:  attributes are ignored on an enum declaration that is not also a definition
Pe1572:  declaring a reference with "mutable" is nonstandard
Pe1573:  a condition declaration for an array is always true
Pe1574:  static assertion failed with %sq
Pe1575:  visibility attribute ignored because it conflicts with a previous declaration
Pe1576:  field name resolves to more than one offset -- see %nod1 and %nod2
Pe1577:  %sq is not a field name
Pe1578:  case label value has already appeared in this switch %p
Pe1579:  a member function cannot have internal linkage
Pe1580:  declaration hides built-in %n
Pe1581:  declaration overloads built-in %n
Pe1582:  the option to list macro definitions may not be specified when compiling more than one translation unit
Pe1583:  unexpected parenthesis after declaration of %n (malformed parameter list or invalid initializer?)
Pe1584:  parentheses around a string initializer are nonstandard
Pe1586:  a variable declared with an auto type specifier cannot appear in its own initializer
Pe1587:  cannot deduce "auto" type
Pe1588:  initialization with "{...}" is not allowed for "auto" type
Pe1589:  "auto" type cannot appear in top-level array type
Pe1590:  "auto" type cannot appear in top-level function type
Pe1591:  a member of type %t cannot have an in-class initializer
Pe1592:  a member with an in-class initializer must be const
Pe1593:  cannot deduce "auto" type (initializer required)
Pe1594:  "auto" type is %t1 for this entity, but was previously implied to be %t2
Pe1595:  invalid constructor declaration
Pe1596:  invalid use of a type qualifier
Pe1597:  a union cannot be abstract or sealed
Pe1598:  "auto" is not allowed here
Pe1599:  definition of base class type not completed yet
Pe1600:  "extern template" cannot refer to a specialization of static %nd
Pe1601:  "extern template" cannot follow explicit instantiation of %n
Pe1602:  __declspec(restrict) requires a function returning a pointer type
Pe1603:  the "report_gnu_extensions" option is only valid in GNU C and GNU C++ modes
Pe1604:  variable-length array types are nonstandard
Pe1605:  designators are nonstandard
Pe1606:  this designator syntax is a GNU extension
Pe1607:  compound literals are nonstandard
Pe1608:  statement expressions are a GNU extension
Pe1609:  asm name ignored for previously defined entity
Pe1610:  attributes are a GNU extension
Pe1611:  extended asm syntax is a GNU feature
Pe1612:  volatile asm declarations are a GNU extension
Pe1613:  asm name specifiers are a GNU extension
Pe1614:  the "__restrict" qualifier is nonstandard
Pe1615:  "typeof" is a GNU extension
Pe1616:  modifying the size or signedness of a typedef is nonstandard
Pe1617:  zero-length arrays are a GNU extension
Pe1618:  flexible array members are nonstandard
Pe1619:  attribute "nonnull" references nonpointer parameter
Pe1620:  argument for attribute "nonnull" is larger than number of parameters
Pe1621:  no parameter has pointer type
Pe1622:  null argument provided for parameter marked with attribute "nonnull"
Pe1623:  the destructor for %t1 has been suppressed because the destructor for %t2 is inaccessible
Pe1624:  the suppressed destructor for %t is needed
Pe1625:  routine is both "inline" and "noinline"/"inline = never"
Pe1626:  invalid cleanup routine
Pe1627:  attribute "cleanup" requires automatic storage duration
Pe1628:  attribute "cleanup" does not apply to parameters
Pe1629:  cleanup routine has invalid type
Pe1630:  call of cleanup routine requires suspect conversion
Pe1631:  __sptr and __uptr must follow a "*"
Pe1632:  __sptr and __uptr cannot both be specified
Pe1633:  widening pointer conversion from %t1 to %t2 extends sign bit
Pe1634:  __sptr and __uptr don't apply to pointer-to-member types
Pe1635:  the declaration of the copy assignment operator for %t has been suppressed because %n is const
Pe1636:  the declaration of the copy assignment operator for %t has been suppressed because %n has reference type
Pe1637:  the declaration of the copy assignment operator for %t1 has been suppressed because that of %t2 was suppressed
Pe1638:  the declaration of the copy assignment operator for %t1 has been suppressed because that of %t2 is ambiguous
Pe1639:  the declaration of the copy assignment operator for %t1 has been suppressed because that of %t2 is inaccessible
Pe1640:  the declaration of the copy constructor for %t1 has been suppressed because that of %t2 was suppressed
Pe1641:  the declaration of the copy constructor for %t1 has been suppressed because that of %t2 is ambiguous
Pe1642:  the declaration of the copy constructor for %t1 has been suppressed because that of %t2 is inaccessible
Pe1643:  the destructor for %t1 will not be called because it is inaccessible and the destructor for %t2 was suppressed
Pe1644:  definition at end of file not followed by a semicolon or a declarator
Pe1645:  first argument must be a pointer to integer or enumeration type
Pe1646:  synchronized operations are valid only on objects of size 1, 2, 4, or 8
Pe1647:  extra arguments ignored
Pe1648:  '=' assumed following macro name %sq in command-line definition
Pe1649:  white space is required between the macro name %sq and its replacement text
Pe1650:  result of call is not used
Pe1651:  attribute "warn_unused_result" is ignored for void return type
Pe1653:  dllimport/dllexport is ignored on redeclaration using a qualified name
Pe1654:  too many characters in character literal -- extra leading characters ignored
Pe1655:  %n cannot be declared inline after its definition %p
Pe1658:  a template argument may not reference a type with no name linkage
Pe1659:  "virtual" is ignored here
Pe1660:  a template argument may not reference a variable-length array type
Pe1661:  a universal character name cannot designate a surrogate code point
Pe1662:  #include_next cannot be used in the primary source file
Pe1663:  %no1 cannot be specified in a template member definition -- %no2 assumed instead
Pe1664:  attribute %sq is ignored on local function declaration
Pe1665:  concatenation with %sq in %n does not create a valid token
Pe1666:  %no is ambiguous (%n2 assumed)
Pe1667:  a type qualifier is not allowed on a static member function
Pe1668:  a type qualifier is not allowed on a constructor or destructor
Pe1669:  a type qualifier is not allowed on operator new or operator delete
Pe1670:  a type qualifier is not allowed on a nonmember function
Pe1671:  __assume expression with side effects discarded
Pe1672:  unrecognized Unicode source kind (must be one of UTF-8, UTF-16, UTF-16LE, UTF-16BE): %s
Pe1673:  Unicode character with hex value %s not representable in preprocessing output
Pe1674:  requested constructor/destructor priority is reserved for internal use
Pe1675:  unrecognized GCC pragma
Pe1676:  unrecognized GCC visibility pragma directive
Pe1677:  unrecognized visibility kind
Pe1678:  visibility pragma was still active
Pe1679:  no matching visibility push
Pe1680:  typeid of incomplete type
Pe1682:  array %n assumed to have one element
Pe1683:  vector_size attribute requires an arithmetic or enum type
Pe1684:  vector size is too large
Pe1685:  the number of elements in a vector must be a power of two
Pe1686:  vector size must be a multiple of the element size
Pe1687:  mixed vector-scalar operation not allowed
Pe1688:  operation requires two vectors of the same size
Pe1689:  template-dependent vector size is not allowed
Pe1692:  vector_size attribute is not allowed with a complex element type
Pe1694:  vector operation requires identical element types
Pe1695:  vector operation does not apply to vector with non-integral type
Pe1696:  cannot open %s file %sq2
Pe1697:  cannot open %s file %sq2: %s3
Pe1703:  error while writing %s file: %s2
Pe1712:  IL output
Pe1713:  conversion drops "__restrict" qualifier
Pe1714:  unable to obtain mapped memory for %sq: %s2
Pe1715:  restrict qualifier is ignored
Pe1717:  array of elements containing a flexible array member is nonstandard
Pe1718:  a template parameter may not have a vector type
Pe1719:  the initialization of %n1 will be done before that of %n2
Pe1721:  inheritance kind is ignored on an enum specifier
Pe1723:  modifier is ignored on an enum specifier
Pe1724:  identifier character cannot be represented in Unicode
Pe1725:  header name contains characters that cannot be represented in Unicode
Pe1726:  %sq is not a valid locale name
Pe1727:  declaring a void parameter list with a template parameter is nonstandard
Pe1728:  lambdas option can be used only when compiling C++
Pe1729:  explicit capture matches default
Pe1730:  %n is not a variable
Pe1731:  a variable with static storage duration cannot be captured in a lambda
Pe1732:  "this" cannot be captured by reference
Pe1733:  "this" cannot be used inside the body of this lambda
Pe1734:  a member of an outer-scope anonymous union cannot be referenced inside the body of a lambda
Pe1735:  an enclosing-function local variable cannot be referenced in a lambda body unless it is in the capture list
Pe1736:  invalid reference to an outer-scope local variable in a lambda body
Pe1737:  a local variable outside the current function scope cannot be captured
Pe1738:  the enclosing-function "this" cannot be referenced in a lambda body unless it is in the capture list
Pe1740:  lambda captured variable of type %t1 cannot be copied to closure class field of type %t2
Pe1741:  invalid template directory: %s
Pe1749:  enumeration value is outside the range of its underlying type (%t)
Pe1750:  "\" followed by white space is not a line splice
Pe1751:  this dynamic_cast cannot be done without runtime type information, which is disabled
Pe1752:  conversion to %t is ambiguous; direct base selected
Pe1753:  an internal buffer would be too large
Pe1754:  C++ exception handler used, but exception handling semantics have not been specified
Pe1755:  type qualifier ignored on constructor
Pe1756:  a variable captured by a lambda cannot have a type involving a variable-length array
Pe1757:  conversion between incompatible vector types
Pe1758:  expected a "{" introducing a lambda body
Pe1759:  rvalue references option can be used only when compiling C++
Pe1760:  a type qualifier is not allowed on a lambda
Pe1761:  a name cannot appear more than once in a capture-list
Pe1762:  explicit template arguments ignored
Pe1763:  a lambda is not allowed in a constant expression
Pe1764:  %t is not a class type
Pe1765:  "delete" applied to a pointer-to-array type treated as delete[]
Pe1766:  "delete" applied to a pointer-to-array type is nonstandard; treated as delete[]
Pe1767:  %n cannot be called with the given argument list
Pe1768:  an rvalue reference cannot be bound to an lvalue
Pe1769:  a nontype template parameter cannot have rvalue reference type
Pe1770:  type qualifiers are ignored (underlying type is a reference)
Pe1771:  %n, declared using a local type, must be defined in this translation unit
Pe1772:  %n, declared using a type with no linkage, must be defined in this translation unit
Pe1773:  the operand of an rvalue reference dynamic_cast must have a complete class type
Pe1774:  "= default" can only appear on default constructors, copy/move constructors, copy/move assignment operators, and destructors
Pe1775:  "= delete" can only appear on the first declaration of a function
Pe1776:  %npd cannot be referenced -- it is a deleted function
Pe1777:  a lambda is not allowed in an unevaluated expression
Pe1778:  __builtin_va_arg_pack/__builtin_va_arg_pack_len can appear only in an inline function with an ellipsis parameter
Pe1779:  "= default" cannot be specified on a friend declaration
Pe1780:  expected a C++ keyword
Pe1782:  offset is not constant
Pe1783:  unrecognized #pragma comment type %sq
Pe1784:  option to control whether "auto" is a type specifier can be used only when compiling C++
Pe1785:  option to control whether "auto" is a storage class can be used only when compiling C++
Pe1786:  the type specifier and storage class specifier meanings of "auto" cannot both be disabled
Pe1787:  invalid string in #pragma comment
Pe1788:  deleted function overrides nondeleted %n
Pe1789:  nondeleted function overrides deleted %n
Pe1790:  the default constructor of %t cannot be referenced -- it is a deleted function
Pe1791:  an rvalue reference is not allowed as a catch type
Pe1792:  default arguments of %n is incompatible with a declaration in another translation unit
Pe1793:  default arguments of %n were different during compilation of %sq
Pe1795:  initializer for %n is different in another translation unit
Pe1796:  initializer for %n was different during compilation of %sq
Pe1797:  a designator into a template-dependent type is not allowed
Pe1798:  unrecognized conformance kind
Pe1799:  expected "on" or "off"
Pe1800:  #pragma conform(forScope) stack is empty
Pe1801:  no previous #pragma conform(forScope) entry matches %sq
Pe1802:  forScope behavior is nonstandard
Pe1803:  forScope behavior is standard
Pe1804:  function "main" cannot be deleted
Pe1805:  type qualifiers are meaningless here
Pe1806:  invalid type for defaulted assignment operator
Pe1807:  function templates cannot be defaulted
Pe1808:  invalid type for defaulted constructor
Pe1809:  function call requires one argument
Pe1810:  function call requires a real floating-point argument
Pe1811:  a copy constructor with a default argument cannot be defaulted
Pe1812:  a predeclared function cannot be deleted
Pe1813:  empty dependent statement in if-statement
Pe1814:  empty dependent statement in "else" clause of if-statement
Pe1815:  %nfd, required for copy that was eliminated, cannot be referenced -- it is a deleted function
Pe1816:  nonstandard first parameter %t of "main", expected "int"
Pe1817:  nonstandard number of parameters for "main", expected zero or two parameters
Pe1818:  nonstandard second parameter %t of "main", expected "char *[]" or "char **"
Pe1819:  %sq was specified as both a system and non-system include directory -- the non-system entry will be ignored
Pe1820:  option to control move constructors and move assignment operators can be used only when compiling C++
Pe1823:  a trailing return type requires the "auto" type specifier
Pe1824:  a trailing return type cannot appear in a nested declarator
Pe1825:  a function declarator with a trailing return type must be preceded by a simple "auto" type specifier
Pe1826:  "auto" function requires a trailing return type
Pe1827:  a member template cannot have a pure specifier
Pe1828:  string literal too long -- excess characters ignored
Pe1829:  option to control the nullptr keyword can be used only when compiling C++
Pe1830:  std::nullptr_t converted to bool
Pe1833:  attribute %sq does not allow an empty argument list
Pe1834:  attribute appears more than once
Pe1835:  attribute %sq does not apply here
Pe1836:  attribute %sq does not apply to bit fields
Pe1837:  attribute %sq requires a bit field
Pe1838:  attribute %sq does not apply to member functions
Pe1839:  attribute %sq requires a member function
Pe1840:  attribute %sq does not apply to virtual functions
Pe1841:  attribute %sq requires a virtual function
Pe1842:  attribute %sq does not apply to pure virtual functions
Pe1843:  attribute %sq requires a pure virtual function
Pe1844:  attribute %sq does not apply to register variables
Pe1845:  attribute %sq requires a register variable
Pe1846:  attribute %sq did not appear on original declaration
Pe1847:  attributes are not allowed here
Pe1848:  attribute %sq must appear in a class definition
Pe1849:  "final" applied to a pure virtual function
Pe1850:  cannot override "final" %nd
Pe1851:  static %n treated as extern because it was referenced but not defined
Pe1852:  option to enable GNU-C89-style inlining can be used only when compiling C
Pe1853:  function was previously declared without the "gnu_inline" attribute
Pe1854:  the "gnu_inline" attribute is ignored on non-inline functions
Pe1855:  %n previously declared without the carries_dependency attribute
Pe1856:  invalid initializer for array %n
Pe1857:  must specify C++11 or C++14 mode when building runtime library
Pe1858:  attribute %sq does not apply to function types
Pe1859:  attribute %sq requires a function type
Pe1860:  attribute %sq does not apply to nonstatic member functions
Pe1861:  attribute %sq does not apply to automatic variables
Pe1862:  attribute %sq requires an automatic variable
Pe1863:  attribute %sq does not apply to a variable or function with external linkage
Pe1864:  attribute %sq requires a local variable
Pe1865:  attributes ignored here
Pe1866:  attribute does not apply to any entity
Pe1867:  bad attribute argument substitution
Pe1868:  the argument of the "tls_model" attribute must be "global-dynamic", "local-dynamic", "initial-exec", or "local-exec"
Pe1869:  the declaration %p specified a different "tls_model" argument
Pe1870:  attribute %sq does not apply to inline functions
Pe1871:  attribute %sq requires a inline function
Pe1872:  both file names in an include_alias pragma must use the same delimiter characters
Pe1873:  comparison between signed and unsigned operands
Pe1874:  attribute %sq ignored on unnamed type
Pe1875:  attribute %sq ignored because no definition follows
Pe1876:  thread locality is incompatible with a previous declaration of %nd
Pe1877:  this enclosing-function local variable cannot be referenced in this lambda body because an enclosing lambda does not allow implicit captures
Pe1878:  this attribute argument contains unmatched parentheses, brackets, or braces
Pe1879:  a call to __builtin_fpclassify requires five integral arguments followed by one floating-point argument
Pe1880:  the last argument in a call to __builtin_fpclassify must have a real floating-point type
Pe1881:  alignment cannot be set to less than the default alignment
Pe1882:  attributes are not allowed on explicit instantiations
Pe1883:  attribute %sq does not apply to a definition
Pe1884:  attribute %sq requires a definition
Pe1885:  standard attributes cannot appear on friend declarations that are not definitions
Pe1886:  specified alignment (%s1) is different from alignment (%s2) specified on a previous declaration
Pe1887:  alignment attribute must also appear on definition %p
Pe1888:  %n may not be used in the type-id of the alias-declaration
Pe1890:  %t cannot be transparent because its first field has a floating-point type
Pe1891:  %t cannot be transparent because its first field is a bit field
Pe1892:  virtual function of a "base_check" class overrides a base class member but lacks the "override" attribute
Pe1893:  "hiding" attribute specified on a declaration that does not hide a base class declaration
Pe1894:  "hiding" attribute specified on a declaration referred to by the using-declaration %p
Pe1895:  attribute "hiding" is required on a declaration (in a "base_check" class) that hides %nd
Pe1896:  %n is not defined in this translation unit but depends on a local type
Pe1897:  %n is not defined in this translation unit but depends on a type with no linkage
Pe1898:  attribute %sq is missing in another translation unit
Pe1899:  attribute %sq conflicts with another translation unit
Pe1900:  the "nonstd_gnu_keywords" option is only valid in GNU C and GNU C++ modes
Pe1901:  use of a const variable in a constant expression is nonstandard in C
Pe1902:  an initializer cannot be specified for a flexible array member with automatic storage duration
Pe1904:  a "final" class type cannot be used as a base class
Pe1905:  exported templates are no longer in the standard C++ language
Pe1906:  a template-dependent designator is not allowed
Pe1907:  second operand of offsetof may not be a field with reference type
Pe1908:  long lifetime temporaries are incompatible with other requested newer language features
Pe1909:  wide character string literal will not be quoted in diagnostics
Pe1910:  missing arguments for attribute %sq
Pe1911:  options "c++11" and "c++11_sfinae" require a different compiler configuration
Pe1912:  template parameter pack not at end of parameter list
Pe1913:  a parameter pack declaration is not allowed here
Pe1914:  a parameter pack cannot have a default
Pe1915:  C++/CLI can be enabled only in Microsoft C++ mode
Pe1916:  "value__" cannot be used as the name of an enumerator constant (it is a reserved name in this context)
Pe1917:  an explicit enumerator value is required in an enumeration type with boolean underlying type
Pe1919:  parameter pack %sq was referenced but not expanded
Pe1920:  pack expansion does not make use of any argument packs
Pe1921:  pack %sq does not have the same number of elements as %sq2
Pe1923:  vector_size attribute is not allowed with an enumeration type
Pe1924:  a property cannot be both static and virtual
Pe1925:  an indexed property cannot be trivial
Pe1926:  this declaration cannot appear in a property definition
Pe1927:  a qualified function type cannot be used to declare an accessor function
Pe1928:  an accessor function cannot have an ellipsis parameter
Pe1929:  a "get" accessor was already declared for this property %p
Pe1930:  a "set" accessor was already declared for this property %p
Pe1931:  a "get" accessor cannot have a parameter
Pe1932:  return type of "get" accessor does not match property type
Pe1933:  return type of "set" accessor must be void
Pe1934:  a property cannot declare an empty list of indices
Pe1935:  a property index cannot have type void
Pe1936:  index type does not match the corresponding parameter in the "set" accessor
Pe1937:  index type does not match the corresponding parameter in the "get" accessor
Pe1938:  index type is missing in the "set" accessor
Pe1939:  index type is missing in the "get" accessor
Pe1940:  "set" accessor is missing its value parameter
Pe1941:  accessor function has too many parameters
Pe1942:  the last parameter of the "set" accessor does not match the property type
Pe1943:  %sq requires C++/CLI mode
Pe1944:  error in Win32 API "%s": %s
Pe1945:  #using may only be used at global scope
Pe1947:  member name %sq is reserved by %nd
Pe1948:  expected a "["
Pe1949:  %[C++/CLI] mode requires microsoft_version >= 1600
Pe1950:  a default-indexed property cannot be static
Pe1951:  a property accessor cannot be both static and virtual
Pe1952:  a top-level visibility specifier cannot appear on a nested type declaration
Pe1953:  a top-level visibility specifier requires a type definition
Pe1954:  a trivial property cannot have a reference type
Pe1955:  a trivial property cannot have a const or volatile type
Pe1956:  %nd was previously declared as a different kind of enumeration type
Pe1957:  a variable captured by a lambda cannot have a %[managed] class type
Pe1958:  virtual function overriding with a covariant return type is not allowed in a %[managed] class
Pe1959:  array of handles is not allowed
Pe1960:  handle to array is not allowed
Pe1961:  handle to function is not allowed
Pe1962:  handle to void is not allowed
Pe1963:  handle to handle, pointer, or reference is not allowed
Pe1964:  tracking reference to function is not allowed
Pe1966:  a field cannot be a tracking reference
Pe1967:  a tracking reference cannot be combined with an ordinary reference in this way
Pe1968:  a variable with static storage duration cannot have a ref class type
Pe1969:  a %[managed] class cannot be unnamed
Pe1970:  a %[managed] class cannot be local
Pe1971:  %nd was previously declared as a different kind of class
Pe1972:  %nd was previously declared as a different kind of class template
Pe1973:  literal data members can only be members of %[managed] classes
Pe1974:  a literal data member must be initialized
Pe1975:  a literal data member of type %t is not allowed
Pe1976:  const has no effect on a literal data member
Pe1977:  initonly data members can only be members of %[managed] classes
Pe1978:  const has no effect on an initonly data member
Pe1979:  %nd has no "get" accessor
Pe1980:  %nd has no "set" accessor
Pe1981:  a static constructor cannot have parameters
Pe1982:  a static constructor cannot be a member template
Pe1983:  a compound lvalue is not allowed as an asm output operand
Pe1984:  properties can only be members of %[managed] classes
Pe1985:  a type qualifier is not allowed on a member function of a %[managed] class
Pe1986:  an ordinary pointer to a %[C++/CLI] ref class or interface class is not allowed
Pe1987:  an ordinary reference to a %[C++/CLI] ref class or interface class is not allowed
Pe1988:  override specifier does not name a base class member function
Pe1989:  override specifier designates a nonvirtual member %nd
Pe1990:  member function overrides %nd1 which is already overridden by %nd2
Pe1991:  at most one visibility specifier is allowed
Pe1992:  type %t used for delegate definition is not a function type
Pe1993:  delegate member types can only be members of %[managed] classes
Pe1994:  a tracking reference to a delegate type is not allowed
Pe1995:  a delegate type is not allowed here
Pe1996:  this pack expansion produced an empty list of expressions, and an expression is needed here
Pe1997:  an event cannot be both static and virtual
Pe1998:  events can only be members of %[managed] classes
Pe1999:  this declaration cannot appear in an event definition
Pe2000:  event type must be a handle-to-delegate type
Pe2001:  an "add" accessor was already declared for this event %p
Pe2002:  a "remove" accessor was already declared for this event %p
Pe2003:  a "raise" accessor was already declared for this event %p
Pe2004:  an event accessor cannot be both static and virtual
Pe2005:  return type of "add" and "remove" accessors must be void
Pe2006:  event accessor is missing its value parameter
Pe2007:  accessor function has too many parameters
Pe2008:  the type %t1 of the parameter of the event accessor does not match the event type (%t2)
Pe2009:  the type of the "raise" accessor does not match the event's delegate invocation type
Pe2010:  an event definition must include both "add" and "remove" accessors
Pe2011:  a static conversion function must accept exactly one argument
Pe2012:  static operator must have a parameter type T, T&, T%%, or T^ with T = %t
Pe2013:  the operand of sizeof... must be a parameter pack name
Pe2014:  the sizeof... operator can be used only in a variadic template
Pe2015:  event name cannot appear here
Pe2016:  a handle to a non-%[managed] class is not allowed
Pe2017:  a handle to an unscoped enum type is not allowed
Pe2018:  "property" attribute not allowed in %[managed] class
Pe2019:  a pure specifier ("= 0") followed by a definition is nonstandard
Pe2020:  the %[managed] nullptr type cannot be used here
Pe2021:  the "&" operator cannot be used to take the address of an object with a ref class type
Pe2022:  array of %[managed] class is not allowed
Pe2023:  a variable with static storage duration cannot have a handle or tracking reference type
Pe2024:  a variable captured by a lambda cannot be a handle or tracking reference
Pe2025:  a %[C++/CLI] parameter array requires a handle to a one-dimensional %[cli::array] type
Pe2026:  could not import metadata from file %sq
Pe2027:  the cli namespace cannot be extended
Pe2028:  the element type of a %[cli::array] must be a handle or value type
Pe2029:  invalid number of dimensions for %[cli::array] type
Pe2030:  a cli::interior_ptr/cli::pin_ptr must point to a standard class, a value class, an integer, a handle, or a standard pointer
Pe2031:  %t cannot be a class member
Pe2032:  a parameter of type cli::pin_ptr is not allowed
Pe2033:  invalid finalizer declaration
Pe2034:  a finalizer may not have parameters
Pe2035:  a type qualifier is not allowed on a finalizer
Pe2036:  a return type may not be specified on a finalizer
Pe2037:  a using-declaration may not name a finalizer
Pe2038:  a finalizer name must be qualified
Pe2039:  qualifier of finalizer name %t1 does not match type %t2
Pe2040:  %n cannot be used to name a finalizer (a type name is required)
Pe2041:  invalid finalizer name for type %t
Pe2042:  finalizer reference is ambiguous -- both %n1 and %n2 could be used
Pe2043:  a finalizer can only be a member of a ref class
Pe2045:  type used as finalizer name does not match type %t
Pe2046:  a finalizer does not exist for this type
Pe2047:  the "%%" operator can be used only on an object with a %[managed] class type
Pe2048:  a pointer, handle, or reference to a cli::interior_ptr is not allowed
Pe2049:  a pointer, handle, or reference to a cli::pin_ptr is not allowed
Pe2050:  a pointer or reference to a %[C++/CLI] array is not allowed
Pe2051:  a %[C++/CLI] array type is not allowed here
Pe2052:  a %[C++/CLI] ref class can only derive from another ref class or from interface classes
Pe2053:  a %[C++/CLI] value class can only derive from interface classes
Pe2054:  a %[C++/CLI] interface class can only derive from interface classes
Pe2055:  a ref class can have at most one direct ref base class (%t is already such a base)
Pe2056:  a standard class cannot derive from a %[managed] class
Pe2057:  a %[managed] class cannot have a virtual base
Pe2058:  a %[managed] class cannot have a "private" or "protected" base
Pe2059:  the "override" modifier requires a virtual function declaration with an explicit "virtual" keyword
Pe2060:  the "abstract" modifier requires a virtual function declaration with an explicit "virtual" keyword
Pe2061:  the "sealed" modifier requires a virtual function declaration with an explicit "virtual" keyword
Pe2062:  a named override specifier requires a virtual function declaration with an explicit "virtual" keyword
Pe2063:  a cli::pin_ptr return type is not allowed
Pe2064:  attribute %sq applies in %[C++/CLI] mode only
Pe2065:  a simple (non-tracking) reference cannot be bound to an entity on the managed heap
Pe2067:  "%s" not loaded from default assemblies
Pe2068:  list initialization syntax is a C++11 feature
Pe2069:  operand of sizeof may not be a ref class type or interface class type
Pe2070:  invalid number of subscripts for this %[cli::array] type
Pe2071:  a pointer-to-member is not valid for a %[managed] class
Pe2072:  private virtual member function of %[managed] class is not "sealed"
Pe2073:  modifier is not allowed on a destructor
Pe2074:  modifier is not allowed on a finalizer
Pe2075:  "virtual" has no effect on a destructor of a %[managed] class
Pe2076:  "new" or "override" is required because this declaration matches %nd
Pe2077:  "new" or "virtual" is required because this declaration matches %nd
Pe2078:  "new" or "override" are not valid here because the matching %nd is a member of an interface
Pe2079:  "new" modifier without a matching base ref class member
Pe2080:  %nd overridden with reduced access
Pe2081:  a reference of type %t1 cannot be initialized with a value of type %t2
Pe2082:  a copy constructor cannot be declared in a value class
Pe2083:  a default constructor cannot be declared in a value class
Pe2084:  a destructor cannot be declared in a value class
Pe2085:  an assignment operator cannot be declared in a value class
Pe2086:  non-value class %t cannot be the type of a member of a value class
Pe2087:  option "cppcli" requires a different compiler configuration
Pe2088:  exception specifications are not allowed on member functions of %[managed] classes
Pe2089:  a %[managed] class cannot declare a friend
Pe2092:  a local class definition is not allowed in a member function of a %[managed] class
Pe2093:  a local lambda is not allowed in a member function of a %[managed] class
Pe2094:  a member function of a %[C++/CLI] interface class type cannot have a definition
Pe2095:  a property definition must include at least one accessor ("get" or "set")
Pe2096:  default-indexed property conflicts with %nd
Pe2097:  %n1 cannot be used because it follows a parameter pack and cannot be deduced from the parameters of %n2
Pe2098:  this pack expansion produced more than one expression, and a single expression is needed here
Pe2099:  type must correspond to System::Boolean, System::Byte, System::SByte, System::Int16, System::UInt16, System::Int32, System::UInt32, System::Int64, or System::UInt64
Pe2100:  call of an object of a handle type without appropriate operator() or conversion functions to pointer-to-function type
Pe2101:  an unnamed parameter pack declaration cannot be parenthesized
Pe2102:  variadic templates can be enabled only when compiling C++
Pe2103:  property definition conflicts with %nd
Pe2106:  a generic parameter cannot have a default
Pe2107:  a generic can only have type parameters
Pe2108:  to be used with "for each" statements, type %t must provide nonstatic member function %sq
Pe2109:  "for each" cannot use member %n because it is static
Pe2110:  in this "for each" statement, no instance of %no is callable with an empty argument list
Pe2111:  "for each" cannot use member function "MoveNext" because the return type is invalid
Pe2112:  a "for each" statement cannot operate on an expression of type %t
Pe2113:  to be used with "for each" statements, type %t must provide a non-indexed property %sq
Pe2115:  in this "for each" statement, %t2 is not a valid enumerator (returned by "GetEnumerator" of %t1)
Pe2116:  expected "in"
Pe2117:  class %t has no suitable assignment operator (after operator synthesis)
Pe2118:  %sq is not a generic parameter
Pe2119:  %sq is not a generic parameter of the innermost generic parameter list
Pe2120:  invalid generic constraint
Pe2121:  invalid use of event member (only subscription, unsubscription, and invocation are allowed)
Pe2122:  invoking an event with no "raise" accessor is invalid
Pe2123:  only "+=" and "-=" are valid for events
Pe2124:  typeid of a %[managed] type is not allowed
Pe2125:  typeid of a %[managed] pointer type is not allowed
Pe2126:  name followed by "::typeid" must be a type name
Pe2127:  a member %sq of this type is reserved within a %[managed] class -- destructor intended?
Pe2128:  a member %sq of this type is reserved within a %[managed] class -- finalizer intended?
Pe2129:  %[System]::IDisposable::Dispose is missing or invalid
Pe2130:  %[System]::Object::Finalize is missing or invalid
Pe2131:  %n does not override %[System]::Object::Finalize
Pe2132:  the operand of a handle dynamic_cast must be a handle to a complete class type
Pe2133:  the operand of a tracking-reference dynamic_cast must be an lvalue of a complete class type
Pe2134:  the type in a dynamic_cast to a handle or tracking reference type must refer to a complete class
Pe2135:  an interior pointer cannot be cast to a native pointer
Pe2136:  explicit conversion operators can only be declared in ref and value class types
Pe2137:  explicit conversion operator cannot be virtual
Pe2138:  expression must have arithmetic or unscoped enum type
Pe2139:  expression must have arithmetic, unscoped enum, or pointer type
Pe2140:  expression must have integral or unscoped enum type
Pe2141:  expression must have integral, unscoped enum, or fixed-point type
Pe2142:  a built-in binary operator applied to a scoped enumeration requires two operands of the same type
Pe2143:  %[gcnew] cannot allocate an entity of type %t
Pe2144:  placement syntax cannot be used with %[gcnew]
Pe2145:  new can only be used with simple value types
Pe2146:  new cannot be used on a %[managed] class (%[gcnew] should be used instead)
Pe2147:  new cannot be used on a handle type
Pe2148:  %[gcnew] for a %[C++/CLI] array must have a new initializer or an array initializer
Pe2149:  an array initializer can only be used to initialize a %[C++/CLI] array type
Pe2150:  %[gcnew] does not allow auto
Pe2151:  too many array bounds
Pe2152:  too few array bounds
Pe2153:  too few arguments for %nf
Pe2154:  too many arguments for %nf
Pe2156:  no declaration of %nf accepts the number of generic arguments supplied
Pe2157:  invalid delegate initializer -- must be a function
Pe2158:  invalid delegate initializer -- more than one function matches the delegate type
Pe2159:  invalid delegate initializer -- function does not match the delegate type
Pe2160:  invalid delegate initializer -- an object is needed in addition to a function
Pe2161:  invalid delegate initializer -- function is not a member of a %[managed] class
Pe2162:  invalid delegate initializer -- object is not needed for the specified function
Pe2163:  invalid delegate initializer -- object has type %t1 but type %t2 is expected
Pe2164:  taking the address of a member function of a %[managed] class is not allowed
Pe2165:  invalid delegate initializer -- expected either "(<function-address>)" or "(<object-handle>, <member-address>)"
Pe2166:  class fails to implement interface member %nd
Pe2167:  %[gcnew] cannot be used to allocate a native array
Pe2168:  a %[C++/CLI] interface class cannot declare an assignment operator
Pe2169:  a %[C++/CLI] interface class cannot be sealed
Pe2171:  a destructor or finalizer declaration cannot include a named override specifier
Pe2172:  an override specifier cannot designate a destructor or finalizer
Pe2173:  a named override specifier is allowed only in a %[managed] class
Pe2174:  no member designated by the named override specifier matches the type of this member
Pe2175:  a static constructor declaration cannot include a named override specifier
Pe2176:  a scoped enumeration type must have a name
Pe2177:  transfer of control into a finally block is not allowed
Pe2178:  return statement inside a finally block is not allowed
Pe2179:  try block requires at least one handler or finally clause
Pe2180:  a %[managed] object must be thrown by handle
Pe2181:  a %[managed] object must be caught by handle
Pe2182:  a break statement cannot be used in a finally block
Pe2183:  a continue statement cannot be used in a finally block
Pe2184:  builtin offsetof cannot be used when subscripting is overloaded
Pe2185:  duplicate constraint
Pe2186:  more than one class constraint: %t1 and %t2
Pe2187:  more than one constraint clause for %n
Pe2188:  initonly static data members must have an initializer or be initialized in a static constructor
Pe2189:  GNU attributes on a template redeclaration have no effect
Pe2190:  GNU attributes on a template redeclaration have no effect (the attributes of the original declaration %p apply instead)
Pe2191:  a %[C++/CLI] parameter array must be the last parameter
Pe2192:  a function with a %[C++/CLI] parameter array cannot have default arguments
Pe2193:  a %[C++/CLI] parameter array cannot be followed by an ellipsis parameter
Pe2194:  a %[C++/CLI] parameter array is not allowed in an operator function parameter list
Pe2195:  __inline and __forceinline are not allowed here
Pe2196:  a data member cannot have a %[C++/CLI] interface class type
Pe2197:  a variable cannot have a %[C++/CLI] interface class type
Pe2198:  a parameter cannot have a %[C++/CLI] interface class type
Pe2199:  a function return type cannot be a %[C++/CLI] interface class type
Pe2200:  an array of generic parameter type is not allowed
Pe2201:  a pointer, handle, or reference to a generic parameter type is not allowed
Pe2202:  an initonly field cannot have a ref class type
Pe2203:  a reference cannot be bound to an initonly field
Pe2204:  taking the address of an initonly field is not allowed
Pe2205:  an initonly field can only be modified by the instance constructor of its containing class
Pe2206:  a static initonly field can only be modified by the static constructor of its containing class
Pe2207:  member function will be invoked on a copy of the initonly field
Pe2208:  expression must have pointer or handle type
Pe2209:  a move constructor or move assignment operator is used to copy an lvalue here, which may destroy the source object
Pe2210:  member selection on a %[C++/CLI] generic entity must use the "->" syntax, not "."
Pe2211:  a ref class type cannot derive from %t
Pe2212:  a generic class must be %[managed] (i.e., a ref class, a value class, or an interface class)
Pe2213:  a sealed class cannot be used as a constraint
Pe2214:  the type in a dynamic_cast cannot be a generic type that might be a value type
Pe2215:  a universal character name must designate a valid code point
Pe2216:  generic constraints do not match those of %nd
Pe2217:  __underlying_type only applies to enumeration types
Pe2218:  expected only one operand expression for this cast
Pe2219:  Unicode character with hex value %s not representable in the system default code page
Pe2220:  nonstandard conversion of bound pointer-to-member to a function pointer
Pe2221:  access specifier %s1 is deprecated -- use %s2 instead
Pe2222:  a static accessor function is not permitted in a nonstatic property or event definition
Pe2223:  %t has both a value class and ref class constraint
Pe2224:  %t1 and %t2 involve circular naked type constraints
Pe2225:  %t is not a valid type constraint
Pe2226:  precompiled header file %sq not used (because it is incomplete)
Pe2227:  %t is not a valid generic argument
Pe2228:  assembly_info attribute applied to an invalid type
Pe2229:  %t1 does not satisfy the ref class constraint of generic parameter %t2
Pe2230:  %t1 does not satisfy the value class constraint of generic parameter %t2
Pe2231:  %t1 does not satisfy the %[gcnew] constraint of generic parameter %t2 because it is abstract
Pe2232:  %t1 does not satisfy the %[gcnew] constraint of generic parameter %t2 because it does not have a public default constructor
Pe2233:  generic parameter %t1 does not satisfy the %[gcnew] constraint of generic parameter %t2 because it does not have the %[gcnew] constraint
Pe2234:  %t1 does not satisfy the %t3 type constraint of generic parameter %t2
Pe2235:  constraint on generic parameter %t differs from previous declaration (%p)
Pe2236:  a member of a %[managed] class cannot be a standard array
Pe2237:  a member of a non-%[managed] class cannot be a handle
Pe2238:  a member of a non-%[managed] class cannot be a tracking reference
Pe2239:  unsafe reinterpret_cast of handle
Pe2240:  a template argument may not reference a generic type parameter
Pe2241:  an expression list is not allowed in this subscript operation (use parentheses around a top-level comma operator)
Pe2242:  expression must have pointer-to-object or handle-to-%[C++/CLI]-array type
Pe2243:  unrecognized attribute
Pe2244:  a member of a %[managed] class cannot be of a non-%[managed] class type
Pe2245:  a member of a non-%[managed] class cannot have a ref class type or interface class type
Pe2247:  a delegate may not be declared as a template
Pe2248:  a generic cannot be explicitly specialized
Pe2249:  a generic cannot be declared in a class template
Pe2250:  a template cannot be declared in a generic class
Pe2251:  a literal field cannot be declared "static"
Pe2252:  "long float" is a nonstandard extension -- use "double" instead
Pe2253:  a standard class cannot be nested in a %[managed] class
Pe2254:  __clrcall is valid only in C++/CLI mode
Pe2255:  __clrcall not allowed on function with ellipsis parameter
Pe2256:  %sq is not allowed here
Pe2257:  a trivial property or event cannot be used to override %nd
Pe2258:  expected an iterator variable name
Pe2259:  the iterator type in this "for each" statement is %t, which is not a pointer type or an iterator-like class type
Pe2260:  the iterator type in this "for each" statement is %t, which is not a pointer type or an iterator-like class type
Pe2261:  the iterator type in this "for each" statement is %t, which is not a pointer type or an iterator-like class type
Pe2262:  packing attribute on the parent type is ignored for this field of class type %t that is not standard-layout
Pe2263:  %nd not implemented because this declaration is not public and has no named override specifier
Pe2264:  this declaration is missing the gnu_inline attribute specified in the previous declaration %p
Pe2265:  a member function of a %[managed] class cannot have an ellipsis parameter
Pe2266:  previously-declared %n invalid as iterator of "for each" statement
Pe2267:  calling convention ignored because the function type involves a generic parameter; __clrcall used instead
Pe2268:  a function type involving a generic parameter cannot have an ellipsis parameter
Pe2269:  "virtual" is required to override the matching %nd
Pe2270:  "virtual" is required to implement the matching %nd
Pe2271:  an initonly data member cannot be volatile
Pe2272:  a member %sq of this type is reserved within a %[managed] class -- %[C++/CLI] operators must be declared using the keyword "operator"
Pe2273:  a tracking reference to non-const cannot be bound to a constant
Pe2274:  attributes ignored here because they do not apply to a declared entity
Pe2275:  a tracking reference to %[System]::String is not allowed
Pe2276:  invalid use of a generic class %t with pending constraints (probably caused by an invalid metadata file)
Pe2277:  a pending constraint clause is only allowed for generic class declarations (but not generic class definitions)
Pe2278:  empty initializer list not allowed here
Pe2279:  a template cannot be declared in a %[managed] class
Pe2280:  a generic declaration is not allowed here
Pe2281:  interface types cannot have member generics
Pe2282:  Unicode character not Latin-1, truncated to low-order byte
Pe2283:  to be used with range-based "for" statements, type %t must provide function %sq
Pe2284:  the iterator type in this range-based "for" statement is %t, which is not a pointer type or an iterator-like class type
Pe2285:  the iterator type in this range-based "for" statement is %t, which is not a pointer type or an iterator-like class type
Pe2286:  the iterator type in this range-based "for" statement is %t, which is not a pointer type or an iterator-like class type
Pe2287:  a range-based "for" statement cannot operate on an array of unknown size or incomplete type %t
Pe2288:  return types for "begin" and "end" functions used in a range-based "for" statement must be the same ("begin" return type is %t1, "end" return type is %t2)
Pe2289:  %nfd, required to destroy temporary that was eliminated, is inaccessible
Pe2290:  in this range-based "for" statement, no instance of %no matches the argument list
Pe2291:  this range-based "for" statement requires a suitable %sq function and none was found
Pe2292:  this "for each" statement requires a suitable %sq function and none was found
Pe2293:  %t has a metadata representation not representable using %[C++/CLI]
Pe2294:  expected "..."
Pe2295:  %t in __implements list is not an interface
Pe2296:  an __implements list must precede virtual function declarations
Pe2297:  %t specified "__implements ..." in its list of bases, but is missing a matching __implements list
Pe2298:  the result of dereferencing a handle to a ref or interface class type must be used
Pe2300:  expected a ")"; pragma ignored
Pe2301:  a using-declaration or access declaration cannot appear in a managed class
Pe2302:  Note: %nd could have been called but was not considered because it is inaccessible
Pe2303:  an abstract member function of a C++/CLI managed class cannot have a definition
Pe2304:  declaring this unary "operator*" can change the meaning of dereferencing a handle (use static member operators to explicitly indicate applicable types)
Pe2319:  an interface class cannot contain a nonstatic data member
Pe2320:  #pragma GCC system_header cannot be used in the primary source file
Pe2321:  %n is too large to be inlined
Pe2323:  option to control move operations can be used only when compiling C++
Pe2324:  move operations cannot be generated when rvalue constructors are copy constructors
Pe2325:  option to control move operations cannot be used when rvalue references are disabled
Pe2326:  "final" cannot be used for managed classes (use "sealed" instead)
Pe2327:  a cast to CLI interface class %t is not allowed -- cast to handle intended?
Pe2328:  cannot create an object of a CLI interface class
Pe2329:  this declaration hides the nonstandard declaration of %nd because the underlying types are incompatible
Pe2330:  pointer comparison result is constant, because operand can never be null
Pe2331:  an object of the incomplete type %t cannot be value-initialized
Pe2332:  a reference cannot be value-initialized
Pe2333:  expected a "(" or a "{"
Pe2334:  copy-list-initialization cannot use a constructor marked "explicit"
Pe2335:  pointer to member of type void is not allowed
Pe2336:  pointer to member of reference type is not allowed
Pe2337:  pointer to member of handle type is not allowed
Pe2338:  a brace-enclosed list is not allowed here
Pe2339:  an operator->* member is not allowed in a managed class
Pe2340:  assembly metadata refers to non-existent assembly
Pe2341:  attribute %sq2 conflicts with earlier attribute %sq1
Pe2342:  %nd was previously declared with a different base type
Pe2343:  "enum class" and "enum struct" cannot be used here (use plain "enum" instead)
Pe2344:  only one level of braces is allowed on an initializer for an object of type %t
Pe2345:  %nd cannot be used as an enumeration type name
Pe2347:  a braced-initializer cannot be used with "new auto"
Pe2348:  the definition of std::initializer_list does not contain the expected constructor
Pe2349:  declaration hides %nd
Pe2350:  invalid template parameter list for std::initializer_list (it should be one ordinary type parameter with no default)
Pe2351:  a brace-enclosed list cannot be passed for an ellipsis parameter
Pe2352:  an #include <initializer_list> is needed prior to a use of std::initializer_list, including an implicit use
Pe2353:  the "inline" keyword cannot be used on a namespace alias declaration
Pe2354:  the previous declaration of %n was not declared inline
Pe2355:  %n was previously declared inline
Pe2356:  the first argument must be an integer constant
Pe2357:  a designator cannot be used with a non-aggregate type %t
Pe2358:  a designator for an anonymous union member can only appear within braces corresponding to that anonymous union
Pe2359:  function prototype tags can only be enabled when compiling C
Pe2360:  braces cannot be omitted for this subobject initializer
Pe2361:  invalid narrowing conversion from %t1 to %t2
Pe2362:  invalid narrowing conversion from %t1 to %t2: constant value does not fit in destination type
Pe2363:  cast to incomplete array type %t is not allowed
Pe2364:  invalid narrowing conversion from %t1 to %t2: constant value cannot be represented exactly in destination type
Pe2365:  a parenthesized initializer for a non-class entity must be an expression, not a brace-enclosed list
Pe2366:  a brace-enclosed list does not provide a return type for this lambda
Pe2367:  the declared exception specification is incompatible with the generated one
Pe2368:  scoped enumeration types are a C++11 feature
Pe2369:  a function type cannot be value-initialized
Pe2370:  list-initialization of an object type %t is not allowed because the type is incomplete
Pe2371:  std::initializer_list has a destructor, and is not supposed to -- library is misconfigured
Pe2372:  explicit enum base types are a C++11 feature
Pe2373:  this constant expression has type %t1 instead of the required %t2 type
Pe2374:  a "new" of an std::initializer_list object is unlikely to work as expected because the underlying array will be destroyed at the end of the full expression
Pe2377:  "defined" is always false in a macro expansion in Microsoft mode
Pe2378:  %t cannot be the element type of an initializer list because it is not a complete object type
Pe2379:  mismatched delimiters in default argument expression
Pe2380:  nonstandard conversion of pointer-to-member to a function pointer
Pe2381:  dynamic exception specifications are deprecated
Pe2382:  %n cannot be partially specialized in the current scope
Pe2383:  %nd was previously declared constexpr
Pe2384:  %nd was previously not declared constexpr
Pe2385:  missing initializer for constexpr variable
Pe2386:  "constexpr" is not valid here
Pe2387:  a constexpr function must contain exactly one return statement
Pe2388:  statement may not appear in a constexpr function
Pe2389:  statement may not appear in a constexpr constructor
Pe2390:  a function cannot be both constexpr and virtual in this mode
Pe2391:  a constexpr function cannot have a nonliteral return type %t
Pe2392:  a constexpr function cannot have a parameter of nonliteral type %t
Pe2393:  unsequenced uses of %n in expression may produce undefined results
Pe2394:  the optional third argument of a call to __builtin_assumed_aligned must have integral type
Pe2395:  a destructor cannot be constexpr
Pe2396:  address supplied for mmap must be aligned on a page boundary: %s
Pe2397:  the body of a constexpr constructor cannot be a function try block
Pe2398:  constexpr %nf provides no initializer for:
Pe2400:  calling the default constructor for %t does not produce a constant value
Pe2401:  the default constructor for %t is not constexpr
Pe2402:  a constexpr variable must have a literal type or a reference type
Pe2403:  a constructor for a class with virtual bases cannot be constexpr
Pe2404:  function call must have a constant value in a constant expression
Pe2405:  function "main" may not be declared constexpr
Pe2407:  a class or enumeration type definition cannot appear in a constexpr function or constructor body
Pe2408:  only GNU-style attributes are permitted here
Pe2409:  nonstandard use of "auto" to both deduce the type from an initializer and to announce a trailing return type
Pe2410:  declaring a void parameter list with a qualified void type is nonstandard
Pe2411:  the qualifier on this local declaration is ignored
Pe2412:  this constant expression has type %t instead of the required %s type
Pe2413:  an instantiation of __bases or __direct_bases requires a class type
Pe2414:  the argument of __bases and __direct_bases must be a type template parameter
Pe2415:  %s can only be used in template contexts
Pe2416:  constexpr function return is non-constant
Pe2417:  constexpr constructor calls non-constexpr %n
Pe2418:  constructor cannot be constexpr because the initializer of %n is not a constant expression
Pe2419:  non-constant initializer for constexpr constructor
Pe2420:  the generated default constructor for %t cannot be used in an initializer for its own data member
Pe2421:  instantiation of initializer of %n depends on its own value
Pe2422:  defaulted default constructor cannot be constexpr because the corresponding implicitly declared default constructor would not be constexpr
Pe2424:  invalid binary number
Pe2425:  a union can have at most one field initializer -- %nd also has an initializer
Pe2427:  constexpr constructor of a union must initialize one of its fields
Pe2428:  constexpr constructor fails to initialize an anonymous union (defined %p)
Pe2429:  a constexpr static data member declaration requires an in-class initializer
Pe2430:  maximum constexpr depth/count options can be used only when compiling C++
Pe2431:  expression not folded to a constant due to excessive constexpr function call complexity
Pe2432:  unrestricted union options can be used only when compiling C++
Pe2433:  constexpr constructor must initialize direct base class %t
Pe2434:  creation of an std::initializer_list object in a field initializer is unlikely to work as expected because the underlying array will be destroyed at the end of the full expression
Pe2435:  "this" cannot be used in a constant expression
Pe2437:  "constexpr" is not allowed on an explicit instantiation directive
Pe2438:  cannot determine the exception specification of the default constructor due to a circular dependency
Pe2439:  anonymous union defined %p
Pe2440:  this constructor uses the initializer of %nd, which would result in unbounded recursion
Pe2442:  an initializer is not allowed on a local declaration of an extern variable
Pe2443:  an initializer is not allowed on a local declaration of a named register variable
Pe2445:  unrestricted unions cannot be enabled in Microsoft mode
Pe2446:  constructor delegates directly or indirectly to itself
Pe2447:  a delegating constructor cannot have other mem-initializers
Pe2448:  a ref-qualifier is not allowed here
Pe2449:  overloading two member functions with the same parameter types requires that they both have ref-qualifiers or both lack ref-qualifiers
Pe2450:  invalid character in raw string delimiter
Pe2451:  parenthesis terminating raw string delimiter not found within 16 characters -- raw string indicator ignored
Pe2452:  ending delimiter for raw string not found
Pe2453:  a parameter pack must be the final template argument in a partial specialization
Pe2454:  a pointer-to-member function with type %t can only be used with an lvalue object
Pe2455:  a pointer-to-member function with type %t can only be used with an rvalue object
Pe2456:  the parameter of this defaulted copy-constructor cannot be const because a base or member copy constructor parameter is non-const
Pe2457:  the parameter of this defaulted assignment operator cannot be const because a base or member copy assignment parameter is non-const
Pe2458:  an anonymous union must contain at least one nonstatic data member
Pe2459:  option "delegating_constructors" requires a different compiler configuration
Pe2460:  a reduction in alignment is ignored
Pe2461:  the operand of a const_cast to an rvalue reference type cannot be a non-class prvalue
Pe2462:  expression must be an lvalue or xvalue
Pe2463:  conversion may change the value
Pe2464:  conversion from a string literal to "char *" is deprecated
Pe2465:  conversion from a string literal to pointer-to-character (non-const) is deprecated
Pe2466:  "override" and "final" are C++11 features
Pe2467:  rvalue references are not allowed as exception specification types
Pe2468:  attribute %sq does not apply to handler parameters
Pe2469:  attribute %sq requires a handler parameter
Pe2470:  alignas does not apply here
Pe2471:  the standard "alignof" operator does not accept an expression argument (use a type instead)
Pe2472:  invalid qualifier for %t (a derived class is not allowed here)
Pe2473:  the "always_inline" attribute is ignored on non-inline functions
Pe2474:  inheriting constructors must be inherited from a direct base class
Pe2476:  expected a label
Pe2477:  expected an operand number after "%%l"
Pe2478:  operand number for "%%l" doesn't refer to a valid label argument
Pe2479:  a wide string is invalid in an "asm" statement
Pe2480:  attribute is nonstandard
Pe2481:  not a base class of class %t
Pe2482:  non-identifier character in user-defined literal suffix
Pe2483:  a multicharacter literal cannot be part of a user-defined literal
Pe2484:  user-defined literal suffix does not match the earlier %sq
Pe2485:  invalid literal operator name
Pe2486:  user-defined literal operator not found
Pe2487:  ambiguous literal operators and/or literal operator template:
Pe2488:  a literal operator cannot be a member of a class
Pe2489:  a literal operator cannot have extern "C" name linkage
Pe2490:  at least one parameter expected for a literal operator
Pe2491:  too many parameters for this literal operator
Pe2492:  invalid parameter type %t for literal operator
Pe2493:  invalid integer parameter type (%t) for literal operator; expected a character type or unsigned long long
Pe2494:  invalid floating-point parameter type (%t) for literal operator; expected long double
Pe2495:  invalid first parameter type (%t) for literal operator; pointer to non-const type is not allowed
Pe2496:  invalid second parameter type (%t) for literal operator; must be size_t
Pe2497:  invalid pointer parameter type (%t) for literal operator; expected a pointer to a character type
Pe2498:  a literal operator cannot have an ellipsis parameter
Pe2499:  a literal operator template cannot have any parameters
Pe2500:  a literal operator template must have a template parameter list equivalent to "<char ...>"
Pe2501:  thread-local storage class is not valid here
Pe2502:  thread-local declaration follows non-thread-local declaration (declared %p)
Pe2503:  non-thread-local declaration follows thread-local declaration (declared %p)
Pe2504:  a literal operator cannot have default arguments
Pe2505:  attribute is ignored for thread-local variables
Pe2506:  a user-provided literal suffix must begin with "_"
Pe2507:  rvalue references are a C++11 feature
Pe2508:  lambda expressions are a C++11 feature
Pe2509:  standard attribute syntax is a C++11 feature
Pe2510:  delegating constructors are a C++11 feature
Pe2511:  inheriting constructors are a C++11 feature
Pe2512:  field initializers are a C++11 feature
Pe2513:  deleted functions are a C++11 feature
Pe2514:  defaulted functions are a C++11 feature
Pe2515:  a storage class is not allowed in an explicit specialization
Pe2517:  an unscoped enumeration must be opaque in order to be specialized
Pe2518:  an enumeration template declaration must refer to a previously declared member of a class template
Pe2519:  expected a vector operand
Pe2520:  shuffle source operands have incompatible types %t1 and %t2
Pe2521:  shuffle mask (type %t) is not a vector of integers
Pe2522:  shuffle mask (type %t1) has a length different from the source operand (type %t2)
Pe2523:  static initialization with an address value requires a destination of the same size as the address
Pe2524:  the argument to a feature-test macro must be a simple identifier
Pe2525:  __has_include_next cannot be used in the primary source file
Pe2526:  absolute file name used in __has_include_next
Pe2527:  attribute %sq must be applied to a function type
Pe2529:  _Noreturn is not allowed here
Pe2530:  expected an operand of real floating-point type (not %t)
Pe2531:  __builtin_complex requires operands of compatible types (unlike %t1 and %t2)
Pe2532:  a default association already appeared in this _Generic selection
Pe2533:  a type involving a variable length array is not allowed here
Pe2534:  duplicate association type (%t) in _Generic selection
Pe2535:  no association matches the selector type %t
Pe2536:  the type of %n (%t) is incompatible with an ifunc resolver type
Pe2537:  a function cannot have both ifunc and alias attributes
Pe2538:  a function cannot have both ifunc and weak attributes
Pe2539:  call requires a string literal operand
Pe2540:  duplicate inheriting constructor declaration (previous %p)
Pe2541:  "decltype(auto)" must be a placeholder for the complete type of the variable (not for a component of that type)
Pe2542:  decltype(auto) is not allowed here
Pe2543:  cannot deduce "decltype(auto)" (initializer required)
Pe2544:  cannot deduce "decltype(auto)" type
Pe2545:  a block-scope thread-local declaration must include static or extern
Pe2546:  deduced return type %t1 conflicts with previously deduced type %t2
Pe2547:  cannot deduce the return type of %nd; it has not been defined
Pe2548:  a virtual function cannot have a deduced return type
Pe2549:  %n will be treated as a context-sensitive keyword from this point
Pe2550:  the global namespace has no actual member %sq
Pe2551:  comparison between two different enum types (%t1 and %t2)
Pe2552:  target attribute not recognized
Pe2553:  missing "default" target function
Pe2554:  only one arch= target may be specified
Pe2555:  a generic class cannot be a custom attribute
Pe2556:  invalid attribute target %sq
Pe2557:  ambiguous attribute -- both %t1 and %t2 could be used
Pe2558:  a named attribute argument can only reference a public nonstatic read/write field or scalar property
Pe2559:  a named attribute argument can only reference a nonstatic field or scalar property of an attribute parameter type
Pe2560:  invalid attribute argument -- expression must be a constant of an attribute parameter type
Pe2561:  an attribute argument cannot use generic type parameters
Pe2562:  %t may only be used as a standalone attribute
Pe2563:  the 'field' attribute target cannot be used on a non-trivial property/event
Pe2564:  invalid attribute target for a standalone attribute
Pe2565:  invalid attribute target for this context
Pe2566:  %t attribute cannot be used here
Pe2567:  %t is deprecated; use '...' to specify a parameter array
Pe2568:  the default namespace cannot be extended
Pe2569:  the boxed type must be a value class or enum
Pe2570:  tracking reference to value class is not allowed
Pe2571:  handle to value class is not allowed
Pe2572:  tracking reference to enum is not allowed
Pe2573:  handle to enum is not allowed
Pe2574:  a public native type is not allowed
Pe2575:  a public nested type is not allowed
Pe2576:  generic types are not permitted in C++/CX
Pe2577:  generic methods are not permitted in C++/CX
Pe2578:  generic constraints are not allowed
Pe2579:  non-public data members are not allowed in public C++/CX value types
Pe2580:  public non-data members are not allowed in public C++/CX value types
Pe2581:  constructors are not allowed in public C++/CX value types
Pe2582:  the return type of the "add" accessor must be Windows::Foundation::EventRegistrationToken
Pe2583:  the return type of the "remove" accessor must be void
Pe2584:  the parameter type of the "remove" accessor must be Windows::Foundation::EventRegistrationToken
Pe2585:  a handle or reference to a generic parameter type is not allowed
Pe2586:  public data members are not allowed in non-value types
Pe2587:  C++/CX can be enabled only in Microsoft C++ mode
Pe2588:  C++/CLI and C++/CX modes cannot be combined
Pe2589:  %sq requires C++/CX mode
Pe2590:  C++/CX mode requires microsoft_version >= 1600
Pe2591:  Literal fields are not allowed in C++/CX
Pe2592:  a standard reference cannot be bound to a C++/CX type
Pe2593:  type must correspond to Platform::Boolean, default::uint8, default::int8, default::int16, default::uint16, default::int32, default::uint32, default::int64, or default::uint64
Pe2594:  a C++/CX value type cannot have events
Pe2595:  a dynamic_cast to a handle type must refer to a complete class type
Pe2596:  Platform::Array can only be one-dimensional
Pe2597:  tracking reference to standard class type is not allowed
Pe2598:  a C++/CX value type cannot inherit from an interface
Pe2599:  a C++/CX value type cannot contain virtual functions
Pe2600:  "partial" can only be applied to "ref class" or "ref struct" at global scope or namespace scope
Pe2601:  the parameter of the "set" accessor must be of type "const Platform::Array<T>^"
Pe2602:  the definition of a public C++/CX type is not allowed at global scope
Pe2603:  an indexed property with a public "get" or "set" accessor is not allowed
Pe2604:  a public nested delegate type is not allowed
Pe2605:  invalid delegate initializer -- expected either "(<function-address or functor-object> [, Platform::CallbackContext])" or "(<object handle>, <member-address> [, Platform::CallbackContext [, bool]])"
Pe2606:  invalid delegate initializer -- object must be a handle to a %[managed] class
Pe2607:  C++/CX does not support 'in/out' arrays -- use "const Platform::Array<T>^" for 'in' and "Platform::WriteOnlyArray<T>^" or "Platform::Array<T>^*" for 'out' on public APIs
Pe2608:  missing "target" attribute for %nd
Pe2609:  no declared member function matches "target" attributes for %n
Pe2610:  Microsoft attributes in this location are only permitted for interface types
Pe2611:  GNU function multiversion resolver routine required
Pe2612:  an enum type declared in a managed class must include a definition
Pe2613:  a decltype-qualified name is nonstandard in this declaration context
Pe2614:  nonvirtual function cannot be declared with "final" modifier
Pe2615:  "target" attribute on special function is not supported
Pe2616:  must be a narrow string literal
Pe2617:  unmatched parentheses
Pe2618:  no corresponding "push_options"
Pe2619:  this pragma is not allowed inside a function
Pe2620:  declaring a new or delete operator "inline" is nonstandard
Pe2621:  a mem-initializer for a data member cannot be a pack expansion
Pe2622:  generic lambda expressions cannot have capture defaults in this mode
Pe2623:  a default template argument in a friend declaration may only be specified in a definition
Pe2624:  a friend template declaration with a default template argument must be the only declaration (first declared %p)
Pe2625:  an opaque enum declaration cannot be part of another declaration
Pe2626:  an opaque enum declaration is nonstandard in this context
Pe2627:  extended friend syntax is a C++11 feature
Pe2628:  digit separators not enabled, apostrophe begins a character literal
Pe2629:  digit separator cannot appear here
Pe2630:  "constexpr" is ignored here in Microsoft mode
Pe2631:  invalid expression for statement expression result
Pe2632:  identifier is a macro and not a literal suffix
Pe2633:  %nd cannot be called on an lvalue
Pe2634:  %nd cannot be called on an rvalue
Pe2635:  member function cannot be called on an lvalue
Pe2636:  member function cannot be called on an rvalue
Pe2637:  the template parameter list is too long
Pe2638:  alias template type %t1 is incompatible with the previous type of %t2 in the redeclaration of %nfd
Pe2639:  the field initializer for %nd is not a constant expression
Pe2640:  the number of operand constraints must be the same in each constraint string
Pe2641:  the constraint string contains too many alternative constraints; not all constraints were checked
Pe2642:  call through incomplete class %t will always produce an error when instantiated
Pe2643:  decltype(auto) cannot have added type qualifiers
Pe2644:  init-capture %nod cannot be captured here
Pe2645:  invalid nontype template argument of type %t
Pe2646:  the abi_tag attribute is ignored (it has no meaning in C mode)
Pe2647:  redeclaration adds abi_tag attribute "%s"
Pe2648:  abi_tag attribute is ignored (superseded by later abi_tag attribute)
Pe2649:  previous declaration of %nd had no abi_tag attribute
Pe2651:  abi_tag attribute is ignored on specialization
Pe2652:  decltype(auto) cannot appear under a pointer, reference, or pointer-to-member construct
Pe2653:  expected "class" or "typename"
Pe2654:  placement "new" expression refers to non-placement %nd
Pe2655:  must specify C++14 mode when building runtime library
Pe2659:  constexpr non-static member function will not be implicitly 'const' in C++14
Pe2660:  variable type %t in constexpr function is not a literal type
Pe2661:  variable in constexpr function does not have automatic storage duration
Pe2662:  variable in constexpr function is uninitialized
Pe2663:  braced initialization of a variable declared with a placeholder type but without `=` requires exactly one element inside the braces
Pe2664:  no "%s" --target configuration exists
Pe2665:  attribute is not supported in 64-bit x86 configurations
Pe2666:  "%s" requires an argument
Pe2667:  a constructor or destructor cannot be a coroutine
Pe2668:  %n cannot be a coroutine
Pe2669:  co_yield expressions are not permitted in a catch clause
Pe2674:  class template %sq not found
Pe2675:  use the "typename" keyword to treat %n as a type in a dependent context
Pe2676:  argument value must be less than the sum of the vector elements
Pe2677:  %t has no member %sq
Pe2678:  a brace-enclosed list does not provide a return type
Pe2679:  a co_await expression must appear in a function scope
Pe2680:  a co_await expression is not allowed inside a catch clause
Pe2681:  a coroutine cannot have an ellipsis parameter
Pe2682:  enabling C++14-style constexpr requires support for "bool"
Pe2683:  constexpr function %nd is not defined
Pe2684:  this call cannot be evaluated because the target function %nd is not constexpr or not completely defined yet
Pe2687:  invalid anonymous union -- alias member template is not allowed
Pe2688:  a UTF-8 character literal value cannot occupy more than one code unit
Pe2689:  the value of %nd cannot be used as a constant
Pe2690:  a pointer or reference to %nd cannot be used as a constant
Pe2691:  nonzero subscript for non-array object
Pe2692:  cannot access position %d1 in array of %d2 elements
Pe2693:  called from here
Pe2694:  invalid access to inactive %n1 of union (%n2 is active)
Pe2695:  'goto' cannot be executed in constexpr contexts
Pe2696:  missing return value
Pe2697:  callee is null
Pe2698:  attempt to dereference a null pointer
Pe2699:  attempt to access storage one position past the end of an array of %d elements
Pe2700:  attempt to access expired storage
Pe2701:  attempt to access run-time storage
Pe2703:  cannot call non-constexpr %nd
Pe2704:  cannot use variable-length array during constexpr evaluation
Pe2705:  cannot perform a negative shift
Pe2706:  shift amount (%d) too large
Pe2707:  value exceeds range of %t
Pe2708:  floating-point error
Pe2709:  attempt to dereference a null pointer-to-member (data member)
Pe2710:  comparing a pointer to void and a pointer to a function is nonstandard
Pe2711:  metadata initialization failed
Pe2712:  invalid base-to-derived cast (complete class type is %t)
Pe2713:  invalid access to %n in object of complete type %t
Pe2714:  "__auto_type" not allowed here
Pe2715:  "__auto_type" does not permit multiple declarators
Pe2716:  initialization with "{...}" is not allowed for "__auto_type"
Pe2717:  "__auto_type" must be a placeholder for the complete type of the variable (not for a component of that type)
Pe2718:  a variable declared with "__auto_type" requires an initializer
Pe2719:  integer constant must be greater than or equal to zero
Pe2720:  type must be an integral type
Pe2721:  expression cannot be interpreted
Pe2722:  statement cannot be interpreted
Pe2723:  invalid use of address of interpreter storage
Pe2724:  invalid constant kind for constant-expression
Pe2725:  type %t too large for constant-expression evaluation
Pe2726:  invalid type %t for constant-expression evaluation
Pe2727:  conversion from %t1 to %t2 is invalid in constant-expression evaluation
Pe2728:  floating-point conversion failed
Pe2730:  deduced return types are a C++14 feature
Pe2731:  cannot evaluate a constructor with an associated destructor
Pe2732:  %n not initialized during constexpr evaluation
Pe2733:  invalid pointer difference in constexpr evaluation
Pe2734:  invalid arithmetic on non-array pointer
Pe2735:  cannot set pointer before the first array element
Pe2736:  a coroutine with a deduced return type is invalid
Pe2737:  expression not allowed in unevaluated context
Pe2740:  "return" is not permitted in a coroutine (use "co_return" instead)
Pe2741:  "co_return" is only allowed in coroutines
Pe2742:  floating-point values cannot be compared
Pe2743:  pointer values cannot be compared because they do not point into the same complete object or they point to subobjects with different accessibility
Pe2744:  ignoring abi_tag attribute on non-inline namespace
Pe2745:  ignoring abi_tag attribute on anonymous namespace
Pe2746:  complex or imaginary template parameter type is nonstandard
Pe2747:  co_yield expression is not permitted outside a function scope
Pe2748:  ignoring thread-local indication on anonymous union
Pe2751:  access to uninitialized object
Pe2752:  attempt to read from volatile storage
Pe2753:  invalid access to inactive %n1 of union (no field is active)
Pe2754:  label definitions cannot appear in constexpr functions
Pe2755:  cannot compare a pointer past the end of an array with a pointer to another complete object
Pe2756:  function type %t is an invalid type for a variable template instantiation
Pe2757:  variable cannot have incomplete type %t
Pe2758:  access to uninitialized subobject (%n)
Pe2759:  access to uninitialized subobject (base class %t)
Pe2760:  a pseudo-destructor call is not permitted in a constant-expression
Pe2761:  attempt to modify const storage
Pe2764:  attempt to access storage one position past an object treated as an array of one element
Pe2765:  cannot use reinterpret_cast in constant-expression evaluation
Pe2766:  operation not allowed on null pointer
Pe2767:  the value of *this cannot be used as a constant
Pe2768:  the "inline" keyword cannot be used on a nested namespace declaration
Pe2769:  the "carries_dependency" attribute is ignored
Pe2770:  an "__event __interface" cannot have a definition here
Pe2771:  an event handler must have a void or integral return type
Pe2772:  an "__event __interface" must have been previously defined
Pe2773:  too many template arguments for %n
Pe2774:  enumerator already declared (see %nd)
Pe2775:  the version of Microsoft being emulated must be at least 1903 to use "--ms_c++14"
Pe2776:  the version of Microsoft being emulated must be at least 1903 to use "--ms_c++latest"
Pe2777:  type %t cannot be _Atomic because it is an array or function type
Pe2778:  the _Atomic(...) specifier cannot be applied to qualified type %t
Pe2779:  access to member of _Atomic object
Pe2780:  a bit field cannot have an _Atomic type
Pe2781:  _Atomic class types are disabled
Pe2782:  constexpr constructor calls non-constexpr constructor for subobject initialization
Pe2783:  expected a comma (the one-argument version of static_assert is not enabled in this mode)
Pe2784:  static assertion failed
Pe2785:  at most one of the qualifiers _Nullable, _Nonnull, and _Null_unspecified can modify a type
Pe2786:  nullability qualifiers are only permitted on pointer and pointer-to-member types
Pe2787:  vector length is too large
Pe2788:  vector element type must be integral, enum, or real floating-point type
Pe2789:  builtin function is not available because 128-bit integers are not supported
Pe2790:  builtin function is not available because vector types are not supported
Pe2791:  two consecutive left square brackets always introduce an attribute list but an attribute list cannot appear here
Pe2792:  unrecognized "target" attribute disqualifies this routine from being used by resolver routine
Pe2793:  %t is not a vector type
Pe2794:  vector types %t1 and %t2 must have the same length
Pe2795:  added default arguments cannot result in declaring a default or copy constructor
Pe2796:  a nontype template argument of reference type must bind to a function or to a complete object
Pe2797:  %t not allowed here
Pe2798:  use of the "register" storage class specifier is not allowed
Pe2799:  use of the "register" storage class specifier is deprecated
Pe2800:  incrementing a bool value is not allowed
Pe2801:  %sq, declared as iterator of range-based "for" statement, may not be redeclared in this scope
Pe2802:  an attribute namespace may not be used here (because a "using" prefix was specified)
Pe2803:  attribute namespace %sq is unrecognized
Pe2804:  a default member initializer is not permitted in a value class
Pe2805:  "--implicit_noexcept" requires a mode that enables noexcept
Pe2806:  cannot fold operation involving virtual base class (%t)
Pe2807:  initialization is not constant
Pe2808:  cannot evaluate value of incomplete %t
Pe2809:  ignoring return value from routine declared with "nodiscard" attribute
Pe2810:  ignoring return value type with "nodiscard" attribute
Pe2811:  the "nodiscard" attribute doesn't apply to destructors or routines with void return type
Pe2812:  the "fallthrough" attribute only applies to null statements
Pe2813:  the "fallthrough" attribute may only appear in an enclosing switch statement
Pe2814:  fallthrough statement must precede switch case label or default
Pe2815:  reference or pointer to temporary with limited lifetime
Pe2816:  cannot take the address of a function with an "enable_if" attribute whose condition is not unconditionally true
Pe2817:  "enable_if" attributes with conditions that are not constant values are not currently supported
Pe2818:  attribute was declared here
Pe2819:  __has_include cannot appear outside #if
Pe2820:  could not add CComCoClass base class
Pe2821:  not a null-terminated string
Pe2822:  non-scalar type %t cannot be used in a pseudo-destructor call
Pe2823:  address of "weak" %n is not constant
Pe2824:  too many recursive substitutions of function template signatures
Pe2825:  invalid specifier for structured binding declaration
Pe2826:  invalid structured binding syntax
Pe2827:  missing initializer
Pe2828:  type %t has no components to bind to
Pe2829:  too many identifiers
Pe2830:  there are more elements than there are binding names
Pe2831:  "std::tuple_element" not defined
Pe2832:  cannot instantiate "std::tuple_element" for <%s, %t>
Pe2833:  cannot call member function "get<%s>()" for type %t
Pe2834:  no instance of %no matches the argument list
Pe2835:  this structured binding requires a suitable %sq function and none was found
Pe2836:  a structured binding cannot be declared "inline"
Pe2837:  a structured binding cannot be declared "constexpr"
Pe2838:  a structured binding cannot declare an explicit storage class
Pe2839:  std::tuple_size<%t>::value is not a valid integral constant-expression
Pe2840:  a condition declaration must declare a variable
Pe2841:  a condition declaration must include an initializer
Pe2842:  a parenthesized initializer is not permitted for a condition declaration
Pe2843:  a condition declaration can only declare one variable
Pe2844:  structured binding cannot bind to closure type
Pe2845:  cannot bind to non-public %n
Pe2846:  cannot bind to incomplete type %t
Pe2847:  this declaration is not valid here
Pe2848:  the body of a constexpr function cannot be a function try block
Pe2849:  transfer of control into a constexpr if block is not allowed
Pe2850:  structured binding cannot be captured
Pe2851:  the version of Microsoft being emulated must be at least 1911 to use "--ms_c++17"
Pe2852:  attempt to read past the end of the object
Pe2853:  constexpr lambdas are not enabled in this mode
Pe2854:  a constant expression cannot contain a lambda expression
Pe2855:  value exceeds number of template arguments
Pe2856:  second operator in binary fold expression does not match first
Pe2857:  invalid fold expression operator
Pe2858:  a binary fold expression cannot apply to two parameter packs
Pe2859:  empty expansion not valid for this fold expression
Pe2860:  a nonstatic data member cannot be declared as inline
Pe2861:  fold expression does not refer to a parameter pack
Pe2862:  two functions with the same parameter types but different exception specifications cannot be overloaded
Pe2863:  dynamic exception specifications are not permitted in this mode
Pe2865:  invalid operand for noexcept specifier
Pe2866:  lambda expression cannot appear in noexcept specifier of a template
Pe2867:  %nfd is inaccessible
Pe2868:  invalid specifier in enum template declaration
Pe2869:  80-bit floating-point types are not supported in this configuration
Pe2870:  128-bit floating-point types are not supported in this configuration
Pe2871:  invalid enumerator value
Pe2872:  must be an _Atomic qualified type
Pe2873:  type of array element must be complete
Pe2874:  the always_inline attribute has been suppressed for this function
Pe2875:  a negative value is not permitted here
Pe2876:  an integer pack element cannot match %n
Pe2877:  an integer pack element cannot match %n
Pe2878:  unexpected designator
Pe2879:  cannot evaluate __builtin_offsetof
Pe2880:  deduction guide %t cannot be defined
Pe2881:  deduction guide must be declared in the same scope as %n
Pe2882:  invalid specifier for deduction guide declaration (only "explicit" is permitted)
Pe2883:  mutable %n of a constant cannot be accessed in a constant expression
Pe2884:  function modifier does not apply to static member declaration
Pe2885:  the "overloadable" attribute requires a prototyped function declaration
Pe2886:  cannot deduce "auto" template parameter type %t1 from %t2
Pe2887:  class template name must be a placeholder for the complete type being initialized (not for a component of that type)
Pe2888:  alias declarations are a C++11 feature
Pe2889:  alias templates are a C++11 feature
Pe2890:  the return type must directly designate a specialization of the associated class template
Pe2891:  copy-list-initialization cannot use "explicit" %n
Pe2893:  Invalid value for user-defined literal operator
Pe2894:  __has_cpp_attribute cannot appear outside of #if or #elif
Pe2895:  deduction guide must be declared with the same accessibility as %n
Pe2896:  a lambda is not permitted in this context
Pe2897:  specified alignment is not equivalent to previous declaration
Pe2898:  no alignment specified on definition; previous declaration had specified an alignment
Pe2899:  builtin function is not available because 128-bit floating-point types are not supported
Pe2900:  left-shifting a negative value has undefined behavior
Pe2901:  array designators are nonstandard in C++
Pe2902:  chained designators are nonstandard in C++
Pe2903:  mixing designated and non-designated initializers is nonstandard in C++
Pe2904:  out-of-order initializers are nonstandard in C++
Pe2905:  a string literal operator template must have a template parameter list equivalent to "<typename T, T ...>"
Pe2906:  duplicate designator is not allowed
Pe2907:  attribute conflicts with previous likely/unlikely attribute
Pe2908:  the implicit by-copy capture of "this" is deprecated
Pe2909:  an empty template parameter list is not allowed in a lambda expression
Pe2910:  the version of Microsoft being emulated must be at least 1920 to use "--ms_c++20"
Pe2911:  STDC pragma argument not accepted in this mode
Pe2912:  constexpr if statements are a C++17 feature
Pe2913:  pack expansion is not allowed in a designated initializer list
Pe2914:  field designator has no value
Pe2915:  a union can have at most one field initializer
Pe2916:  no valid std::%s type found (<compare> must be included)
Pe2917:  invalid types (%t1 and %t2) for built-in operator<=>
Pe2918:  fold expressions are nonstandard in this mode
Pe2919:  C++17-style initializer is nonstandard in this mode
Pe2920:  capturing *this is nonstandard in this mode
Pe2921:  C++17-style "using" attribute prefix is nonstandard in this mode
Pe2922:  C++17-style nested namespaces are nonstandard in this mode
Pe2923:  only one of "constexpr", "consteval", and "constinit" can appear on a declaration
Pe2924:  a function cannot be both consteval and virtual in this mode
Pe2925:  "consteval" is not allowed on an explicit instantiation directive
Pe2926:  "consteval" is not valid here
Pe2927:  a destructor cannot be consteval
Pe2928:  a constructor for a class with virtual bases cannot be consteval
Pe2929:  "consteval" is not permitted on the declaration of a variable or static data member
Pe2930:  %nd was previously declared consteval
Pe2931:  %nd was previously not declared consteval
Pe2932:  function "main" may not be declared consteval
Pe2933:  call to consteval %n did not produce a valid constant expression
Pe2934:  address of consteval %n in constant expression result
Pe2935:  consteval member cannot override non-consteval %n
Pe2936:  non-consteval member cannot override consteval %n
Pe2938:  dynamic_cast to subobject of type %t1 is invalid (most-derived type is %t2)
Pe2939:  the identifier __VA_OPT__ can only appear in the replacement lists of variadic macros
Pe2940:  __VA_OPT__ cannot appear in a __VA_OPT__ operand
Pe2941:  missing closing parenthesis for __VA_OPT__
Pe2942:  __VA_OPT__ must be followed by "("
Pe2943:  "##" may not be first in a __VA_OPT__ operand
Pe2944:  "##" may not be last in a __VA_OPT__ operand
Pe2945:  C++20-style nested inline namespaces are nonstandard in this mode
Pe2946:  cannot convert pointer to base class %t2 to pointer to derived class %t1 -- attempt to point beyond the most-derived object
Pe2948:  "main" cannot be used as a global variable name or given C language linkage
Pe2949:  function "main" cannot be declared in a linkage-specification
Pe2950:  structured binding is not allowed in a condition
Pe2951:  an attribute namespace identifier is required before "::"
Pe2952:  only one attribute namespace is allowed
Pe2953:  "return" not allowed here
Pe2954:  a structured binding cannot be combined with other declarators
Pe2955:  cannot branch out of a constant-evaluation context
Pe2956:  structured binding templates are not permitted
Pe2957:  a parenthesized initializer must be an expression, not a brace-enclosed list
Pe2958:  cannot deduce class template arguments
Pe2959:  a new or delete operator cannot be declared "consteval"
Pe2960:  the address of a consteval function cannot be used here
Pe2961:  the alignment of a function type (%t) is nonstandard
Pe2962:  the alignment of an array of unspecified bound is nonstandard in C
Pe2963:  a variable cannot have both "common" and "internal_linkage" attributes
Pe2964:  the "internal_linkage" attribute did not appear on a prior declaration
Pe2965:  no viable template argument deduction candidate found for %n
Pe2966:  a fully qualified constructor call is not allowed
Pe2967:  a defaulted comparison operator must be a member or a friend of the class it applies to
Pe2968:  bad type %t for parameter of defaulted comparison operator (must be "reference to const X" where X is the enclosing class type)
Pe2969:  return type of defaulted comparison operator must be "bool"
Pe2970:  a defaulted member comparison operator must be "const"
Pe2972:  a coroutine's promise type %t cannot have both "return_void" and "return_value" set
Pe2973:  "return_value" declared %p
Pe2974:  "return_void" declared %p
Pe2975:  missing co_return statement while %t has no "return_void" at end of %n
Pe2976:  no nothrow variant of the global "operator new" found for coroutine state allocation
Pe2977:  no viable "operator delete" found for coroutine state deallocation
Pe2978:  a constexpr function cannot be a coroutine
Pe2979:  the operand to this %s expression resolves to non-class %t
Pe2980:  a co_await expression is not allowed in a static initializer
Pe2981:  the co_await expression calling %n must be non-throwing
Pe2982:  too many recursive comparison rewrite operations
Pe2983:  a deducible return type for a default operator<=> must be "auto"
Pe2984:  implicit copy of non-constant source
Pe2985:  a structured binding cannot declare an explicit storage class other than static or thread_local
Pe2986:  defaulted comparison operators are not supported for nontrivial Microsoft property fields
Pe2987:  standard comparison type (%t) must be a class type with a single nonstatic data member of integral type
Pe2988:  no constexpr static data member %sq found in %t
Pe2989:  number of elements (%d) too large for dynamic allocation
Pe2990:  constexpr dynamic allocation request too large
Pe2991:  deallocation of storage that was not dynamically allocated
Pe2992:  deallocation size (%d1) does not correspond to size allocated (%d2)
Pe2993:  allocation occurred here
Pe2994:  deallocation type (%t1) does not correspond to allocation type (%t2)
Pe2995:  some dynamic allocations (total number = %d) were not deallocated
Pe2996:  intrinsic %n declared with unexpected signature (type %t)
Pe2997:  >> output from std::__report_constexpr_value
Pe2998:  >> end output from std::__report_constexpr_value
Pe2999:  cannot use array with dependent array size in constexpr evaluation
Pe3000:  ignoring return value from routine declared with "nodiscard" attribute (%sq)
Pe3001:  ignoring return value type with "nodiscard" attribute (%sq)
Pe3002:  constructor used to create discarded object has "nodiscard" attribute
Pe3003:  constructor used to create discarded object has "nodiscard" attribute (%sq)
Pe3004:  type of discarded object has "nodiscard" attribute
Pe3005:  type of discarded object has "nodiscard" attribute (%sq)
Pe3006:  a pseudo-destructor reference can only be used for a pseudo-destructor call
Pe3007:  an explicit destructor call is not permitted in a constant-expression
Pe3008:  an unparenthesized comma operator in an array subscript expression is deprecated
Pe3009:  number of dynamically-allocated elements (%d) too small for initializer
Pe3010:  a volatile operand to %s expression is deprecated
Pe3011:  use of the result of an assignment to a volatile scalar object is deprecated
Pe3012:  a volatile destination type for a compound assignment expression is deprecated
Pe3013:  a volatile function parameter is deprecated
Pe3014:  a volatile return type is deprecated
Pe3015:  use of a volatile qualifier on a structured binding is deprecated
Pe3016:  the "ext_vector_type" argument must be between 1 and 2047
Pe3017:  the "ext_vector_type" attribute may appear only in a typedef
Pe3018:  the "ext_vector_type" attribute applies only to integer or floating-point types
Pe3019:  this feature-test macro is ignored (and returns 0) in the current compilation mode
Pe3020:  cannot evaluate an aggregate initializer with multiple elements for a union
Pe3021:  %nd selected for operator rewrite does not return type bool
Pe3022:  a new-expression calling a class-specific allocation function cannot be constant-evaluated
Pe3023:  a placement new-expression cannot be constant-evaluated
Pe3024:  deleting through a subobject pointer requires a virtual destructor
Pe3026:  operand of __INTADDR__ must be offset from null pointer
Pe3027:  _Generic construct matches multiple types
Pe3028:  the other match is %t
Pe3029:  the "availability" attribute used here is ignored
Pe3030:  C++20-style initializer statement in a range-based "for" statement is nonstandard in this mode
Pe3031:  co_await can only apply to a range-based for statement
Pe3032:  cannot deduce type of range in range-based "for" loop
Pe3033:  inline variables are a C++17 feature
Pe3034:  destroying operator delete requires %t as first parameter
Pe3035:  a destroying operator delete cannot have parameters other than std::size_t and std::align_val_t
Pe3036:  relaxed abstract class options can be used only when compiling C++
Pe3037:  invalid start of expression in requires clause
Pe3038:  a cast expression in a requires-clause must be parenthesized
Pe3039:  this operator cannot appear at the top level (without parentheses) in a requires-clause
Pe3040:  atomic constraint must have type bool
Pe3041:  atomic constraint failed substitution
Pe3042:  atomic constraint not constant
Pe3043:  atomic constraint evaluates to false
Pe3044:  template constraint not satisfied
Pe3045:  concept definition cannot appear in this scope
Pe3046:  invalid redeclaration of %nd
Pe3047:  substitution of arguments %T for concept-id failed
Pe3048:  concept is false for arguments %T
Pe3049:  a requires-clause is not allowed here (not a templated function)
Pe3051:  requires-clause incompatible with %nfd
Pe3052:  expected an attribute
Pe3054:  expected a type name
Pe3055:  an ellipsis parameter is not permitted in a requires-expression
Pe3056:  unnamed parameter in requires-expression has no effect
Pe3057:  expected a concept name
Pe3058:  call to %s appearing in a constant expression always produces "true"
Pe3059:  call to %s appearing in a consteval context always produces "true"
Pe3060:  call to %s appearing in a non-constexpr function always produces "false"
Pe3061:  type constraint failed for %t
Pe3062:  option "export" cannot be used in modes where C++ modules are enabled
Pe3063:  a global module fragment declaration must precede any other declaration
Pe3064:  a module declaration can only be preceded by a global module fragment
Pe3065:  a private module fragment must be preceded by a module declaration
Pe3066:  a %s module fragment cannot be exported
Pe3067:  cannot declare more than one module
Pe3068:  cannot declare more than one %s module fragment
Pe3069:  a module must be declared with a non-empty name
Pe3070:  %sq is not an importable header
Pe3071:  cannot import a module with no name
Pe3072:  a module cannot have an interface dependency on itself
Pe3073:  module %sq has already been imported
Pe3075:  could not find module file for module %sq
Pe3076:  could not import module file %sq
Pe3077:  expected %s1, found %s2 instead
Pe3079:  unknown partition name %sq
Pe3085:  the type of the second operand %t2 must have the same size as %t1
Pe3086:  type must be trivially copyable
Pe3087:  type %t is currently not supported for constexpr evaluation of __builtin_bit_cast
Pe3088:  class types with bitfields %t are not currently supported for constexpr evaluation of __builtin_bit_cast
Pe3089:  non-static data member of reference type %t prevents constexpr evaluation of __builtin_bit_cast
Pe3090:  a volatile type %t prevents constexpr evaluation of __builtin_bit_cast
Pe3091:  a union, pointer, or pointer-to-member type %t prevents constexpr evaluation of __builtin_bit_cast
Pe3093:  the sub-object construction of %t for inheriting constructors cannot be performed -- the implicit default constructor is deleted
Pe3094:  %n must return void
Pe3095:  invalid start of member declaration
Pe3096:  expected "auto"
Pe3097:  this operator is not allowed at this point; parenthesize the preceding new-expression
Pe3098:  invalid use of concept
Pe3099:  a defaulted member comparison operator cannot be "&&"-qualified
Pe3100:  default constexpr comparison function calls non-constexpr function %nd
Pe3101:  constexpr memory comparison is only supported for top-level integer or array-of-integer objects
Pe3102:  a concept template cannot have associated constraints
Pe3103:  "export" is not allowed
Pe3104:  exporting individual class members is not allowed
Pe3105:  an exported declaration must introduce a name
Pe3106:  an export declaration cannot contain an export declaration (previous declaration %p)
Pe3107:  an export declaration cannot contain a module import declaration
Pe3108:  an export declaration can only appear in a module interface unit
Pe3109:  an export declaration cannot export a name with internal linkage
Pe3111:  builtin function is not available because __fp16 floating-point types are not supported
Pe3112:  a requires-expression must specify at least one requirement
Pe3113:  "constinit" is not valid here
Pe3114:  "constinit" is only valid for declarations of variables with static or thread storage duration
Pe3115:  constinit variable requires dynamic initialization
Pe3116:  variable was previously declared with "constinit" %p
Pe3117:  use of non-prototype function declarator
Pe3118:  argument cannot have a const-qualified type
Pe3119:  a pointer-to-member of an incomplete type %t is not allowed
Pe3120:  pack expansion in init-capture not enabled in this mode
Pe3121:  pack expansion in init-capture is a C++20 feature
Pe3122:  a comparison operator defaulted in a class definition must be the first declaration of that comparison operator (%nd)
Pe3123:  a pack expansion in an init-capture can be used only in a variadic template
Pe3124:  type constraint uses %nd that is not a type concept (i.e., a concept template whose first parameter is a type parameter)
Pe3125:  the deduced placeholder type %t failed the type constraint
Pe3126:  default constructor for %t is not eligible
Pe3127:  destructor for %t is ambiguous because of unordered constraints
Pe3128:  destructor for %t is ineligible because of failed constraints
Pe3129:  ambiguous destructor candidate
Pe3130:  a virtual function cannot have a trailing requires clause
Pe3131:  %nd does not satisfy its constraints
Pe3132:  result of decltype qualifier %t is not a class or enumeration
Pe3133:  comparison is ambiguous in standard C++20 because the implied comparison operator with reversed parameters is an equally good match -- this is usually caused by a missing "const" qualifier on the comparison operator; see %nod
Pe3134:  invalid concept-id
Pe3135:  substitution of arguments %T for requires-clause failed
Pe3136:  constraints for %nd are not satisfied
Pg001:  incorrect value for preprocessing controlling expression
Pg002:  a macro parameter immediately following a # is immediately followed by a ##
Pg003:  missing static storage modifier for %sq which has internal linkage
Pg004:  macro parameter %sq is used in both expanded and raw forms
Pg005:  octal or hexadecimal escape sequence is not terminated
Pg006:  a preprocessing directive shall not occur within a macro argument
Pm001:  compiler is not configured to compile C89/C95 code - all code shall conform to ISO 9899 standard C
Pm002:  compiler is configured to allow extensions - all code shall conform to ISO 9899 standard C, with no extensions permitted
Pm003:  nonstandard characters or escape sequences shall not be used
Pm004:  trigraphs shall not be used
Pm005:  multibyte characters shall not be used
Pm006:  wide string literals shall not be used
Pm007:  comments shall not be nested
Pm008:  sections of code should not be 'commented out'
Pm009:  symbol has the same initial 31 characters as %nd - identifiers (internal and external) shall not rely on significance of more than 31 characters
Pm010:  same name as %nd - no identifier in one name space shall have the same spelling as an identifier in another name space
Pm011:  the basic types of char, int, short, long, float, and double should not be used, but specific-length equivalents should be typedef'd for the specific compiler, and these type names used in the code
Pm012:  the type char shall always be declared as unsigned char or signed char
Pm013:  same name as %nd - typedef names shall not be reused
Pm014:  this constant will not have the type %t in all implementations - numeric constants should be suffixed to indicate type, where an appropriate suffix is available
Pm015:  octal constants shall not be used
Pm016:  all object and function identifiers shall be declared before use
Pm017:  symbol hides %nd - identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide the identifier
Pm018:  the register storage class specifier should not be used
Pm019:  identifiers shall not simultaneously have both internal and external linkage in the same translation unit
Pm020:  enumerated type mixed with another type - the use of a tag shall agree with its declaration
Pm021:  %n is used before its value is set - all automatic variables shall be assigned a value before being used
Pm022:  missing left brace - braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures
Pm023:  missing elements - braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures
Pm024:  extra left brace - braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures
Pm025:  in an enumerator list, the '=' construct shall not be used to explicitly initialize members other than the first, unless all items are explicitly initialized
Pm026:  the right hand operand of an && or || operator shall not contain side effects
Pm027:  this is not a primary expression - the operands of a logical && or || shall be primary expressions
Pm028:  assignment operators shall not be used in expressions which return boolean values
Pm029:  this bitwise operation is in a boolean context - logical operators should not be confused with bitwise operators
Pm030:  this boolean operation is the operand of a bitwise operator - logical operators should not be confused with bitwise operators
Pm031:  bitwise operations shall not be performed on signed integer types
Pm032:  the right hand operand of a shift operator shall lie between zero and one less than the width in bits of the left hand operand (inclusive)
Pm033:  the unary minus operator shall not be applied to an unsigned expression
Pm034:  the sizeof operator should not be used on expressions that contain side effects
Pm035:  the comma operator shall not be used
Pm036:  implicit conversions which may result in a loss of information shall not be used
Pm037:  redundant explicit casts should not be used
Pm038:  type casting from any type to or from pointers shall not be used
Pm039:  an lvalue is modified more than once without an intervening sequence point in this statement - the value of an expression shall be the same under any order of evaluation that the standard permits
Pm040:  %nd (or a value reached by some form of indirection through it) is modified more than once without an intervening sequence point in this statement - the value of an expression shall be the same under any order of evaluation that the standard permits
Pm041:  the order of read and modification is undefined in this statement - the value of an expression shall be the same under any order of evaluation that the standard permits
Pm042:  the order of read and modification of %nd (or a value reached by some form of indirection through it) is undefined in this statement - the value of an expression shall be the same under any order of evaluation that the standard permits
Pm043:  the order of volatile accesses is undefined in this statement - the value of an expression shall be the same under any order of evaluation that the standard permits
Pm044:  the order of volatile accesses to %nd (or a value reached by some form of indirection through it) is undefined in this statement - the value of an expression shall be the same under any order of evaluation that the standard permits
Pm045:  mixed precision arithmetic should use explicit casting to generate the desired result
Pm046:  floating point values shall not be tested for exact equality or inequality
Pm047:  evaluation of constant unsigned integer expressions should not lead to wrap-around
Pm048:  there shall be no unreachable code
Pm049:  all non-null statements shall have a side-effect
Pm050:  a null statement shall only occur on a line by itself, and shall not have any other text on the same line
Pm051:  labels should not be used, except in switch statements
Pm052:  the goto statement shall not be used
Pm053:  the continue statement shall not be used
Pm054:  the break statement shall not be used (except to terminate the cases of a switch statement)
Pm055:  the statement forming the body of an if, else if, else, while, do ... while, or for statement shall always be enclosed in braces
Pm056:  all if, else if constructs should contain a final else clause
Pm057:  every non-empty case clause in a switch statement shall be terminated with a break statement
Pm058:  all switch statements shall contain a final default clause
Pm059:  a switch expression should not represent a boolean value
Pm060:  only one case - a switch expression should not represent a boolean value
Pm061:  every switch statement shall have at least one case
Pm062:  floating point value detected in loop condition - floating point variables shall not be used as loop counters
Pm063:  functions shall always be declared at file scope
Pm064:  functions with variable number of arguments shall not be used
Pm065:  not a prototype - functions shall always have prototype declarations and the prototype shall be visible at both the function definition and call
Pm066:  no prototype seen - functions shall always have prototype declarations and the prototype shall be visible at both the function definition and call
Pm067:  type %t1 is not identical with type %t2 given in declaration %p - for each function parameter the type given in the declaration and definition shall be identical, and the return types shall also be identical
Pm068:  identifiers shall either be given for all the parameters in a function prototype declaration, or for none
Pm069:  if identifiers are given for any of the parameters, then the identifiers used in the declaration and definition shall be identical
Pm070:  the type shall be explicitly stated
Pm071:  functions with no parameters shall be declared with parameter type void
Pm072:  the argument has type %t1, but the expected type is %t2 - the unqualified type of parameters passed to a function shall be compatible with the unqualified expected types defined in the function prototype
Pm073:  previous exit seen %p - a function should have a single point of exit
Pm074:  no return value for non-void function %n - for functions with non-void return types: (1) there shall be one return statement for every exit branch (including the end of the program), (2) each return shall have an expression, (3) the return expression shall match the declared return type
Pm075:  the type of this expression is %t1, but the function has return type %t2 - for functions with non-void return types: (1) there shall be one return statement for every exit branch (including the end of the program), (2) each return shall have an expression, (3) the return expression shall match the declared return type
Pm076:  function call with no parameters should have empty parentheses
Pm077:  #include statements in a file shall only be preceded by other preprocessor directives or comments
Pm078:  non standard characters shall not occur in header file names in #include directives
Pm079:  the #include directive shall be followed by either a <filename> or "filename" sequence
Pm080:  macros shall not be #define'd and #undef'd within a block
Pm081:  #undef should not be used
Pm082:  a function-like macro shall not be 'called' without all its arguments
Pm083:  arguments to a function-like macro shall not contain tokens that look like pre-processing directives
Pm084:  in the definition of a function-like macro, the whole definition shall be enclosed in parenthesis
Pm085:  identifiers in pre-processor directives should be defined before use
Pm086:  there shall be at most one occurrence of the # or ## preprocessor operator in a single macro definition
Pm087:  the defined pre-processor operator shall only be used in one of the two standard forms
Pm088:  pointer arithmetic should not be used
Pm089:  no more than 2 levels of pointer indirection should be used
Pm090:  cast of non-constant to function pointer - non-constant pointers to function shall not be used
Pm091:  cast between function pointer types - all the functions pointed to by a single pointer to function shall be identical in the number and type of parameters and the return type
Pm092:  in the specification of a structure or union type, all members of the structure or union shall be fully specified
Pm093:  use of union - overlapping storage shall not be used
Pm094:  unions shall not be used to access sub-parts of larger data types
Pm095:  bit fields shall only be defined to be of type unsigned int or signed int
Pm096:  bit fields of type signed int shall be at least 2 bits long
Pm097:  all the members of a structure (or union) shall be named and shall only be accessed via their name
Pm098:  reserved words and standard library function names shall not be redefined or undefined
Pm099:  standard library function names shall not be reused
Pm100:  dynamic heap memory allocation shall not be used
Pm101:  the error indicator errno shall not be used
Pm102:  the macro offsetof, in library <stdddef.h>, shall not be used
Pm103:  <locale.h> and the setlocale function shall not be used
Pm104:  the setjmp macro and the longjmp function shall not be used
Pm105:  the signal handling facilities of <signal.h> shall not be used
Pm106:  NDEBUG is defined - the input/output library <stdio.h> shall not be used in production code
Pm107:  the library functions atof, atoi, and atol from library <stdlib.h> shall not be used
Pm108:  the library functions abort, exit, getenv, and system from library <stdlib.h> shall not be used
Pm109:  the time handling functions of library <time.h> shall not be used
Pm110:  %sq (or a value reached by some form of indirection through it) is modified more than once without an intervening sequence point in this statement - the value of an expression shall be the same under any order of evaluation that the standard permits
Pm111:  the order of read and modification of %sq (or a value reached by some form of indirection through it) is undefined in this statement - the value of an expression shall be the same under any order of evaluation that the standard permits
Pm112:  the order of volatile accesses to %sq (or a value reached by some form of indirection through it) is undefined in this statement - the value of an expression shall be the same under any order of evaluation that the standard permits
Pm113:  the statement forming the body of a 'switch', 'while', 'do ... while', or 'for' statement shall be a compound statement
Pm114:  an 'if (expression)' construct shall be followed by a compound statement. The 'else' keyword shall be followed by either a compound statement, or another 'if' statement
Pm115:  a switch label shall only be used when the most closely-enclosed compound statement is the body of a 'switch' statement
Pm116:  source code shall only use /* ... */ style comments
Pm117:  octal escape sequences shall not be used
Pm118:  hexadecimal escape sequences shall not be used
Pm119:  identifiers shall be given for all of the parameters in a function prototype declaration
Pm120:  the # and ## preprocessor operators should not be used
Pm121:  precautions shall be taken in order to prevent the contents of a header file being included twice
Pm122:  preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor
Pm123:  there shall be no definition of objects or functions in a header file
Pm124:  the 'static' storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage
Pm125:  when an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation
Pm126:  if the bitwise operators ~ and << are applied to an operand of underlying type 'unsigned char' or 'unsigned short', the result shall be immediately cast to the underlying type of the operand
Pm127:  a 'U' suffix shall be applied to all constants of 'unsigned' type
Pm128:  illegal implicit conversion from underlying MISRA type %t1 to %t2
Pm129:  illegal implicit conversion from underlying MISRA type %t1 to %t2 in complex expression
Pm130:  illegal implicit conversion from underlying MISRA type %t1 to %t2 in return statement
Pm131:  illegal implicit conversion from underlying MISRA type %t1 to %t2 in function call
Pm132:  illegal implicit conversion from %t1 to %t2
Pm133:  illegal implicit conversion from %t1 to %t2 in complex expression
Pm134:  illegal implicit conversion from %t1 to %t2 in return statement
Pm135:  illegal implicit conversion from %t1 to %t2 in function call
Pm136:  illegal explicit conversion from underlying MISRA type %t1 to %t2
Pm137:  illegal explicit conversion from type %t1 to %t2
Pm138:  conversions shall not be performed between a pointer to a function and any other type other than an integral type, this converts from type %t1 to %t2
Pm139:  conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void. This converts from type %t1 to %t2
Pm140:  a cast should not be performed between a pointer type and an integral type, this casts from type %t1 to %t2
Pm141:  a cast should not be performed between a pointer to object type and a different pointer to object type, this casts from type %t1 to %t2
Pm142:  A cast shall not be performed that removes any 'const' or 'volatile' qualification from the type addressed by the pointer, this casts from type %t1 to %t2
Pm143:  a function should have a single point of exit at the end of the function
Pm144:  for any iteration statement there shall be at most one 'break' statement used for loop permination
Pm145:  boolean operations whose results are invariant shall not be permitted
Pm146:  the controlling expression of a 'for' statement shall not contain any objects of floating type
Pm147:  the three expressions of a 'for' statement shall be concerned only with loop control
Pm148:  in 'for' statements, the following options are allowed: (a) all three expressions shall be present; (b) the second and third expressions shall be present with prior initialisation of the loop counter. (c) all three expressions shall be empty for a deliberate infinite loop
Pm149:  USE ME USE ME!
Pm150:  the names of standard library macros, objects, and functions shall not be reused
Pm151:  all exit paths from a function with non-void return type shall have an explicit 'return' statement with an expression
Pm152:  array indexing shall only be applied to objects defined as an array type
Pm153:  the increment (++) and decrement (--) operators should be the only side-effect of an expression
Pm154:  in the definition of a function-like macro, each instance of a parameter shall be enclosed in parenthesis
Pm155:  no prototype seen - functions (even static) shall always have prototype declarations and the prototype shall be visible at both the function definition and call
Pm156:  incorrect value for preprocessing controlling expression
Pm157:  a macro parameter immediately following a # is immediately followed by a ##
Pm158:  missing static storage modifier for %sq which has internal linkage
Pm159:  macro parameter %sq is used in both expanded and raw forms
Pm160:  octal or hexadecimal escape sequence is not terminated
Pm161:  a preprocessing directive shall not occur within a macro argument
Su001:  No source file specified
Su002:  Unexpected command line arguments:
Su006:  The parameter to the command line option %sq1 was %sq2, which has an initial "-". If that is desired, use an initial "---" instead
Su007:  Unable to open the command file %sq
Su008:  Command file recursion. A request to process %sq was found while already processing that file
Su009:  Missing closing quote in command file
Su010:  Comment unclosed at end of command file
Su011:  More than one source file specified:
Su013:  The use of this option is deprecated: %s
Ta005:  Cannot call an __arm function from thumb mode
Ta006:  Cannot call the __arm function %no from thumb mode
Ta007:  Cannot call a __thumb function from arm mode
Ta008:  Cannot call the __thumb function %no from arm mode
Ta014:  Auto variable %no cannot have storage specifier
Ta015:  Auto variable %no cannot have __no_init attribute
Ta016:  Auto variable %no cannot be located
Ta017:  Auto variable %no cannot be located to section %s
Ta020:  Misaligned stack reference is not supported
Ta021:  Library call (%s) from within a __ramfunc function
Ta022:  Possible rom access (%s) from within a __ramfunc function
Ta023:  Call to a non __ramfunc function (%s) from within a __ramfunc function
Ta025:  Interrupt function %no must be __arm
Ta026:  Interrupt function %no must have void return
Ta027:  Interrupt function %no cannot have parameters
Ta028:  #pragma vector is not supported for non interrupt function %no
Ta029:  __thumb functions can only call __svc functions with svc_number in range 0-0xFF
Ta030:  Illegal svc_number syntax, usage #pragma svc_number=<0-0xFFFFFF>
Ta032:  The specified svc_number is associated with another function
Ta033:  No svc_number specified for __svc function, use #pragma svc_number=<number>
Ta034:  __svc function %no must be __arm
Ta035:  Stackspace must be used to pass parameters to __svc function
Ta048:  Only functions with __irq attribute can have __nested attribute
Ta049:  Attribute %sq is obsolete
Ta051:  Interrupt function %no cannot be interwork
Ta052:  Endian attribute is not available in this core
Ta053:  Endian attribute is not allowed on parameter %t
Ta054:  Endian attribute is not allowed on function return type %t
Ta056:  Compound access to endian specified %t is not allowed
Ta057:  Variable with endian specifier %no cannot have initializer
Ta061:  Module too big
Ta062:  Function %no previously seen as %s
Ta063:  SWI/SVC is not available in this core
Ta065:  Incompatible type attributes, %sq1 and %sq2
Ta066:  Cannot call function %no with vfp calling convention from thumb mode
Ta067:  Thumb function %no cannot use vfp calling convention
Ta068:  Argument %sq1 is not valid for #pragma %s2
Ta070:  Invalid core (%s) for this license
Ta071:  The address of a pc/static base relative object cannot be used in static initialization
Ta072:  __ramfunc is not available when generating ropi-code
Ta073:  __ramfunc is not available when generating rwpi-code
Ta074:  Illegal access to statically allocated read/write-object %no in RWPI-compatible mode
Ta075:  PC-relative reference to weak external symbol %no
Ta076:  Static base relative reference to weak external symbol %no
Ta077:  Stackless function can't have aggregate return type
Ta078:  Stackless function can't have aggregate parameters
Ta079:  Passing all parameters to this stackless function would require use of the stack
Ta080:  Function %no with attribute %sq cannot be compiled without allocated auto area
Ta081:  Inline assembler constraint %sq is incompatible with operand expression
Ta082:  Inline assembler constraint %sq is not supported
Ta083:  Inline assembler constraint %sq only available for cores with VFP
Ta084:  Inline assembler constraint %sq not available for selected core/mode
Ta085:  Inline assembler clobber operand %sq is not supported
Ta086:  Register %s is only available to clobber for cores with VFP
Ta087:  Register %s not available to clobber in selected core/mode
Ta088:  Alignment of operand for constraint %sq must be 4 or higher
Ta089:  Constant is out of range for immediate operand constraint
Ta090:  Immediate operand is not constant
Ta092:  Operand modifier %s1 is not valid for symbolic value %s2
Ta093:  Operand modifier %s1 is unknown
Ta094:  Operand modifier %s1 is not valid for operand %s2
Ta095:  Operand modifier sequence %s1 is not valid for operand %s2
Ta096:  Cannot call intrinsic function %no from ARM mode in this architecture
Ta097:  Cannot call intrinsic function %no from Thumb mode in this architecture
Ta098:  ARM mode is not available in this core
Ta099:  Thumb mode is not available in this core
Ta100:  Unknown register specified for command line option --lock_regs
Ta101:  Register %s not allowed for command line option --lock_regs
Ta102:  Invalid register interval specified for --lock_regs
Ta103:  Argument %sq is not valid for option --ebk
Ta104:  Command line option --segment is obsolete: use --section
Ta105:  Multiple cpu modes specified
Ta106:  Cannot generate code in ARM mode for the specified cpu
Ta107:  Cannot generate VFP code for the specified cpu
Ta108:  VFP calling convention is not supported for this configuration
Ta109:  Cannot behave as both --eval_version and --kick_version
Ta110:  Argument %sq is not valid for option --legacy
Ta111:  Argument %sq is not valid for option --enable_hardware_workaround
Ta112:  Multiple svc/swi vectors found for function %no
Ta113:  Argument to --code_alignment must be power of two
Ta114:  Option --no_literal_pool is only valid for ARMv7, and ARMv6-M non-ROPI/RWPI
Ta115:  Pointers in global registers cannot be handled with bounds checking
Ta116:  Instruction needs two slots in IT-block: IT-block in inline assembler cannot have more than four slots
Ta117:  IT-block ends prematurely, or there is a label within the IT-block
Ta118:  ARM mode is not available with --enable_hardware_workaround=RM4x_B064
Ta119:  STREXD is not available with --enable_hardware_workaround=RM4x_B064
Ta120:  A variadic function cannot use vfp calling convention
Ta121:  Auto variable %no cannot have a stricter alignment than the stack
Ta122:  Float operations is not available in functions declared with __aapcs_core
Ta123:  Functions declared with __aapcs_core can only call functions declared with __aapcs_core
Ta124:  Register %s not available: it has been locked using --lock_regs or as a global register variable
Ta125:  Function declared as using vfp calling convention but target for compilation does not have floating point coprocessor
Ta126:  The return type is not compatible with the __value_in_regs attribute
Ta127:  Functions declared with __aapcs_core is not compatible with floating point interface
Ta128:  Secure entry function cannot be declared with attribute %s
Ta129:  Secure entry function cannot take arguments on the stack
Ta130:  Secure entry function cannot return value through return value pointer
Ta131:  Non secure call can only be compiled in CMSE mode
Ta132:  Non secure call can not be done to C++ function
Ta133:  Non secure call can not be defined
Ta134:  Non secure call cannot put arguments on the stack
Ta135:  Non secure call cannot return value through return value pointer
Ta136:  Non secure call cannot use vfp calling convention
Ta137:  Invalid special register %sq
Ta138:  Invalid special register %sq1, %s2
Ta139:  cmse_nonsecure_call can only be used with function pointer
Ta140:  Special register %sq1 is not available%s2
Ta141:  Thread local storage, used on %no, is not available when compiling for RWPI
Ta142:  Secure entry function cannot be a variadic function
Ta143:  Cannot build secure image for core without Cortex-M Security Extensions
Ta144:  Cannot build position independent secure image
Ta145:  Constraint %sq can not be used on output operands
Ta146:  Constant referenced from inline assembler is too complex
Ta147:  Unknown symbol %sq referenced from inline assembler
Ta148:  Intrinsic function %no is not available in this architecture
Ta149:  Barrier limitation %s is not available for this architecture
Ta150:  Cannot generate code in Aarch64 mode for the specified cpu
Ta151:  Option not available for %s1: %s2
Ta152:  Memory ordering %s invalid for atomic operation
Ta153:  Operand value may be truncated
Ta154:  Object too large: %nf (%s1 bytes). Max size = %s2
Ta155:  Exception function %no must have void return
Ta156:  Exception function %no cannot have parameters
Ta157:  Only exception and SVC functions can have __nested attribute
Ta158:  #pragma vector is not supported for non SVC function %no
Ta159:  The exception function %no cannot be a SVC function as well
Ta160:  Argument out of range, value should be between %s1 and %s2
Ta161:  Exception function %no has size %s bytes. Maximum size of a vector is 128 bytes
Ta162:  Located address, used on %no, is too high
Ta163:  The relocation is not supported in this version of the abi
Ta164:  The specified offset must be a multiple of %s.
Ta165:  Generating code for %s is not allowed with this license.
Ta166:  Illegal vector duplicate increment count, legal values are 1, 2, 4 or 8.
Ta167:  Illegal vector clear mask, must be an 8-bit value left shifted a multiple of 8 steps
Ta168:  Pragma section_prefix overrides command line option --section_prefix
TcuCover001:  Expected cover point "%s"
TcuCover002:  Forbidden cover point "%s" present
TcuCover003:  Expected '=name_of_cover_point' after pragma
