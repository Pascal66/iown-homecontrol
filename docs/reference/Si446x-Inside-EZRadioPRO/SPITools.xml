<?xml version="1.0" encoding="utf-8"?>
<SPITools>
  <SPIDevice chipID="9" type="Si4032" revision="B" projectID="P828" name="Tamara RevB">
    <TxPufferSize>32</TxPufferSize>
    <RxPufferSize>0</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress></RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="enfec" />
      <Bit index="5" name="enmanch" />
      <Bit index="4" name="enwhite" />
      <Bit index="3" name="dssr[3]" />
      <Bit index="2" name="dssr[2]" />
      <Bit index="1" name="dssr[1]" />
      <Bit index="0" name="dssr[0]" />
      <Description>enfec = Forward Error Correction is enabled if this bit is set.
enmanch = Manchester Coding is enabled if this bit is set.
enwhite = Data Whitening is enabled if this bit is set.
dssr[3:0] = Direct Sequence Spread Spectrum Chip Pattern Length.
  The number of chip pattern bits used from the DSSS Pattern Look-up Table equals dssr[3:0]+1.
  If dssr[3:0] = 0 then the DSSS mode is disabled. (not impl.)</Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="23" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="modsrc[1]" />
      <Bit index="4" name="modsrc[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="modtyp[2]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>trclk[1:0] = TX Data Clock Configuration. 
  00 – No TX Data CLK is available (asynchronous mode)
  01 – TX Data CLK is available via the GPIO (one of the GPIO’s should be programmed as well)
  10 – TX Data CLK is available via the SCK pin (implemented: SDO pin instead!)
  11 – TX Data CLK is available via the nIRQ pin (not impl.)
modsrc[1:0] = Modulation Source
  00 –  Direct Mode using TX_Data function via the GPIO pin (one of the GPIO’s should be  programmed accordingly as well)
  01 –  Direct Mode using TX_Data function via the SDI pin (only when nSEL is high) (not impl.)
  10 –  FIFO Mode
  11 –  PN9 (internally generated)
eninv = Invert TX Data
modtyp[2:0] = Modulation Type 
  000 – Unmodulated carrier
  001 – OOK
  010 – FSK
  011 – GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)</Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="43" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>The frequency deviation can be calculated: Fd = 625 Hz * fd[7:0] 
fd[7:0] = Frequency Deviation Setting. See formula above.</Description>
    </Register>
    <Register address="73" name="Frequency Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>The frequency offset can be calculated: Offset = 156.25 Hz * (hbsel + 1) * fo[6:0] ; MSB = fo[7] = Sign bit
fo[7:0] = Frequency Offset Setting.</Description>
    </Register>
    <Register address="74" name="Frequency Look-Up Table Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="X" />
      <Bit index="2" name="frqadd[2]" />
      <Bit index="1" name="frqadd[1]" />
      <Bit index="0" name="frqadd[0]" />
      <Description>frqadd[2:0] = Frequency Look-up Table Address.
This address selects the current frequency and band setting from the Look-up Table.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="35" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="-" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>hbsel = High Band Select.
  Setting hbsel = ‘1’ will choose the freqency range from 480-960MHz (High Bands).
  Setting hbsel = ‘0’ will choose the freqency range from 240-479.9MHz (Low Bands).
fb[4:0] = Frequency Band Select.
  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.
  Setting fb[4:0]=’00000’ corresponds to the 240-250MHz Band for hbsel=’0’ and the 480-500MHz Band for hbsel=’1’.
  Setting fb[4:0]=’00001’ corresponds to the 250-260MHz Band for hbsel=’0’ and the 500-520MHz Band for hbsel=’1’.</Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>The RF transmit frequency can be calculated as:
   ftx = (fb+24+(fc+fo) / 64000) * 10000 * (hbsel+1) + (fhch * fhs * 10)  [kHz],
where parameters fc, fo, fb and hb_sel come from the current location of the frequency look-up table
addressed by the look-up table pointer (register 76h). These parameter values can be read out from
registers 75h – 77h.
Parameters fhch and fhs come from register 78h and 79h.
fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="7A" name="TX FIFO Content Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="nbstx[5]" />
      <Bit index="4" name="nbstx[4]" />
      <Bit index="3" name="nbstx[3]" />
      <Bit index="2" name="nbstx[2]" />
      <Bit index="1" name="nbstx[1]" />
      <Bit index="0" name="nbstx[0]" />
      <Description>nbstx[5:0] = Number of bytes stored in the TX FIFO - 1</Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold - 1</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold - 1</Description>
    </Register>
    <Register address="7F" name="FIFO Data" size="8" defaultVal="-" isRead="0" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>fifod[7:0] = A write (R/W=’1’) to this address will begin a burst write to the TX FIFO.
  The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.
  To conclude the TX FIFO Write the SEL pin should be brought HIGH.
  A Read (R/W=’0’) to this address will begin a burst read of the RX FIFO, in the same manner.</Description>
    </Register>
    <Register address="00" name="Device Type" size="8" defaultVal="07" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>dt[4:0] = Device Type Code.
This internally hardwired code will allow the user to identify the different devices. Tamara = 00111.</Description>
    </Register>
    <Register address="01" name="Version Code" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>vc[4:0] = Version Code. Internally hardwired version code of the chip</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="X" />
      <Bit index="4" name="chiprdy" />
      <Bit index="3" name="lbd" />
      <Bit index="2" name="lockdet" />
      <Bit index="1" name="cps" />
      <Bit index="0" name="-" />
      <Description>chiprdy = Chip Ready (XTAL) status. When leaving Sleep mode time is needed to stabilize the internal analog circuitry.
  When chiprdy = ’1’ the chip is ready (oscillator is ON) and can be commanded to either RX or TX modes.
  When chiprdy = ‘0’ more time is needed for the chip to stabilize.
lbd = Low Battery Detect status.
  When this bit is ‘1’ the battery voltage is lower than the programmed battery threshold.
lockdet = Synthesizer Lock Detect status. 
cps = Chip Power State:
  0 – Idle State
  1 – TX State</Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="itxffovfl" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="-" />
      <Bit index="0" name="-" />
      <Description>When any of the following bits change state the control block will notify the microcontroller by setting the nIRQ pin LOW = ’0’
if it is enabled in the Interrupt Mask 1 register. The nIRQ pin will remain low until the microcontroller reads this address,
then it will be set until the next change.
itxffovfl = TX FIFO Overflow. When set to ‘1’ the TX FIFO has overflowed and needs to be cleared and reloaded.
itxffafull = TX FIFO Almost Full. When set to ‘1’ the TX FIFO has met its almost full threshold and needs to be transmitted.
itxffaem = TX FIFO Almost Empty. When set to ‘1’ the TX FIFO is almost empty and needs to be filled.
ipksent = Packet Sent. When set to ’1’ a valid packet has been transmitted.</Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>When any of the following bits change state the control block will notify the microcontroller by setting the nIRQ pin LOW = ’0’
if it is enabled in the Interrupt Mask 1 register. The nIRQ pin will remain low until the microcontroller reads this address,
then it will be set until the next change.
iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.  
ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1.
  This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.</Description>
    </Register>
    <Register address="05" name="Interrupt Mask 1" size="8" defaultVal="E4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="mtxffovfl" />
      <Bit index="6" name="mtxffafull" />
      <Bit index="5" name="mtxffaem" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="mpksent" />
      <Bit index="1" name="-" />
      <Bit index="0" name="-" />
      <Description>mffovfl = Mask FIFO Overflow. When set to ‘1’ the FIFO Overflow interrupt will be enabled.
mtxffafull = Mask TX FIFO Almost Full. When set to ‘1’ the TX FIFO Almost Full interrupt will be enabled.
mtxffaem= Mask TX FIFO Almost Empty. When set to ‘1’ the TX FIFO Almost Empty interrupt will be enabled.
mpksent = Mask Packet Sent. When ipksent =’1’ the Packet Sense Interrupt will be enabled.</Description>
    </Register>
    <Register address="06" name="Interrupt Mask 2" size="8" defaultVal="0F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="mwut" />
      <Bit index="2" name="mlbd" />
      <Bit index="1" name="mchiprdy" />
      <Bit index="0" name="mpor" />
      <Description>mwut = Mask Wake-Up Timer. When set to ‘1’ the Wake-Up Timer  interrupt will be enabled.
mlbd = Mask Low Battery Detect. When set to ‘1’ the Low Battery Detect interrupt will be enabled.
mchiprdy= Mask Chip Ready (XTAL). When set to ‘1’ the Chip Ready interrupt will be enabled.
mpor = Mask POR.  When set to ‘1’ the POR interrupt will be enabled.</Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enlbd" />
      <Bit index="6" name="enwt" />
      <Bit index="5" name="x32ksel" />
      <Bit index="4" name="ents" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="-" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>enlbd = Enable Low Battery Detect.
  When this bit is set to ‘1’ the Low Battery Detector circuit and threshold comparison will be enabled.  
enwt = Enable Wake-Up-Timer.  Wake-Up-Timer will be enabled when enwt = ’1’.
  If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
x32ksel = 32,768 kHz crystal oscillator select.
  The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
ents = Temperature Sensor enable
txon = TX on in manual transmit mode.
pllon = TUNE Mode (PLL is ON). When pllon = ’1’ the PLL will remain enabled in Idle State.
  This will for faster turn-around time at the cost of increased current consumption in Idle State.  
xton = READY Mode (Xtal is ON).</Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="ffidle" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="txretran" />
      <Bit index="1" name="-" />
      <Bit index="0" name="ffclrtx" />
      <Description>swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state,
  without the need for sequentially writing to each individual register.
  The RESET is accomplished by setting swres = ‘1’.  This bit will be automatically cleared.  
ffidle = FIFO IDLE.
  If this bit is set and the chip is selected to use FIFO Mode (modsrc[1:0]) it will automatically return the chip to Idle State when the TX FIFO is empty.
autotx = Automatic Transmission. 
  When autotx = ‘1’ the transceiver will enter automatically TX State when the FIFO is almost full.
  When the FIFO is empty it will automatically return to the Idle State.  
txretran = TX Retransmission. This bit enables a one time retransmission of a TX packet without having to reload the FIFO.
  This bit is cleared automatically after the packet has been retransmitted.
ffclrtx = TX FIFO Clear.  Setting ffclrtx=’1’ will clear the contents of the TX FIFO.</Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xlc[7]" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>xlc[7:0] = Tuning Capacitance for the 30MHz XTAL</Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="0B" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>clkt[1:0] = Clock Tail.  If enlfc = ‘0’ then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.
  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
    00 –  0 cycle
    01 –  128 cycles
    10 –  256 cycles
    11 –  512 cycles 
enlfc = Enable Low Frequency Clock.
  When enlfc = ‘1’ and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.
  For example if mclk[2:0] = ‘000’, 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.
  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
mclk[2:0] = Microcontroller Clock.
  Different clock frequencies may be selected for configurable GPIO clock output.
  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.
  The mclk[2:0] setting is only valid when xton = ‘1’ except the ‘111’.  
    000 –  30 MHz
    001 –  15 MHz
    010 –  10 MHz
    011 –  4 MHz
    100 –  3 MHz
    101 –  2 MHz
    110 –  1 MHz
    111 – 32.768 kHz</Description>
    </Register>
    <Register address="3E" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="0B" name="GPIO Configuration 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="gpio1[3]" />
      <Bit index="6" name="gpio1[2]" />
      <Bit index="5" name="gpio1[1]" />
      <Bit index="4" name="gpio1[0]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>gpio1[3:0] = GPIO1 pin function select:
  0000 – Power-On-Reset (output)
  0001 – External Retransmission Request (input) – not implemented
  0010 – TX FIFO Almost Full  (output)
  0011 – GND
  0100 – Wake-Up Timer: ’1’ when WUT has expired  (output)
  0101 – Low Battery Detect: ’1’ when Battery is below threshold setting (output)
  0110 – direct input
  0111 – direct output
  1000 – TX State  (output)
  1001 – GND
  1010 – GND
  1011 – TX Data CLK output to be used in conjunction with TR Data pin (output)
  1100 – GND
  1101 – TX Data input for direct modulation (input)
  1110 – GND
  1111 – Digital Test Bus (output)
gpio0[3:0] = GPIO0 pin function select:
  0000 – Power-On-Reset Inverted
  0001 – External Retransmission Request (input) – not implemented 
  0010 – TX FIFO Almost Full  (output)
  0011 – GND
  0100 – Wake-Up Timer: ’1’ when WUT has expired  (output)
  0101 – Low Battery Detect: ’1’ when Battery is below threshold setting (output)
  0110 – direct input
  0111 – direct output
  1000 – TX State  (output)
  1001 – GND
  1010 – GND
  1011 – TX Data CLK output to be used in conjunction with TR Data pin (output)
  1100 – GND
  1101 – TX Data input for direct modulation (input)
  1110 – GND
  1111 – Digital Test Bus (output)</Description>
    </Register>
    <Register address="0C" name="GPIO Configuration 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="dio[2]" />
      <Bit index="5" name="dio[1]" />
      <Bit index="4" name="dio[0]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>dio[2:0] = Direct I/O for GPIO2, GPIO1 and GPIO0 respectively.
 These bits control the GPIO pins if the direct output option is selected.
 If the GPIO is direct input then the value of the pin can be read here.
gpio2[3:0] = GPIO2 pin function select:
  0000 – Microcontroller CLK Output 
  0001 – External Retransmission Request (input) – not implemented
  0010 – TX FIFO Almost Full  (output)
  0011 – GND
  0100 – Wake-Up Timer: ’1’ when WUT has expired  (output)
  0101 – Low Battery Detect: ’1’ when Battery is below threshold setting (output)
  0110 – direct input
  0111 – direct output
  1000 – TX State  (output)
  1001 – GND
  1010 – GND
  1011 – TX Data CLK output to be used in conjunction with TR Data pin (output)
  1100 – GND
  1101 – TX Data input for direct modulation (input)
  1110 – GND
  1111 – Digital Test Bus (output)</Description>
    </Register>
    <Register address="0D" name="Wake-Up Timer Period 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtr[3]" />
      <Bit index="6" name="wtr[2]" />
      <Bit index="5" name="wtr[1]" />
      <Bit index="4" name="wtr[0]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>The period of the wake-up timer can be calculated as TWUT = (32 * M * 2R) / 32.768 [ms]
wtr[3:0] = Wake Up Timer R value.  See formula above.
wtm[11:8] = Wake Up Timer M value.  See formula above.</Description>
    </Register>
    <Register address="0E" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>The period of the wake-up timer can be calculated as TWUT = (32 * M * 2R) / 32.768 [ms]
wtm[7:0] = Wake Up Timer M value.  See formula above.</Description>
    </Register>
    <Register address="10" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>The threshold can be calculated as LB_TH = ( 1.675 + lbdt * 50 mV ) +/- 25 mV
lbdt[4:0] = Low Battery Detector Threshold.  This threshold is compared to Battery Voltage Level.
If the Battery Voltage is less than the threshold the Low Battery Interrupt is set.</Description>
    </Register>
    <Register address="11" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>1.7V + vbat * 50 mV
vbat[4:0] = Battery Voltage Level.
The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1s.</Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="0D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>enpactx = Enable Packet TX Handling.  If FIFO Mode (modsrc=’10’) is being used automatic packet handling may be enabled.
  Setting enpactx=’1’ will enable automatic packet handling in the TX path.
  Register 30-4D allow for various configurations of the packet structure.
  Setting enpactx=’0’ will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
  encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
crc[1:0] = CRC polynomial selection.
  00 – CCITT
  01 – CRC-16
  10 – IEC-16
  11 – Biacheva</Description>
    </Register>
    <Register address="31" name="Header Control 1" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhdlen[2]" />
      <Bit index="6" name="txhdlen[1]" />
      <Bit index="5" name="txhdlen[0]" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="-" />
      <Bit index="1" name="-" />
      <Bit index="0" name="-" />
      <Description>txhdlen[2:0] = Transmit Header Length.
  Length of header used if packet handler is enabled for TX (enpactx). Headers are transmitted in descending order.  
  000 – No TX header
  001 –  Header 3
  010 –  Header 3 and 2
  011 –  Header 3 and 2 and 1
  100 –  Header 3 and 2 and 1 and 0</Description>
    </Register>
    <Register address="32" name="Header Control 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="X" />
      <Bit index="2" name="fixpklen" />
      <Bit index="1" name="synclen[1]" />
      <Bit index="0" name="synclen[0]" />
      <Description>fixpklen = Fix Transmit Packet Length.
  When fixpklen = ‘1’ the packet length (pklen[7:0]) is not included in the header.
  When fixpklen = ‘0’ the packet length is included in the header.
synclen[1:0] = Synchronization Word Length.
  The value in this register corresponds to the number of bytes used in the Synchronization Word.
  The synchronization word bytes are transmitted in descending order.
    00 –  Synchronization Word 3 
    01 –  Synchronization Word 3 and 2
    10 –  Synchronization Word 3 and 2 and 1
    11 –  Synchronization Word 3 and 2 and 1 and 0</Description>
    </Register>
    <Register address="36" name="Preamble Length" size="8" defaultVal="07" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.
The value in the prealen[7:0] register corresponds to the number of nibbles (4bits) in the packet Length.
For example prealen[7:0] = ‘00000111’  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.
The maximum preamble length is prealen[7:0] = ‘11111110’ which corresponds to a 127 Byte Preamble.</Description>
    </Register>
    <Register address="37" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3F" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] – Packet Length.
The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.
For example pklen[7:0] = ‘00001000’ corresponds to a packet length of 9 Bytes.
The maximum packet length is pklen[7:0] = ‘11111111’, a 256 byte packet.</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="atbcon" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>atbcon = Analog Test Bus Connection to GPIO1 &amp; 2 enable
atb[3:0] = Analog Test Bus.
  The selection of internal analog testpoints that are muxed onto TESTp and TESTn. See section XX and Table XX for more details.</Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>dtb[4:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output</Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="4A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>txmod[2:0] = TX Modulation Delay.
 The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up.
  It can be set from 0 us to 28 us in 4 us steps.
ldoramp[1:0] = TX LDO Ramp Time.
  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
  00 – 5 us
  01 – 10 us
  10 – 15 us
  11 – 20 us
txramp[1:0] = TX ramp Time.
  The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up. 
  00 –  5 us
  01 –  10 us
  10 –  15 us
  11 –  20 us</Description>
    </Register>
    <Register address="53" name="PLL Tune Time 1" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="pllt0[4]" />
      <Bit index="3" name="pllt0[3]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>The total settling time (cold start) of the PLL after the calibration can be calculated as TCS = TS + TO.
pllt0 = PLL Settling Time (TO). This register will set the time allowed for PLL settling after the calibrations are completed.
The value is configurable between 0 µs and 310 µs, in 10 µs steps. The default pllt0 corresponds to 160 µs. See fomula above.</Description>
    </Register>
    <Register address="54" name="PLL Tune Time 2" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="pllts[4]" />
      <Bit index="3" name="pllts[3]" />
      <Bit index="2" name="pllts[2]" />
      <Bit index="1" name="pllts[1]" />
      <Bit index="0" name="pllts[0]" />
      <Description>The total settling time (cold start) of the PLL after the calibration can be calculated as TCS = TS + TO.
pllts[4:0] = PLL Soft Settling Time (TS).
 This register will set the settling time for the PLL from a previous locked frequency in Tune mode.
The value is configurable between 0 µs and 310 µs, in 10 µs intervals. The default plltime  corresponds to 80 µs.
See formula above.</Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="bgstartup" />
      <Bit index="3" name="enrcfcal" />
      <Bit index="2" name="rccal" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>bgstartup = BG Startup  
enrcfcal = RC Oscillator Fine Calibration enable.
  If this bit is set to ‘1’ then the RC oscillator performs fine calibration in every app. 30 s.
rccal = RC Calibration Force.
  If setting rccal=’1’ will automatically perform a forced calibration of the 32kHz RC Oscillator.
  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state.
  The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration.
  Setting this signal from a ‘0’ to ‘1’ will initiate the calibration.
vcocal = VCO Calibration Force.
  If in Idle Mode and pllon=’1’, setting vcocal=’1’ will force a one time calibration of the synthesizer VCO.
skipvco = Skip VCO Calibration.
  Setting skipvco=’1’ will skip the VCO calibration when going from the Idle state to the TX or RX state.</Description>
    </Register>
    <Register address="56" name="Modulator Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="-" />
      <Description>refclksel = Modulator Reference Clock Source Selection (1: 10MHz, 0: PLL)
refclkinv = Modulator Reference Clock Inversion enable</Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>cpforceup = Charge Pump Force Up
cpforcedn = Charge Pump Force Down
cdconly = Charge Pump DC Offset Only
cdcurr[2:0] = Charge Pump DC Current selection</Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="X" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>cpcurr[1:0] = Charge Pump Current (Gain Setting).
  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
cpcorr[4:0] = Charge Pump Correction value</Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
d3trim[1:0] = Divider 3 Current Trim value
d2trim[1:0] = Divider 2 Current Trim value
d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value</Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>vcocorrov = VCO Current Correction override
vcocorr[3:0] = VCO Current Correction value
vcocur[1:0] = VCO Current Trim value</Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="vcdone" />
      <Bit index="5" name="vcocalov" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>vcdone = VCO Calibration Done
vcocalov = VCO Calibration Override.
  When vcocalov=’0’ the internal VCO Calibration results may be viewed by reading the vcocal register.
  When vcocalov=’1’ the VCO results may be overridden externally through the SPI by writing to the vcocal register.
vcocal[4:0] = VCO Calibration Results</Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>dsmod = Delta-Sigma Modulus
  0 – 64 000 1 – 65 536
dsorder[1:0] = Delta-Sigma Order
  00 –  0 order
  01 –  1st order
  10 –  2nd order
  11 –  Mash 111
dsrstmode = Delta-Sigma Reset Mode
dsrst = Delta-Sigma Reset</Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>enpa = Power Amplifier enable override
enbf5 = Buffer 5 enable override
endv32 = Divider 3_2 enable override
enbf12 = Buffer 1_2 enable override
enmx2 = Multiplexer 2 enable override</Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="enldet" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="enmx1" />
      <Description>ends = Delta-Sigma enable override
enldet = Lock Detect enable (direct control, not override!)
enmx3 = Mutiplexer 3 enable override
enbf4 = Buffer 4 enable override
enbf3 = Buffer 3 enable override
enbf11 = Buffer 1_1 enable override
enbf2 = Buffer 2 enable override
enmx1 = Multiplexer enable override</Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="X" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>enfrdv = Fractional Divider enable override
endv31 = Divider 3_1 enable override
endv2 = Divider 2 enable override
endv1p5 = Divider 1.5 (div-by-1.5) enable override
envco = VCO enable override
encp = Charge Pump enable override
enbg = Bandgap enable override</Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="enspor" />
      <Bit index="3" name="lpmode" />
      <Bit index="2" name="enbias2x" />
      <Bit index="1" name="enamp2x" />
      <Bit index="0" name="enbuf" />
      <Description>pwst[1:0] = internal power states of the chip
  00 – low power (stand-by / sleep / sensor)
  01 – ready
  10 – tune
  11 – TX 
enspor = power-on-reset smart mode enable (sensitive)
lpmode = crystal oscillator low power mode enable
enbias2x = 2 times higher bias current enable
enamp2x = 2 times higher amplification enable
enbuf = output buffer enable</Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>rccov = RC Oscillator Coarse Calibration Override.
  When rccov=’0’ the internal Coarse Calibration results may be viewed by reading the rcccal register.
  When rccov=’1’ the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>rcfov = RC Oscillator Fine Calibration Override.
  When rcfov=’0’ the internal Fine Calibration results may be viewed by reading the rcfcal register.
  When rcfov=’1’ the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="enlpldo" />
      <Description>enbias = Bias enable
envcoldo = VCO LDO enable
enrfldo = RF LDO enable
enpllldo = PLL LDO enable
endigldo = Digital LDO enable
enlpldo = Low Power LDO enable</Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="X" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>diglvl[2:0] = Digital LDO voltage level
  000 – 1.2 V
  001 – 1.3 V
  010 – 1.5 V
  011 – 1.7 V
  1XX – 1.8 V</Description>
    </Register>
    <Register address="67" name="Temperature Sensor Calibration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entscal" />
      <Bit index="3" name="tsc[3]" />
      <Bit index="2" name="tsc[2]" />
      <Bit index="1" name="tsc[1]" />
      <Bit index="0" name="tsc[0]" />
      <Description>entsoffs = Temperature Sensor Offset enable
entscal = Temperature Sensor Calibration enable
tscal[3:0] = Temperature Sensor Calibration value</Description>
    </Register>
    <Register address="68" name="Datapath Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="-" />
      <Bit index="1" name="dptst[1]" />
      <Bit index="0" name="dptst[0]" />
      <Description>dptst[1:0] = Datapath Test bits</Description>
    </Register>
    <Register address="69" name="VCO Capacitance Bank Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="vcba[4]" />
      <Bit index="3" name="vcba[3]" />
      <Bit index="2" name="vcba[2]" />
      <Bit index="1" name="vcba[1]" />
      <Bit index="0" name="vcba[0]" />
      <Description>vcba[4:0] = VCO Capacitance Bank Look-up Table Address.</Description>
    </Register>
    <Register address="6A" name="VCO Capacitance Bank Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="vcbv [6]" />
      <Bit index="5" name="vcbv [5]" />
      <Bit index="4" name="vcbv [4]" />
      <Bit index="3" name="vcbv[3]" />
      <Bit index="2" name="vcbv[2]" />
      <Bit index="1" name="vcbv[1]" />
      <Bit index="0" name="vcbv[0]" />
      <Description>vcbv[7:0] = VCO Capacitance Bank Value in the look-up table addressed by the vcba[3:0].</Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="X" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.
  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.   
  000 –  i_coe0 (Default =d1)
  001 –  i_coe1 (Default =d3)
  010 –  i_coe2 (Default =d6)
  011 –  i_coe3 (Default =d10)
  100 –  i_coe4 (Default =d15)
  101 –  i_coe5 (Default =d19)
  110 –  i_coe6 (Default =d20)</Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="07" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>txpow[2:0] = TX Output Power.
The output power is configurable from +13 to -8dBm in ~3dB steps.
txpow[2:0]=’111’ corresponds to +13dBm and ‘000’ to -8dBm.</Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>The data rate can be calculated as TX_DR = 103 * txdr[15:0] / 216 [kbit/s]
txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="AA" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>The data rate can be calculated as TX_DR = 103 * txdr[15:0] / 216 [kbit/s]
txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="10" type="Si4432" revision="Y" projectID="P840" name="ARA">
    <TxPufferSize>32</TxPufferSize>
    <RxPufferSize>32</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        RESERVED A&gt;B
        dt[4:0] = Device Type Code.  This internally hardwired code will allow the user to recognize whether this is a Transmitter, Receiver, or a Transceiver.  Ara = 01000.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="01" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>
        RESERVED B&lt;A
        vc[4:0] = Version Code.  Internally hardwired version code of the chip
      </Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="lockdet" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>
        ffovfl = RX/TX FIFO Overflow status.
        ffunfl = RX/TX FIFO Underflow status.
        rxffem = RX FIFO Empty status.
        headerr = Header Error status. The actual received packet has a header check error.
        freqerr = Frequency Error status. The programmed frequency is outside of the operating range. The actual frequency is saturated to the max/min value.
        lockdet = Synthesizer Lock Detect status.
        cps[1:0] = Chip Power State:
        00 -	Idle State
        01 -	RX State
        10 -	TX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>
        ifferr = FIFO Underflow/Overflow Error.  When set to '1' the TX or RX FIFO has overflowed or underflowed.
        itxffafull = TX FIFO Almost Full.  When set to '1' the TX FIFO has met its almost full threshold and needs to be transmitted.
        itxffaem= TX FIFO Almost Empty.  When set to '1' the TX FIFO is almost empty and needs to be filled.
        irxffafull = RX FIFO Almost Full.  When set to '1' the RX FIFO has met its almost full threshold and needs to be read by the microcontroller
        iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        ipksent = Packet Sent Interrupt. When set to'1' a valid packet has been transmitted.
        ipkvalid =  Valid Packet Received. When set to '1' a valid packet has been received.
        icrcerror = CRC Error. When set to '1' the cyclic redundancy check is failed.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
        ipreaval = Valid Preamble Detected. When a preamble is detected this bit will be set to 1.
        ipreainval = Invalid Preamble Detected. When the preamble detection is failed this bit will be set to 1.
        irssi = RSSI. When RSSI level exceeds the programmed thershold this bit will be set to 1.
        iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.
        ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
        ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>
        enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
        entxffafull = Enable TX FIFO Almost Full. When set to '1' the TX FIFO Almost Full interrupt will be enabled.
        entxffaem = Enable TX FIFO Almost Empty. When set to '1' the TX FIFO Almost Empty interrupt will be enabled.
        enrxffafull = Enable RX FIFO Almost Full. When set to '1' the RX FIFO Almost Full interrupt will be enabled.
        enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
        enpksent = Enable Packet Sent. When ipksent ='1' the Packet Sense Interrupt will be enabled.
        enpkvalid = Enable Valid Packet Received. When ipkvalid = '1' the Valid Packet Received Interrupt will be  enabled
        encrcerror = Enable CRC Error. When set to '1' the CRC Error  interrupt will be enabled.
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        enswdet = Enable Sync Word Detected. When mpreadet ='1' the Preamble Detected Interrupt will be enabled.
        enpreaval = Enable Valid Preamble Detected. When mpreadet ='1' the Valid Preamble Detected Interrupt will be enabled.
        enpreainval = Enable Invalid Preamble Detected. When mpreadet ='1' the Invalid Preamble Detected Interrupt will be enabled.
        enrssi = Enable RSSI. When set to '1' the RSSI Interrupt will be  enabled.
        enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
        enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
        enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
        enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.
        enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.
        enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
        txon = TX on in manual transmit mode. It is cleared in FIFO mode if the packet sent.
        rxon = RX on in manual receiver mode. It is cleared if rxidle bit is set and a valid packet received.
        pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        xton = READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="ffclrtx" />
      <Description>
        antdiv[2:0] = Enable Antenna Diversity. The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
        RX/TX state	non RX/TX state
        GPIO Ant1	GPIO Ant2	GPIO Ant1	GPIO Ant2
        000 - 	1	0	0	0
        001 -	0	1	0	0
        010 - 	1	0	1	1
        011 -	0	1	1	1
        100 -	antenna diversity algorythm	0	0
        101 - 	antenna diversity algorythm	1	1
        110 -	ant. div. algorythm in beacon mode	0	0
        111 - 	ant. div. algorythm in beacon mode 		1	1
        rxmpk = RX Multi Packet. When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the transceiver will automatically leaves the RX State after the first valid packet has been received.
        autotx = Automatic Transmission. When autotx = '1' the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.
        enldm = Enable Low Duty Cycle Mode. If this bit is set to '1' then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
        ffclrrx = RX FIFO Clear. Setting ffclrrx='1' will clear the contents of the RX FIFO.
        ffclrtx = TX FIFO Clear. Setting ffclrtx='1' will clear the contents of the TX FIFO.
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>
        RESERVED
        xlc[6:0] = Tuning Capacitance for the 30MHz XTAL
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        RESERVED
        clkt[1:0] = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00 - 	0 cycle
        01 - 	128 cycles
        10 - 	256 cycles
        11 - 	512 cycles
        enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = '1' except the '111'.
        000 - 	30 MHz
        001 - 	15 MHz
        010 - 	10 MHz
        011 - 	4 MHz
        100 - 	3 MHz
        101 - 	2 MHz
        110 - 	1 MHz
        111 -	32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        RESERVED
        pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio1[4:0] = GPIO0pin function select:
        00000 - 	Power-On-Reset (output)
        00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - 	Direct Digital Input
        00100 -	External Interrupt, falling edge (input)
        00101 - 	External Interrupt, rising edge (input)
        00110 - 	External Interrupt, state change (input)
        00111 -	ADC Analog Input
        01000 -	Reserved (Analog Test N Intput)
        01001 -	Reserved (Analog Test P Intput)
        01010 -	Direct Digital Output
        01011 -	Reserved (Digital Test Output)
        01100 -	Reserved (Analog Test N Output)
        01101 -	Reserved (Analog Test P Output)
        01110 -	Reference Voltage (output)
        01111 -	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000 -	TX Data input for direct modulation (input)
        10001 -	External Retransmission Request (input)
        10010 -	TX State (output)
        10011 -	TX FIFO Almost Full  (output)
        10100 -	RX Data (output)
        10101 -	RX State (output)
        10110 -	RX FIFO Almost Full  (output)
        10111 -	Antenna 1 Switch used for antenna diversity  (output)
        11000 -	Antenna 2 Switch used for antenna diversity  (output)
        11001 -	Valid Preamble Detected  (output)
        11010 -	Invalid Preamble Detected  (output)
        11011 -	Sync Word Detected  (output)
        11100 -	Clear Channel Assessement  (output)
        11101 -	VDD
        else    -	GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        RESERVED
        pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio1[4:0] = GPIO1 pin function select:
        00000 - 	Power-On-Reset Inverted (output)
        00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - 	Direct Digital Input
        00100 -	External Interrupt, falling edge (input)
        00101 - 	External Interrupt, rising edge (input)
        00110 - 	External Interrupt, state change (input)
        00111 -	ADC Analog Input
        01000 -	Reserved (Analog Test N Intput)
        01001 -	Reserved (Analog Test P Intput)
        01010 -	Direct Digital Output
        01011 -	Reserved (Digital Test Output)
        01100 -	Reserved (Analog Test N Output)
        01101 -	Reserved (Analog Test P Output)
        01110 -	Reference Voltage (output)
        01111 -	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000 -	TX Data input for direct modulation (input)
        10001 -	External Retransmission Request (input)
        10010 -	TX State (output)
        10011 -	TX FIFO Almost Full  (output)
        10100 -	RX Data (output)
        10101 -	RX State (output)
        10110 -	RX FIFO Almost Full  (output)
        10111 -	Antenna 1 Switch used for antenna diversity  (output)
        11000 -	Antenna 2 Switch used for antenna diversity  (output)
        11001 -	Valid Preamble Detected  (output)
        11010 -	Invalid Preamble Detected  (output)
        11011 -	Sync Word Detected  (output)
        11100 -	Clear Channel Assessement  (output)
        11101 -	VDD
        else    -	GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        RESERVED
        pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio2[4:0] = GPIO2 pin function select:
        00000 - Microcontroller Clock (output)
        00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - 	Direct Digital Input
        00100 -	External Interrupt, falling edge (input)
        00101 - 	External Interrupt, rising edge (input)
        00110 - 	External Interrupt, state change (input)
        00111 -	ADC Analog Input
        01000 -	Reserved (Analog Test N Intput)
        01001 -	Reserved (Analog Test P Intput)
        01010 -	Direct Digital Output
        01011 -	Reserved (Digital Test Output)
        01100 -	Reserved (Analog Test N Output)
        01101 -	Reserved (Analog Test P Output)
        01110 -	Reference Voltage (output)
        01111 -	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000 -	TX Data input for direct modulation (input)
        10001 -	External Retransmission Request (input)
        10010 -	TX State (output)
        10011 -	TX FIFO Almost Full  (output)
        10100 -	RX Data (output)
        10101 -	RX State (output)
        10110 -	RX FIFO Almost Full  (output)
        10111 -	Antenna 1 Switch used for antenna diversity  (output)
        11000 -	Antenna 2 Switch used for antenna diversity  (output)
        11001 -	Valid Preamble Detected  (output)
        11010 -	Invalid Preamble Detected  (output)
        11011 -	Sync Word Detected  (output)
        11100 -	Clear Channel Assessement  (output)
        11101 -	VDD
        else    -	GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        RESERVED
        extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart / adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        adcstart / adcdone = ADC Measurement Start bit. Reading this bit gives '1' if the ADC measurement cycle has been finished.
        adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
        000 -	Internal Temperature Sensor
        001 -	GPIO0, single-ended
        010 -	GPIO1, single-ended
        011 - 	GPIO2, single-ended
        100 -	GPIO0(+) - GPIO1(-), differential
        101 -	GPIO1(+) - GPIO2(-), differential
        110 -	GPIO0(+) - GPIO2(-), differential
        111 -	GND
        adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
        0X -	bandgap voltage (1.2V)
        10 -	VDD / 3
        11 - 	VDD / 2
        adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0:	adcref[0] = 1:
        FS = 0.014 * (adcgain[1:0] + 1) * VDD 	FS = 0.021 * (adcgain[1:0] + 1) * VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>
        RESERVED
        adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.
      </Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>
        tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
        00 -	-40oC .. 64oC (full operating range), with 0.5oC resolution (1 LSB in the 8 bit ADC)
        01 -	-40oC .. 85oC, with 1oC resolution (1 LSB in the 8 bit ADC)
        11 -	   0oC .. 85oC, with 0.5oC resolution (1 LSB in the 8 bit ADC)
        10 -	-40oF .. 216oF, with 1oF resolution (1 LSB in the 8 bit ADC)
        entsoffs = Temperature Sensor Offset to convert from K to oC.
        entstrim = Temperature Sensor Trim enable
        tstrim[3:0] = Temperature Sensor Trim value
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)</Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="wtr[3]" />
      <Bit index="4" name="wtr[2]" />
      <Bit index="3" name="wtr[1]" />
      <Bit index="2" name="wtr[0]" />
      <Bit index="1" name="wtd[1]" />
      <Bit index="0" name="wtd[0]" />
      <Description>
        RESERVED
        wtr[3:0] = Wake Up Timer Exponent (R) value.  See formula above.
        wtd[1:0] = Wake Up Timer Exponent (D) value.  See formula above.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>wtm[15:8] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>wtm[7:0] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>wtm[15:8] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>wtm[7:0] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>ldc[7:0] = Low-Duty Cycle Mode Duration (LDC).  See formula above</Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>
        RESERVED
        lbdt[4:0] = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.
      </Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        RESERVED
        vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continouosly.
      </Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="16" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>
        RESERVED
        ndec_exp[2:0] = IF Filter decimation rates
        filset[3:0] = IF Filter coefficient sets ; defauts are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz
      </Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="41" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="afcgearl[2]" />
      <Bit index="1" name="afcgearl[1]" />
      <Bit index="0" name="afcgearl[0]" />
      <Description>
        RESERVED
        enafc = AFC enable
        afcgearh[2:0] = AFC High Gear Setting
        afcgearl[2:0] = AFC Low Gear Setting
      </Description>
    </Register>
    <Register address="1E" name="AFC Timing Control" size="8" defaultVal="1C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="lgwait[2]" />
      <Bit index="1" name="lgwait[1]" />
      <Bit index="0" name="lgwait[0]" />
      <Description>
        RESERVED
        shwait[2:0] = short wait periods after AFC correction used before preamble is detected  (unit is 2*Tbit)
        lgwait[2:0] = long wait periods after correction used after preamble detected  (unit is 2*Tbit)
      </Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="13" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="rxready" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>
        RESERVED
        rxready = improves receiver noise immunity when in direct mode. It is recommended to set this bit after preamble is detected. When in FIFO mode this bit should be set to '0' since noise immunity is controlled automatically.
        crfast[2:0] = Clock Recovery Fast Gearshift value
        crslow[2:0] = Clock Recovery Slow Gearshift value
      </Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="30" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>
        rxosr[7:0] = Oversampling Rate, 3 LSBs are the fraction
        default = 0011 0000 = 6 clock cycles per data bit
      </Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="X" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>
        rxosr[10:8] = Oversampling Rate, upper bits
        RESERVED
        ncoff[19:16] = NCO offset. See formula above.
      </Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="AA" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>ncoff[15:8] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>ncoff[7:0] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>
        RESERVED
        crgain[10:8] = Clock Recovery Timing Loop Gain
      </Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="53" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>crgain[7:0] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>rssi[7:0] = Received Signal Strength Indicator value</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>rssith[7:0] = RSSI Threshold. Interrupt is set if the RSSI value is above this threshold.</Description>
    </Register>
    <Register address="28" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>adrssi1[7:0] = Measured RSSI value on antenna 1</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description></Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="autophdet" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        enpacrx = Enable Packet RX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpacrx='1' will enable automatic packet handling in the RX path. Register 30-4D allow for various configurations of the packet structure. Setting enpacrx='0' will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
        lsbfrst = LSB First enable. The LSB of the data will be transmitted/received first if this bit is set.
        crcdonly = CRC Data Only enable When this bit is set to '1' the CRC is calculated on and check against the packet data fields only.
        autophdet = Auto Phase Detection enable. Automatic Manchester phase detection during RX if this bit is set.
        enpactx = Enable Packet TX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpactx='1' will enable automatic packet handling in the TX path. Register 30-4D allow for various configurations of the packet structure. Setting enpactx='0' will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
        encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
        crc[1:0] = CRC polynomial selection.
        00 -	CCITT
        01 -	CRC-16
        10 -	IEC-16
        11 -	Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>
        RESERVED
        pksrch = Packet Searching. When pksrch = '1' the radio is searching for a valid packet.
        pkrx = Packet Receiving. When pkrx = '1' the radio is currently receiving a valid packet.
        pkvalid = Valid Packet Received. When a pkvalid = '1' a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
        crcerror = CRC Error.  When crcerror = '1' a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
        pktx = Packet Transmitting. When pktx = '1' the radio is currently transmitting a packet.
        pksent = Packet Sent.  A pksent  = '1' a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enbcast[1]" />
      <Bit index="6" name="enbcast[1]" />
      <Bit index="5" name="enbcast[1]" />
      <Bit index="4" name="enbcast[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>
        bcen[3:0] = Broadcast Address (FFh) Check enable.  If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
        0000 -	No broadcast address enable.
        0001 -	Broadcast address enable for header byte 0.
        0010 -	Broadcast address enable for header byte 1.
        0011 -	Broadcast address enable for header bytes 0 &amp; 1.
        0100 -	...
        hdch[3:0] = Received Header bytes to be checked against the Check Header bytes.  One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.
        0000 -	No Received Header check
        0001 -	Received Header check for byte 0.
        0010 -	Received Header check for bytes 1.
        0011 -	Received header check for bytes 0 &amp; 1.
        0100 -	...
      </Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="txhdlen[2]" />
      <Bit index="5" name="txhdlen[1]" />
      <Bit index="4" name="txhdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        RESERVED
        txhdlen[2:0] = Transmit Header Length. Length of header used if packet handler is enabled for TX (enpactx). Headers are transmitted in descending order.
        000 -	NoTX header
        001 - 	Header 3
        010 - 	Header 3 and 2
        011 - 	Header 3 and 2 and 1
        100 - 	Header 3 and 2 and 1 and 0synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00 - 	Synchronization Word 3
        01 - 	Synchronization Word 3 and 2
        10 - 	Synchronization Word 3 and 2 and 1
        11 - 	Synchronization Word 3 and 2 and 1 and 0
        fixpklen = Fix Transmit Packet Length.  When fixpklen = '1' the packet length (pklen[7:0]) is not included in the header and no packet length check is performed. When fixpklen = '0' the packet length is included in the header.
        prealen[8] = MSB of Preamble Length. See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="07" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register + 1 corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = '000000111'  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = '111111111' which corresponds to a 256 Bytes  Preamble.</Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="preach[2]" />
      <Bit index="1" name="preach[1]" />
      <Bit index="0" name="preach[0]" />
      <Description>
        preath[4:0] = Number of nibbles processed during detection.
        preach[2:0] = Number of non-consecutive bit errors allowed during detection.
      </Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] - Packet Length.  The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = '00001000' corresponds to a packet length of 9 Bytes.  The maximum packet length is pklen[7:0] = '11111111', a 256 byte packet.</Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>chhd[31:24] = Check Header 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>chhd[23:16] = Check Header 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>chhd[15:8] = Check Header 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>chhd[7:0] = Check Header 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>hden[31:24] = Header Enable 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>hden[23:16] = Header Enable 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>hden[15:8] = Header Enable 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>hden[7:0] = Header Enable 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>rxhd[31:24] = Received Header 3. 4th byte of the received header.</Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>rxhd[23:16] = Received Header 2. 3rd byte of the received header.</Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>rxhd[15:8] = Received Header 1. 2nd byte of the received header.</Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>rxhd[7:0] = Received Header  0. 1st byte of the received header.</Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>rxplen[7:0] = Length byte of the received header.</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>
        RESERVED
        atb[4:0] = Analog Test Bus.  The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
        Internal analog signals available on the Analog Test Bus:
        atb[4:0]
        GPIOx
        GPIOx
        1
        MixIp
        MixIn
        2
        MixQp
        MixQn
        3
        PGA_Ip
        PGA_In
        4
        PGA_QP
        PGA_Qn
        5
        ADC_vcm
        ADC_vcmb
        6
        ADC_ipoly10u
        ADC_ref
        7
        ADC_Refdac_p
        ADC_Refdac_n
        8
        ADC_ipoly10
        ADC_ipoly10
        9
        ADC_Res1Ip
        ADC_Res1In
        10
        ADC_Res1Qp
        ADC_Res1Qn
        11
        spare
        spare
        12
        spare
        spare
        13
        spare
        spare
        14
        spare
        spare
        15
        spare
        spare
        16
        spare
        spare
        17
        spare
        spare
        18
        ICP_Test
        PLL_IBG_05
        19
        PLL_VBG
        VSS_VCO
        20
        Vctrl_Test
        PLL_IPTAT_05
        21
        PA_vbias
        spare
        22
        DIGBG
        DIGVFB
        23
        IFBG
        IFVFB
        24
        PLLBG
        PLLVReg
        25
        IBias10u
        IBias5u
        26
        32KRC_Ucap
        32KRC_Ures
        27
        ADC8_VIN
        ADC8_VDAC
        28
        LBDcomp
        LBDcompref
        29
        TSBG
        TSVtemp
        30
        RFBG
        RFVREG
        31
        VCOBG
        VCOVREG
      </Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>
        RESERVED
        ensctest = Scan Test Enable. When set to '1' then GPIO0 will be the ScanEn input.
        dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
        Internal digital signals available on the Digital Test Bus:
        dtb[4:0]
        GPIO0
        Signal
        GPIO1
        Signal
        GPIO2
        Signal
        0
        wkup_clk_32k
        wake-up 32kHz clock
        rbase_en
        first divided clock
        clk_base
        timebase clock
        1
        wkup_clk_32k
        wake-up 32kHz clock
        wake_up
        wake-up event
        tm1sec
        1 sec timebase
        2
        ts_adc_en
        aux. ADC enable
        adc_rdy_n
        aux. ADC conversion ready
        adc_done
        aux. ADC measurement done
        3
        cont_lbd
        low battery continouos mode
        lbd_on
        low battery ON signal
        lbd
        unfiltered output of LBD
        4
        div_clk_g
        gated divided clock
        uc_clk
        microcontroller clock
        ckout_rcsel
        slow clock selected
        5
        en_div_sync
        clock divider enable (sync'ed)
        en_ckout
        clock out enable
        en_ckout_s
        clock out enable (sync'ed)
        6
        osc30_en
        oscillator enable
        osc30_bias2x
        oscillator bias control
        xok
        chip ready
        7
        xok
        chip ready
        zero_cap
        cap. load zero
        osc30_buff_en
        buffer enable
        8
        tsadc_needed
        aux. ADC enable
        ext_retran
        ext. retransmission request
        tx_mod_gpio
        TX modulation inpit
        9
        gpio_0_oen_n
        GPIO0 output enable
        gpio_0_aen
        GPIO0 analog selection
        gpio_0_aden
        GPIO0 ADC input line enable
        10
        int_ack1
        interrupt acknowledge 1
        int_ack2
        interrupt acknowledge 2
        int_store
        interrupt latch closed
        11
        ext_int2
        ext. interrupt from GPIO2
        irq_bit8
        combined external status
        msk_bit8
        combined masked ext. int.
        12
        sdo_aux_sel
        SDO aux. function select
        sdo_aux
        SDO aux. signal
        nirq_aux_sel
        nIRQ aux. function select
        13
        trdata_on_sdi
        TX/RX data on SDI
        tx_mod
        TX modulation input
        tx_clk_out
        TX clock output
        14
        start_full_sync
        RC osc. full calibration start
        start_fine_sync
        RC osc. fine calibration start
        xtal_req
        crystal req. for RC osc. cal.
        15
        coarse_rdy
        RC osc. coarse cal. ready
        fine_rdy
        RC osc. fine cal. ready
        xtal_req_sync
        sync'ed crystal request
        16
        vco_cal_rst_s_n
        VCO calibration reset
        vco_cal
        VCO calibration is running
        vco_cal_done
        VCO calibration done
        17
        vco_cal_en
        VCO calibration enable
        en_ref_cnt
        reference counter enable
        en_freq_cnt_s
        frequency counter enable
        18
        vco_cal_en
        VCO calibration enable
        pos_diff
        positive difference to goal
        en_freq_cnt_s
        frequency counter enable
        19
        dsm_clk_mux
        DSM multiplexed clock
        pll_fb_clk_tst
        PLL feedback clock
        pll_ref_clk_tst
        PLL reference clock
        20
        dsm[0]
        delta-sigma output
        dsm[1]
        delta-sigma output
        dsm[2]
        delta-sigma output
        21
        dsm[3]
        delta-sigma output
        pll_fbdiv15
        dsm_rst_s_n
        delta-sigma reset
        22
        pll_en
        PLL enable: TUNE state
        pllt0_ok
        PLL initial settling OK
        pllts_ok
        PLL soft settling OK
        23
        ch_freq_req
        frequency change request
        pllts_ok
        PLL soft settling OK
        vco_cal_done
        VCO calibration done
        24
        vco_cal_en
        VCO calibration enable
        pll_vbias_shunt_en
        VCO bias shunt enable
        prog_req
        frequency recalculation req.
        25
        bandgap_en
        bandgap enable
        frac_div_en
        fractional divider enable
        buff3_en
        buffer3 enable
        26
        pll_pfd_up
        PFD up signal
        pll_pfd_down
        PFD down signal
        pfd_up_down
        PFD output change (XOR'ed)
        27
        pll_lock_detect
        PLL lock detect
        pll_en
        PLL enable: TUNE state
        pllt0_ok
        PLL initial settling OK
        28
        pll_en
        PLL enable: TUNE state
        pll_lock_detect
        PLL lock detect
        pllts_ok
        PLL soft settling OK
        29
        pwst[0]
        internal power state
        pwst[1]
        internal power state
        pwst[2]
        internal power state
        Internal digital signals available on the Digital Test Bus (continued from the previous page):
        dtb[4:0]
        GPIO0
        Signal
        GPIO1
        Signal
        GPIO2
        Signal
        30
        xok
        chip ready: READY state
        pll_en
        PLL enable: TUNE state
        tx_en
        TX enable: TX state
        31
        ts_en
        temperature sensor enable
        auto_tx_on
        automatic TX ON
        tx_off
        TX OFF
        32
        ch_freq_req
        frequency change request
        return_tx
        return from TX
        pk_sent
        packet sent
        33
        retran_req
        retransmission request
        tx_ffpt_store
        TX FIFO pointer store
        tx_ffpt_restore
        TX FIFO pointer restore
        34
        pa_on_trig
        PA ON trigger
        dly_5us_ok
        5 us delay expired
        mod_dly_ok
        modulator delay expired
        35
        tx_shdwn
        TX shutdown
        ramp_start
        modulator ramp down start
        ramp_done
        modulator ramp down ended
        36
        pk_sent_dly
        delayed packet sent
        tx_shdwn_done
        TX shutdown done
        pa_ramp_en
        PA ramp enable
        37
        tx_en
        TX enable: TX state
        ldo_rf_precharge
        RF LDO precharge
        pa_ramp_en
        PA ramp enable
        38
        pa_on_trig
        TX enable: TX state
        dp_tx_en
        packet handler (TX) enable
        mod_en
        modulator enable
        39
        reg_wr_en
        register write enable
        reg_rd_en
        register rdead enable
        addr_inc
        register address increment
        40
        dp_tx_en
        packet handler (TX) enable
        data_start
        start of TX data
        pk_sent
        packet has been sent
        41
        data_start
        start of TX data
        tx_out
        packet handler TX data out
        pk_sent
        packet has been sent
        42
        ramp_done
        ramp is done
        data_start
        start of TX data
        pk_tx
        packet is being transmitted
        43
        tx_ffaf
        TX FIFO almost full
        tx_fifo_wr_en
        TX FIFO write enable
        tx_ffem_tst
        internal TX FIFO empty
        44
        clk_mod
        modulator gated 10MHz clock
        tx_clk
        TX clock from NCO
        rd_clk_x8
        read clock = tx_clk / 10
        45
        mod_en
        modulator enable
        ramp_start
        start modulator ramping down
        ramp_done
        modulator ramp done
        46
        data_start
        data input start from PH
        ook_en
        OOK modulation enble
        ook
        OOK modulation
        47
        prog_req
        freq. channel update request
        freq_err
        wrong freq. indication
        dsm_rst_s_n
        dsm sync. reset
        48
        mod_en
        modulator enable
        tx_rdy
        TX ready
        tx_clk
        TX clock from NCO
        49
        dp_rx_en
        packet handler (RX) enable
        prea_valid
        valid preamble
        pk_srch
        packet is being searched
        50
        pk_srch
        packet is being searched
        sync_ok
        sync. word has been detected
        rx_data
        packet handler RX data input
        51
        pk_rx
        packet is being received
        sync_ok
        sync. word has been detected
        pk_valid
        valid packet received
        52
        sync_ok
        sync. word has been detected
        crc_error
        CRC error has been detected
        hdch_error
        header error detected
        53
        direct_mode
        direct mode
        rx_ffaf
        RX FIFO almost full
        rx_fifo_rd_en
        RX FIFO read enable
        54
        bit_clk
        bit clock
        prea_valid
        valid preamble
        rx_data
        demodulator RX data output
        55
        prea_valid
        valid preamble
        prea_inval
        invalid preamble
        ant_div_sw
        antenna switch (algorythm)
        56
        sync_ok
        sync. word has been detected
        bit_clk
        bit clock
        rx_data
        demodulator RX data output
        57
        clk_demod
        demodulator gated 30MHz clk
        adc_lsb_i
        ADC I channel data LSB
        demod_tst[0]
        demodulator test
        58
        prea_valid
        valid preamble
        demod_tst[2]
        demodulator test
        demod_tst[1]
        demodulator test
        59
        agc_smp_clk
        AGC sample clock
        win_h_tp
        window comparator high
        win_l_tp
        window comparator low dly'd
        60
        agc_smp_clk
        AGC sample clock
        win_h_dly_tp
        window comparator high
        win_l_dly_tp
        window comparator low dly'd
        61
        ldc_on
        active low duty cycle
        pll_en
        PLL enable: TUNE state
        rx_en
        RX enable: RX state
        62
        ldc_on
        active low duty cycle
        no_sync_det
        no sync word detected
        prea_valid
        valid preamble
        63
        adc_en
        ADC enable
        adc_refdac_en
        ADC reference DAC enable
        adc_rst_n
        combined ADC reset
      </Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>
        RESERVED
        txmod[2:0] = TX Modulation Delay. The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up.  It can be set from 0 us to 28 us in 4 us steps.
        ldoramp[2:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00 -	5 us
        01 -	10 us
        10 -	15 us
        11 -	20 us
        txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00 - 	5 us
        01 - 	10 us
        10 - 	15 us
        11 - 	20 us
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="45" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>
        pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 us and 310 us, in 10 us intervals. The default plltime  corresponds to 80 us. See formula above.
        pllt0 = PLL Settling Time (TO). This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0 us and 70 us, in 10 us steps. The default pllt0 corresponds to 50 us. See fomula above.
      </Description>
    </Register>
    <Register address="54" name="Reserved 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="X" />
      <Bit index="2" name="X" />
      <Bit index="1" name="X" />
      <Bit index="0" name="X" />
      <Description>RESERVED</Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        RESERVED
        adccaldone = Delta-sigma ADC Calibration Done. Reading this bit gives '1' if the calibration process has been finished.
        enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to '1' then the RC oscillator performs fine calibration in every app. 30 s.
        rccal = RC Calibration Force. If setting rccal='1' will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a '0' to '1' will initiate the calibration. This bit is cleared automatically.
        vcocaldp = VCO Calibration Double Precision enable. When this bit is set to '1' then the VCO calibration measures longer thus calibrates more precisely.
        vcocal = VCO Calibration Force.  If in Idle Mode and pllon='1', setting vcocal='1' will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        skipvco = Skip VCO Calibration. Setting skipvco='1' will skip the VCO calibration when going from the Idle state to the TX or RX state.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="preabp" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="iqswitch" />
      <Description>
        RESERVED
        preabp = Bypass Preamble Detection.
        refclksel = Delta-sigma Reference Clock Source Selection (1: 10MHz, 0: PLL)
        refclkinv = Delta-sigma Reference Clock Inversion enable
        iqswitch = I&amp;Q Channel Switch enable.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>
        RESERVED
        cpforceup = Charge Pump Force Up
        cpforcedn = Charge Pump Force Down
        cdconly = Charge Pump DC Offset Only
        cdcurr[2:0] = Charge Pump DC Current selection
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>
        cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        cpcorrov = Charge Pump Correction Override enable
        cpcorr[4:0] = Charge Pump Correction value
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        RESERVED
        fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
        d3trim[1:0] = Divider 3 Current Trim value
        d2trim[1:0] = Divider 2 Current Trim value
        d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        RESERVED
        vcocorrov = VCO Current Correction override
        vcocorr[3:0] = VCO Current Correction value
        vcocur[1:0] = VCO Current Trim value
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>
        vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov='0' the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov='1' the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives '1' if the calibration process has been finished.
        vcocal[6:0] = VCO Calibration Results
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="vcotype" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>
        RESERVED
        vcotype = VCO Type.
        0 - basic, constant K	1 - single varactor, changing K
        enoloop = Open Loop Mode enable
        dsmod = Delta-Sigma Modulus
        0 - 64000	1 - 65 536
        dsorder[1:0] = Delta-Sigma Order
        00 - 	0 order
        01 - 	1st order
        10 - 	2nd order
        11 - 	Mash 111
        dsrstmode = Delta-Sigma Reset Mode
        dsrst = Delta-Sigma Reset
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>
        enmix = Mixer enable override
        enlna = LNA enable override
        enpga = PGA enable override
        enpa = Power Amplifier enable override
        enbf5 = Buffer 5 enable override
        endv32 = Divider 3_2 enable override
        enbf12 = Buffer 1_2 enable override
        enmx2 = Multiplexer 2 enable override
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="enldet" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="enmx1" />
      <Description>
        ends = Delta-Sigma enable override
        enldet = Lock Detect enable (direct control, not override!)
        enmx3 = Mutiplexer 3 enable override
        enbf4 = Buffer 4 enable override
        enbf3 = Buffer 3 enable override
        enbf11 = Buffer 1_1 enable override
        enbf2 = Buffer 2 enable override
        enmx1 = Multiplexer enable override
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>
        enfrdv = Fractional Divider enable override
        endv31 = Divider 3_1 enable override
        endv2 = Divider 2 enable override
        endv1p5 = Divider 1.5 (div-by-1.5) enable override
        dvbshunt = VCO Bias Shunt disable override
        envco = VCO enable override
        encp = Charge Pump enable override
        enbg = Bandgap enable override
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>
        RESERVED
        chfiladd[3:0] = Channel Filter Coefficient Look-up Table Address. The address for channel filter coefficients used in the RX path.
      </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>
        RESERVED
        chfilval[5:0] = Filter Coefficient Value in the look-up table addressed by the chfiladd[3:0]
      </Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        pwst[1:0] = Internal Power States of the chip
        00 -	low power (stand-by / sleep / sensor)
        01 -	ready
        11 -	tune
        10 -	TX
        enspor = Smart POR enable
        clkhyst = Clock Hysteresis Setting
        enbias2x = 2 times higher bias current enable
        enamp2x = 2 times higher amplification enable
        bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
        0 - output buffer is controlled by the state machine
        1 - output buffer is controlled by the enbuf bit
        enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>
        rccov = RC Oscillator Coarse Calibration Override. When rccov='0' the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov='1' the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>
        rcfov = RC Oscillator Fine Calibration Override. When rcfov='0' the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov='1' the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>
        RESERVED
        enbias = Bias enable
        envcoldo = VCO LDO enable
        enifldo = IF LDO enable
        enrfldo = RF LDO enable
        enpllldo = PLL LDO enable
        endigldo = Digital LDO enable
        endigpwdn = Digital Power Domain Powerdown enable in Idle mode
      </Description>
    </Register>
    <Register address="66" name="Reserved 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="X" />
      <Bit index="2" name="X" />
      <Bit index="1" name="X" />
      <Bit index="0" name="X" />
      <Description>RESERVED</Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>
        adcrst = delta-sigma ADC reset
        enrefdac = delta-sigma ADC reference DAC enable override
        enadc = delta-sigma ADC enable override
        adctuneovr = resonator RC calibration value override enable
        adctune[3:0] = resonator RC calibration value
      </Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>
        RESERVED
        envcm = delta-sigma ADC VCM enable override
        adcoloop = delta-sigma ADC open loop enable
        adcref[2:0] = delta-sigma ADC reference voltage
        000 -	0.5 V
        001 -	0.6 V
        010 -	0.7 V
        ...
        111 -	1.2 V
      </Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>
        RESERVED
        agcen = Automatic Gain Control enable When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
        lnagain = LNA Gain select
        0 - min. gain = 5 dB	1 -max. gain = 25 dB
        pga[3:0] = PGA Gain Override value
        000 -	0 dB
        001 -	3 dB
        010 -	6 dB
        ...
        101 -	24 dB max.
      </Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>
        RESERVED
        agcslow = AGC Slow Gain Increase enable. When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
        lnacomp[3:0] = LNA Gain Compensation, used for smoothing RSSI value when LNA gain is switched.
        pgath[1:0] = window comparator reference voltage adjust in the PGA
      </Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        RESERVED
        firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000 - 	i_coe0 (Default =d1)
        001 - 	i_coe1 (Default =d3)
        010 - 	i_coe2 (Default =d6)
        011 - 	i_coe3 (Default =d10)
        100 - 	i_coe4 (Default =d15)
        101 - 	i_coe5 (Default =d19)
        110 - 	i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>
        RESERVED
        firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.
      </Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>
        RESERVED
        txpow[2:0] = TX Output Power.  The output power is configurable from +13 to -8dBm in ~3dB steps.  txpow[2:0]='111' corresponds to +13dBm and '000' to -8dBm.
      </Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="AA" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        RESERVED
        enmaninv = Manchester Data Inversion is enabled if this bit is set.
        enmanch = Manchester Coding is enabled if this bit is set.
        enwhite = Data Whitening is enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="-" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        trclk[1:0] = TX Data Clock Configuration.
        00 -	No TX Data CLK is available (asynchronous mode)
        01 -	TX Data CLK is available via the GPIO (one of the GPIO's should be programmed as well)
        10 -	TX Data CLK is available via the SCK pin
        11 -	TX Data CLK is available via the nIRQ pin
        dtmod[1:0] = Modulation Source
        00 - 	Direct Mode using TX_Data function via the GPIO pin (one of the GPIO's should be 	programmed accordingly as well)
        01 - 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10 - 	FIFO Mode
        11 - 	PN9 (internally generated)
        eninv = Invert TX and RX Data
        modtyp[2:0] = Modulation Type
        000 -	Unmodulated carrier
        001 -	OOK
        010 -	FSK
        011 -	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="43" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>fd[7:0] = Frequency Deviation Setting. See formula above. </Description>
    </Register>
    <Register address="73" name="Frequency Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>fo[7:0] = Frequency Offset Setting. </Description>
    </Register>
    <Register address="74" name="Frequency Channel Control" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>
        RESERVED
        fo[9:8] = Upper bits of the Frequency Offset Setting. fo[9] is the sign bit.
      </Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="35" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="-" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        RESERVED
        sbsel = Side Band Select.
        hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-960MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
        fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]='00000' corresponds to the 240-250MHz Band for hbsel='0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0]='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>
        RESERVED
        txafthr[5:0] = TX FIFO Almost Full Threshold
      </Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>
        RESERVED
        txfaethr[5:0] = TX FIFO Almost Empty Threshold
      </Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>
        RESERVED
        rxafthr[5:0] = RX FIFO Almost Full Threshold
      </Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        fifod[7:0] = A write (R/W='1') to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH. A Read (R/W='0') to this address will begin a burst read of the RX FIFO, in the same manner.
      </Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="11" type="Si4032" revision="Z" projectID="P828" name="Tamara RevZ">
    <TxPufferSize>32</TxPufferSize>
    <RxPufferSize>0</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress></RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="7F" name="FIFO Data" size="8" defaultVal="-" isRead="0" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>fifod[7:0] = A write to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH. </Description>
    </Register>
    <Register address="00" name="Device Type" size="8" defaultVal="07" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        dt[4:0] = Device Type Code.
        This internally hardwired code will allow the user to identify the different devices.
        Tamara = 00111.
      </Description>
    </Register>
    <Register address="01" name="Version Code" size="8" defaultVal="1" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>
        vc[4:0] = Version Code.
        Internally hardwired version code of the chip
      </Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="txffovfl" />
      <Bit index="6" name="txffunfl" />
      <Bit index="5" name="0" />
      <Bit index="4" name="0" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="lockdet" />
      <Bit index="1" name="cps" />
      <Bit index="0" name="0" />
      <Description>
        txffovfl = TX FIFO Overflow status.
        txffunfl = TX FIFO Underflow status.
        freqerr = Frequency Error status. The programmed frequency is outside of the operating range.
        The actual frequency is saturated to the max/min value.
        lockdet = Synthesizer Lock Detect status.
        cps = Chip Power State:
        0 – Idle State
        1 – TX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="itxfferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="0" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="0" />
      <Bit index="0" name="0" />
      <Description>
        itxfferr = TX FIFO Error.
        When set to ‘1’ the TX FIFO has overflowed or underflowed and needs to be cleared and reloaded.
        itxffafull = TX FIFO Almost Full. When set to ‘1’ the TX FIFO has met its almost full threshold and needs to be transmitted.
        itxffaem= TX FIFO Almost Empty. When set to ‘1’ the TX FIFO is almost empty and needs to be filled.
        iext = External Interrupt. When set to ’1’ an interrupt occurred on one of the GPIO’s if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        ipksent = Packet Sent. When set to ’1’ a valid packet has been transmitted.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="0" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        When any of the following bits change state from ‘0’ to ‘1’ the control block will notify the micro-controller by setting the nIRQ pin LOW = ’0’ if it is enabled in the Interrupt Mask 2 register. The nIRQ pin will go to HIGH when the microcontroller reads this address and all the interrupt bits will be cleared. If any of these bits is not enabled in the Interrupt Mask 2 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
        iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.
        ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
        ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset this bit will be set to 1.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Mask 1" size="8" defaultVal="E4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="mtxffovfl" />
      <Bit index="6" name="mtxffafull" />
      <Bit index="5" name="mtxffaem" />
      <Bit index="4" name="-" />
      <Bit index="3" name="mext" />
      <Bit index="2" name="mpksent" />
      <Bit index="1" name="-" />
      <Bit index="0" name="-" />
      <Description>
        mfftxovfl = Mask TX FIFO Overflow. When set to ‘1’ the TX FIFO Overflow interrupt will be enabled.
        mtxffafull = Mask TX FIFO Almost Full. When set to ‘1’ the TX FIFO Almost Full interrupt will be enabled.
        mtxffaem= Mask TX FIFO Almost Empty. When set to ‘1’ the TX FIFO Almost Empty interrupt will be enabled.
        mext = Mask External Interrupt. When set to ’1’ the External Interrupt will be enabled.
        mpksent = Mask Packet Sent. When set to ’1’ the Packet Sent Interrupt will be enabled.
      </Description>
    </Register>
    <Register address="06" name="Interrupt Mask 2" size="8" defaultVal="0F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="mwut" />
      <Bit index="2" name="mlbd" />
      <Bit index="1" name="mchiprdy" />
      <Bit index="0" name="mpor" />
      <Description>
        mwut = Mask Wake-Up Timer. When set to ‘1’ the Wake-Up Timer  interrupt will be enabled.
        mlbd = Mask Low Battery Detect. When set to ‘1’ the Low Battery Detect interrupt will be enabled.
        mchiprdy= Mask Chip Ready (XTAL). When set to ‘1’ the Chip Ready interrupt will be enabled.
        mpor = Mask POR.  When set to ‘1’ the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="38" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="1" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enlbd" />
      <Bit index="6" name="enwt" />
      <Bit index="5" name="x32ksel" />
      <Bit index="4" name="ents" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="-" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        enlbd = Enable Low Battery Detect.  When this bit is set to ‘1’ the Low Battery Detector circuit and threshold comparison will be enabled.
        enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = ’1’. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
        ents = Temperature Sensor enable
        txon = TX on in manual transmit mode, self-cleared in FIFO mode.
        pllon = TUNE Mode (PLL is ON). When pllon = ’1’ the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        xton = READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="-" />
      <Bit index="1" name="-" />
      <Bit index="0" name="ffclrtx" />
      <Description>
        swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = ‘1’.  This bit will be automatically cleared.
        autotx = Automatic Transmission. When autotx = ‘1’ the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.
        ffclrtx = TX FIFO Clear.  Setting ffclrtx=’1’ will clear the contents of the TX FIFO.
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>xlc[6:0] = Tuning Capacitance for the 30MHz XTAL</Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        clkt[1:0] = Clock Tail.  If enlfc = ‘0’ then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00 –  0 cycle
        01 –  128 cycles
        10 –  256 cycles
        11 –  512 cycles
        enlfc = Enable Low Frequency Clock.  When enlfc = ‘1’ and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = ‘000’, 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = ‘1’ except the ‘111’.
        000 –  30 MHz
        001 –  15 MHz
        010 –  10 MHz
        011 –  4 MHz
        100 –  3 MHz
        101 –  2 MHz
        110 –  1 MHz
        111 – 32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        pup0 = Pull-up Resistor enable on GPIO0. When set to ‘1’ the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio0[4:0] = GPIO0 pin function select:
        00000 –  Power-On-Reset (output)
        00001 –  Wake-Up Timer: ’1’ when WUT has expired  (output)
        00010 –  Low Battery Detect: ’1’ when battery is below threshold setting (output)
        00011 –  Direct Digital Input
        00100 – External Interrupt, falling edge (input)
        00101 –  External Interrupt, rising edge (input)
        00110 –  External Interrupt, state change (input)
        00111 – ADC Analog Input
        01000 – Reserved (Analog Test N Intput)
        01001 – Reserved (Analog Test P Intput)
        01010 – Direct Digital Output
        01011 – Reserved (Digital Test Output)
        01100 – Reserved (Analog Test N Output)
        01101 – Reserved (Analog Test P Output)
        01110 – Reference Voltage (output)
        01111 – TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000 – TX Data input for direct modulation (input)
        10001 – External Retransmission Request (input)
        10010 – TX State (output)
        10011 – TX FIFO Almost Full  (output)
        else    – GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        pup1 = Pull-up Resistor enable on GPIO1. When set to ‘1’ the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        Gpio1[4:0] = GPIO0 pin function select:
        00000 –  Power-On-Reset Inverted (output)
        00001 –  Wake-Up Timer: ’1’ when WUT has expired  (output)
        00010 –  Low Battery Detect: ’1’ when battery is below threshold setting (output)
        00011 –  Direct Digital Input
        00100 – External Interrupt, falling edge (input)
        00101 –  External Interrupt, rising edge (input)
        00110 –  External Interrupt, state change (input)
        00111 – ADC Analog Input
        01000 – Reserved (Analog Test N Intput)
        01001 – Reserved (Analog Test P Intput)
        01010 – Direct Digital Output
        01011 – Reserved (Digital Test Output)
        01100 – Reserved (Analog Test N Output)
        01101 – Reserved (Analog Test P Output)
        01110 – Reference Voltage (output)
        01111 – TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000 – TX Data input for direct modulation (input)
        10001 – External Retransmission Request (input)
        10010 – TX State (output)
        10011 – TX FIFO Almost Full  (output)
        else    – GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        pup2 = Pull-up Resistor enable on GPIO2. When set to ‘1’ the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        Gpio2[4:0] = GPIO2 pin function select:
        00000 –  Microcontroller CLK (output)
        00001 –  Wake-Up Timer: ’1’ when WUT has expired  (output)
        00010 –  Low Battery Detect: ’1’ when battery is below threshold setting (output)
        00011 –  Direct Digital Input
        00100 – External Interrupt, falling edge (input)
        00101 –  External Interrupt, rising edge (input)
        00110 –  External Interrupt, state change (input)
        00111 – ADC Analog Input
        01000 – Reserved (Analog Test N Intput)
        01001 – Reserved (Analog Test P Intput)
        01010 – Direct Digital Output
        01011 – Reserved (Digital Test Output)
        01100 – Reserved (Analog Test N Output)
        01101 – Reserved (Analog Test P Output)
        01110 – Reference Voltage (output)
        01111 – TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000 – TX Data input for direct modulation (input)
        10001 – External Retransmission Request (input)
        10010 – TX State (output)
        10011 – TX FIFO Almost Full  (output)
        else    – GND
      </Description>
    </Register>
    <Register address="3A" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcstart / adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        adcstart / adcdone = ADC Measurement Start bit. Reading this bit gives ‘1’ if the ADC measurement cycle has been finished.
        adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
        000 – Internal Temperature Sensor
        001 – GPIO0, single-ended
        010 – GPIO1, single-ended
        011 –  GPIO2, single-ended
        100 – GPIO0(+) - GPIO1(-), differential
        101 – GPIO1(+) - GPIO2(-), differential
        110 – GPIO0(+) - GPIO2(-), differential
        111 – GND
        adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
        0X – bandgap voltage (1.2V)
        10 – VDD / 3
        11 –  VDD / 2
        adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0: adcref[0] = 1:
        FS = 0.014 * (adcgain[1:0] + 1) * VDD  FS = 0.021 * (adcgain[1:0] + 1) * VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="11" name="Wake-Up Timer Period 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="wtr[3]" />
      <Bit index="4" name="wtr[2]" />
      <Bit index="3" name="wtr[1]" />
      <Bit index="2" name="wtr[0]" />
      <Bit index="1" name="wtd[1]" />
      <Bit index="0" name="wtd[0]" />
      <Description>
        The period of the wake-up timer can be calculated as TWUT = (32 * M * 2R-D) / 32.768 [ms]
        wtr[3:0] = Wake Up Timer R value.  See formula above.
        wtd[1:0] = Wake Up Timer D value.  See formula above.
      </Description>
    </Register>
    <Register address="12" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>
        The period of the wake-up timer can be calculated as TWUT = (32 * M * 2R-D) / 32.768 [ms]
        wtm[15:8] = Wake Up Timer M value.  See formula above.
      </Description>
    </Register>
    <Register address="13" name="Wake-Up Timer Period 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        The period of the wake-up timer can be calculated as TWUT = (32 * M * 2R-D) / 32.768 [ms]
        wtm[7:0] = Wake Up Timer M value.  See formula above.
      </Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>
        The period of the wake-up timer can be calculated as TWUT = (32 * M * 2R-D) / 32.768 [ms]
        wtm[15:8] = Wake Up Timer Current M value.  See formula above.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>
        The period of the wake-up timer can be calculated as TWUT = (32 * M * 2R-D) / 32.768 [ms]
        wtm[7:0] = Wake Up Timer Current M value.  See formula above.
      </Description>
    </Register>
    <Register address="16" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>
        The threshold can be calculated as LB_TH = ( 1.675 + lbdt * 50 mV ) +/- 25 mV
        lbdt[4:0] = Low Battery Detector Threshold.  This threshold is compared to Battery Voltage Level.  If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V.
      </Description>
    </Register>
    <Register address="17" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continouosly.</Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="0D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        enpactx = Enable TX Packet Handling.  If FIFO Mode (modsrc = ’10’) is being used automatic packet handling may be enabled. Setting enpactx = ’1’ will enable automatic packet handling in the TX path. Registers 30h-3Fh allow for various configurations of the packet structure. Setting enpactx = ’0’ will not do any packet handling. It will only transmit what is loaded to the FIFO until the FIFO Empty Status becomes active.
        encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
        crc[1:0] = CRC polynomial selection.
        00 – CCITT
        01 – CRC-16
        10 – IEC-16
        11 – Biacheva
      </Description>
    </Register>
    <Register address="32" name="EzMac Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="0" />
      <Bit index="3" name="pksent" />
      <Bit index="2" name="pktx" />
      <Bit index="1" name="0" />
      <Bit index="0" name="0" />
      <Description>
        pksent = Packet Sent.  A pksent  = ’1’ a packet has been sent by the radio. (Same bit as in register 03)
        pktx = Packet Transmitting. When pktx = ‘1’ the radio is currently transmitting a packet.
      </Description>
    </Register>
    <Register address="34" name="Header Control 1" size="8" defaultVal="42" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhdlen[2]" />
      <Bit index="6" name="txhdlen[1]" />
      <Bit index="5" name="txhdlen[0]" />
      <Bit index="4" name="-" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        txhdlen[2:0] = Transmit Header Length. Length of header used if packet handler is enabled for TX (enpactx). Headers are transmitted in descending order.
        000 – No TX header
        001 –  Header 3
        010 –  Header 3 and 2
        011 –  Header 3 and 2 and 1
        1XX – Header 3 and 2 and 1 and 0
        fixpklen = Fix Transmit Packet Length.  When fixpklen = ‘1’ the packet length (pklen[7:0]) is not included in the header. When fixpklen = ‘0’ the packet length is included in the header.
        synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00 –  Synchronization Word 3
        01 –  Synchronization Word 3 and 2
        10 –  Synchronization Word 3 and 2 and 1
        11 –  Synchronization Word 3 and 2 and 1 and 0
        prealen[8] = MSB of Preamble Length. See register Preamble Length.
      </Description>
    </Register>
    <Register address="35" name="Preamble Length" size="8" defaultVal="07" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register + 1 corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = ‘000000111’  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = ‘111111111’ which corresponds to a 256 Bytes  Preamble.</Description>
    </Register>
    <Register address="37" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3F" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] – Packet Length.  The value in the pklen[7:0] register + 1 corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = ‘00001000’ corresponds to a packet length of 9 Bytes.  The maximum packet length is pklen[7:0] = ‘11111111’, a 256 byte packet.</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>atb[4:0] = Analog Test Bus. The selection of internal analog testpoints that are muxed onto TESTp and TESTn.</Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>
        ensctest = Scan Test Enable. When set to ‘1’ then GPIO0 will be the ScanEn input.
        dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
      </Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>
        txmod[2:0] = TX Modulation Delay. The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up.  It can be set from 0 us to 28 us in 4 us steps.
        ldoramp[1:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00 – 5 us
        01 – 10 us
        10 – 15 us
        11 – 20 us
        txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00 –  5 us
        01 –  10 us
        10 –  15 us
        11 –  20 us
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="45" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>
        The total settling time (cold start) of the PLL after the calibration can be calculated as TCS = TS + TO.
        pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 µs and 310 µs, in 10 µs intervals. The default plltime  corresponds to 80 µs. See formula above.
        pllt0 = PLL Settling Time (TO). This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0 µs and 70 µs, in 10 µs steps. The default pllt0 corresponds to 50 µs. See fomula above.
      </Description>
    </Register>
    <Register address="54" name="Reserved 1" size="8" defaultVal="0" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="X" />
      <Bit index="2" name="X" />
      <Bit index="1" name="X" />
      <Bit index="0" name="X" />
      <Description>Reserved</Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="enrcfcal" />
      <Bit index="2" name="rccal" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to ‘1’ then the RC oscillator performs fine calibration in every app. 30 s.
        rccal = RC Calibration Force. If setting rccal=’1’ will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a ‘0’ to ‘1’ will initiate the calibration. This bit is cleared automatically.
        vcocal = VCO Calibration Force.  If in Idle Mode and pllon=’1’, setting vcocal=’1’ will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        skipvco = Skip VCO Calibration. Setting skipvco=’1’ will skip the VCO calibration when going from the Idle state to the TX or RX state.
      </Description>
    </Register>
    <Register address="56" name="Modulator Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="-" />
      <Description>
        refclksel = Modulator Reference Clock Source Selection (1: 10MHz, 0: PLL)
        refclkinv = Modulator Reference Clock Inversion enable
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>
        cpforceup = Charge Pump Force Up
        cpforcedn = Charge Pump Force Down
        cdconly = Charge Pump DC Offset Only
        cdcurr[2:0] = Charge Pump DC Current selection
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>
        cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        cpcorrov = Charge Pump Correction Override enable
        cpcorr[4:0] = Charge Pump Correction value
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
        d3trim[1:0] = Divider 3 Current Trim value
        d2trim[1:0] = Divider 2 Current Trim value
        d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocaldp" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        vcocaldp = VCO Calibration Double Precision enable. When this bit is set to ‘1’ then the VCO calibration measures longer thus calibrates more precisely.
        vcocorrov = VCO Current Correction override
        vcocorr[3:0] = VCO Current Correction value
        vcocur[1:0] = VCO Current Trim value
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>
        vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov=’0’ the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov=’1’ the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives ‘1’ if the calibration process has been finished.
        vcocal[4:0] = VCO Calibration Results
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="vcotype" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>
        vcotype = VCO Type.
        0 – basic, constant K 1 – single varactor, changing K
        dsmod = Delta-Sigma Modulus
        0 – 64 000 1 – 65 536
        dsorder[1:0] = Delta-Sigma Order
        00 –  0 order
        01 –  1st order
        10 –  2nd order
        11 –  Mash 111
        dsrstmode = Delta-Sigma Reset Mode
        dsrst = Delta-Sigma Reset
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>
        enpa = Power Amplifier enable override
        enbf5 = Buffer 5 enable override
        endv32 = Divider 3_2 enable override
        enbf12 = Buffer 1_2 enable override
        enmx2 = Multiplexer 2 enable override
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="enldet" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="enmx1" />
      <Description>
        ends = Delta-Sigma enable override
        enldet = Lock Detect enable (direct control, not override!)
        enmx3 = Mutiplexer 3 enable override
        enbf4 = Buffer 4 enable override
        enbf3 = Buffer 3 enable override
        enbf11 = Buffer 1_1 enable override
        enbf2 = Buffer 2 enable override
        enmx1 = Multiplexer enable override
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="-" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>
        enfrdv = Fractional Divider enable override
        endv31 = Divider 3_1 enable override
        endv2 = Divider 2 enable override
        endv1p5 = Divider 1.5 (div-by-1.5) enable override
        envco = VCO enable override
        encp = Charge Pump enable override
        enbg = Bandgap enable override
      </Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[1]" />
      <Bit index="6" name="pwst[0]" />
      <Bit index="5" name="enspor" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        pwst[1:0] = Internal Power States of the chip
        00 – low power (stand-by / sleep / sensor)
        01 – ready
        11 – tune
        10 – TX
        enspor = Smart POR enable
        clkhyst = Clock Hysteresis Setting
        enbias2x = 2 times higher bias current enable
        enamp2x = 2 times higher amplification enable
        bufovr = Output Buffer Enable Override If set to ‘1’ then the enbuf bit controls the output buffer.
        0 – output buffer is controlled by the state machine
        1 – output buffer is controlled by the enbuf bit
        enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to ‘1’.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>
        rccov = RC Oscillator Coarse Calibration Override. When rccov=’0’ the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov=’1’ the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>
        rcfov = RC Oscillator Fine Calibration Override. When rcfov=’0’ the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov=’1’ the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="-" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="enlpldo" />
      <Description>
        enbias = Bias enable
        envcoldo = VCO LDO enable
        enrfldo = RF LDO enable
        enpllldo = PLL LDO enable
        endigldo = Digital LDO enable
        enlpldo = Low Power LDO enable
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>
        diglvl[2:0] = Digital LDO voltage level
        000 – 1.2 V
        001 – 1.3 V
        010 – 1.5 V
        011 – 1.7 V
        1XX – 1.8 V
      </Description>
    </Register>
    <Register address="67" name="Temperature Sensor Calibration" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entscal" />
      <Bit index="3" name="tsc[3]" />
      <Bit index="2" name="tsc[2]" />
      <Bit index="1" name="tsc[1]" />
      <Bit index="0" name="tsc[0]" />
      <Description>
        tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
        00 – -64C ..   64C (full operating range), with 0.5C resolution (1 LSB in the 8 bit ADC)
        01 – -64C .. 192C, with 1C resolution (1 LSB in the 8 bit ADC)
        11 –    0C .. 128C, with 0.5C resolution (1 LSB in the 8 bit ADC)
        10 – -40F  .. 216F, with 1F resolution (1 LSB in the 8 bit ADC)
        entsoffs = Temperature Sensor Offset enable
        entscal = Temperature Sensor Calibration enable
        tscal[3:0] = Temperature Sensor Calibration value
      </Description>
    </Register>
    <Register address="68" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)</Description>
    </Register>
    <Register address="69" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>
        The offset can be calculated as Offset = adcoffs[2:0] * VDD / 1000; MSB = adcoffs[3] = Sign bit
        adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.
      </Description>
    </Register>
    <Register address="6A" name="Reserved 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="X" />
      <Bit index="2" name="X" />
      <Bit index="1" name="X" />
      <Bit index="0" name="X" />
      <Description>Reserved</Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000 –  i_coe0 (Default =d1)
        001 –  i_coe1 (Default =d3)
        010 –  i_coe2 (Default =d6)
        011 –  i_coe3 (Default =d10)
        100 –  i_coe4 (Default =d15)
        101 –  i_coe5 (Default =d19)
        110 –  i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="07" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="patrim[3]" />
      <Bit index="5" name="patrim[2]" />
      <Bit index="4" name="patrim[1]" />
      <Bit index="3" name="patrim[0]" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>
        patrim[3:0] = Antenna Tuning value. It is applicable on differential PA only.
        txpow[2:0] = TX Output Power.  The output power is configurable from +13 to -8dBm in ~3dB steps.  txpow[2:0]=’111’ corresponds to +13dBm and ‘000’ to -8dBm.
      </Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>
        The data rate can be calculated as TX_DR = 10^3 * txdr[15:0] / 2^16 [kbit/s]
        txdr[15:8] = Data Rate upper byte.  See formula above. Default = 40kbps.
      </Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="AA" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>
        The data rate can be calculated as TX_DR = 10^3 * txdr[15:0] / 2^16 [kbit/s]
        txdr[7:0] = Data Rate upper byte.  See formula above. Default = 40kbps.
      </Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        enmaninv = Manchester Data Inversion is enabled if this bit is set.
        enmanch = Manchester Coding is enabled if this bit is set.
        enwhite = Data Whitening is enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="63" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="modsrc[1]" />
      <Bit index="4" name="modsrc[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="-" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        trclk[1:0] = TX Data Clock Configuration. Only applicable if using modulation source 00 or 01.
        00 – No TX Data CLK is available (asynchronous mode, only applicable in FSK modulation type)
        01 – TX Data CLK is available via the GPIO (one of the GPIO’s should be programmed as well)
        10 – TX Data CLK is available via the SDO pin (only when nSEL is high)
        11 – TX Data CLK is available via the nIRQ pin
        modsrc[1:0] = Modulation Source
        00 –  Direct Mode using TX_Data function via the GPIO pin (one of the GPIO’s should be  programmed accordingly as well)
        01 –  Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10 –  FIFO Mode
        11 –  PN9 (internally generated)
        eninv = Invert TX Data
        modtyp[2:0] = Modulation Type
        000 – Unmodulated carrier
        001 – OOK
        010 – FSK
        011 – GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="43" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>
        The frequency deviation can be calculated: Fd = 625 Hz * fd[7:0]
        fd[7:0] = Frequency Deviation Setting. See formula above.
      </Description>
    </Register>
    <Register address="73" name="Frequency Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>
        The frequency offset can be calculated: Offset = 156.25 Hz * (hbsel + 1) * fo[7:0] ; MSB = fo[8] = Sign bit
        fo[7:0] = Frequency Offset Setting.
      </Description>
    </Register>
    <Register address="74" name="Frequency Channel Control" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="-" />
      <Bit index="1" name="-" />
      <Bit index="0" name="fo[8]" />
      <Description>fo[8] = MSB (sign) of the Frequency Offset Setting.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="35" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        hbsel = High Band Select.  Setting hbsel = ‘1’ will choose the freqency range from 480-930MHz (High Bands). Setting hbsel = ‘0’ will choose the freqency range from 240-479.9MHz (Low Bands).
        fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]=’00000’ corresponds to the 240-250MHz Band for hbsel=’0’ and the 480-500MHz Band for hbsel=’1’.  Setting fb[4:0]=’00001’ corresponds to the 250-260MHz Band for hbsel=’0’ and the 500-520MHz Band for hbsel=’1’.
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>
        ftx = (fb+24+(fc+fo) / 64000) * 10000 * (hbsel+1) + (fhch * fhs * 10)  [kHz],
        where parameters fc, fo, fb and hb_sel come from the current location of the frequency look-up table addressed by the look-up table pointer (register 78h). These parameter values can be read out from registers 75h – 77h. Parameters fhch and fhs come from register 78h and 79h.
        fc[15:8] = Nominal Carrier Frequency Setting. See formula above.
      </Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>
        ftx = (fb+24+(fc+fo) / 64000) * 10000 * (hbsel+1) + (fhch * fhs * 10)  [kHz],
        where parameters fc, fo, fb and hb_sel come from the current location of the frequency look-up table addressed by the look-up table pointer (register 78h). These parameter values can be read out from registers 75h – 77h. Parameters fhch and fhs come from register 78h and 79h.
        fc[7:0] = Nominal Carrier Frequency Setting. See formula above.
      </Description>
    </Register>
    <Register address="78" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="79" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold - 1</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold - 1</Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="12" type="Si4432" revision="W" projectID="0" name="Ara RevW">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>dt[4:0] = Device Type Code.  This internally hardwired code will allow the user to recognize whether this is a Transmitter, Receiver, or a Transceiver.  Ara = 01000.</Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="01" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>vc[4:0] = Version Code.  Internally hardwired version code of the chip</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="lockdet" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>
        ffovfl = RX/TX FIFO Overflow status.
        ffunfl = RX/TX FIFO Underflow status.
        rxffem = RX FIFO Empty status.
        headerr = Header Error status. The actual received packet has a header check error.
        freqerr = Frequency Error status. The programmed frequency is outside of the operating range. The actual frequency is saturated to the max/min value.
        lockdet = Synthesizer Lock Detect status.
        cps[1:0] = Chip Power State:
        00 -	Idle State
        01 -	RX State
        10 -	TX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>
        ifferr = FIFO Underflow/Overflow Error.  When set to '1' the TX or RX FIFO has overflowed or underflowed.
        itxffafull = TX FIFO Almost Full.  When set to '1' the TX FIFO has met its almost full threshold and needs to be transmitted.
        itxffaem= TX FIFO Almost Empty.  When set to '1' the TX FIFO is almost empty and needs to be filled.
        irxffafull = RX FIFO Almost Full.  When set to '1' the RX FIFO has met its almost full threshold and needs to be read by the microcontroller
        iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        ipksent = Packet Sent Interrupt. When set to'1' a valid packet has been transmitted.
        ipkvalid =  Valid Packet Received. When set to '1' a valid packet has been received.
        icrcerror = CRC Error. When set to '1' the cyclic redundancy check is failed.
        When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
        Bit
        Status Name
        Set/Clear conditions:
        [7]
        ifferr
        Set if there is a Tx or RX FIFO Overflow or Underflow.  It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
        [6]
        itxffafull
        Will be set when the number of bytes written to TX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we start transmitting and the FIFO data is read out and the number of bytes left in the FIFO is smaller or equal to the threshold).
        [5]
        itxffaem
        Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
        [4]
        irxffafull
        Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we read enough data from RX FIFO so that the number of data bytes not yet read is below the Almost Full threshold.
        [3]
        iext
        External interrupt source
        [2]
        ipksent
        Will go high once a packet is sent all the way through (no TX abort). This status will be cleaned if 1) We leave FIFO mode or 2) In FIFO mode we start a new transmission.
        [1]
        ipkvalid
        Goes high once a packet is fully received (no RX abort). It is automatically cleaned once we receive and acknowledge the Sync Word for the next packet.
        [0]
        icrcerror
        Goes High once the CRC computed during RX differs from the CRC sent in the packet by the TX. It is cleaned once we start receiving new data in the next packet.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
        ipreaval = Valid Preamble Detected. When a preamble is detected this bit will be set to 1.
        ipreainval = Invalid Preamble Detected. When the preamble is not found within a period of time after the RX is enabled, this bit will be set to 1.
        irssi = RSSI. When RSSI level exceeds the programmed thershold this bit will be set to 1.
        iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.
        ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
        ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.
        When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
        Bit
        Status Name
        Set/Clear conditions:
        [7]
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        [6]
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        [5]
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        [4]
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        [3]
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        [2]
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        [1]
        ichiprdy
        Chip ready goes high once we enable the xtal, Tx or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        [0]
        ipor
        Power on status.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>
        enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
        entxffafull = Enable TX FIFO Almost Full. When set to '1' the TX FIFO Almost Full interrupt will be enabled.
        entxffaem = Enable TX FIFO Almost Empty. When set to '1' the TX FIFO Almost Empty interrupt will be enabled.
        enrxffafull = Enable RX FIFO Almost Full. When set to '1' the RX FIFO Almost Full interrupt will be enabled.
        enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
        enpksent = Enable Packet Sent. When ipksent ='1' the Packet Sense Interrupt will be enabled.
        enpkvalid = Enable Valid Packet Received. When ipkvalid = '1' the Valid Packet Received Interrupt will be  enabled
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        enswdet = Enable Sync Word Detected. When mpreadet ='1' the Preamble Detected Interrupt will be enabled.
        enpreaval = Enable Valid Preamble Detected. When mpreadet ='1' the Valid Preamble Detected Interrupt will be enabled.
        enpreainval = Enable Invalid Preamble Detected. When mpreadet ='1' the Invalid Preamble Detected Interrupt will be enabled.
        enrssi = Enable RSSI. When set to '1' the RSSI Interrupt will be  enabled.
        enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
        enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
        enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
        enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.
        enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.
        enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
        txon = TX on to enable Transmit mode
        rxon = RX on to enable Receiver mode.
        pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        xton = READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="ffclrtx" />
      <Description>
        antdiv[2:0] = Enable Antenna Diversity. The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
        RX/TX state	non RX/TX state
        GPIO Ant1	GPIO Ant2	GPIO Ant1	GPIO Ant2
        000 - 	1	0	0	0
        001 -	0	1	0	0
        010 - 	1	0	1	1
        011 -	0	1	1	1
        100 -	antenna diversity algorythm	0	0
        101 - 	antenna diversity algorythm	1	1
        110 -	ant. div. algorythm in beacon mode	0	0
        111 - 	ant. div. algorythm in beacon mode 		1	1
        rxmpk = RX Multi Packet. When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the transceiver will automatically leaves the RX State after the first valid packet has been received.
        autotx = Automatic Transmission. When autotx = '1' the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.
        enldm = Enable Low Duty Cycle Mode. If this bit is set to '1' then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
        ffclrrx = RX FIFO Clear. Setting ffclrrx='1' will clear the contents of the RX FIFO.
        ffclrtx = TX FIFO Clear. Setting ffclrtx='1' will clear the contents of the TX FIFO.
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>xlc[6:0] = Tuning Capacitance for the 30MHz XTAL</Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        clkt[1:0] = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00 - 	0 cycle
        01 - 	128 cycles
        10 - 	256 cycles
        11 - 	512 cycles
        enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = '1' except the '111'.
        000 - 	30 MHz
        001 - 	15 MHz
        010 - 	10 MHz
        011 - 	4 MHz
        100 - 	3 MHz
        101 - 	2 MHz
        110 - 	1 MHz
        111 -	32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio1[4:0] = GPIO0pin function select:
        00000 - 	Power-On-Reset (output)
        00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - 	Direct Digital Input
        00100 -	External Interrupt, falling edge (input)
        00101 - 	External Interrupt, rising edge (input)
        00110 - 	External Interrupt, state change (input)
        00111 -	ADC Analog Input
        01000 -	Reserved (Analog Test N Intput)
        01001 -	Reserved (Analog Test P Intput)
        01010 -	Direct Digital Output
        01011 -	Reserved (Digital Test Output)
        01100 -	Reserved (Analog Test N Output)
        01101 -	Reserved (Analog Test P Output)
        01110 -	Reference Voltage (output)
        01111 -	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000 -	TX Data input for direct modulation (input)
        10001 -	External Retransmission Request (input)
        10010 -	TX State (output)
        10011 -	TX FIFO Almost Full  (output)
        10100 -	RX Data (output)
        10101 -	RX State (output)
        10110 -	RX FIFO Almost Full  (output)
        10111 -	Antenna 1 Switch used for antenna diversity  (output)
        11000 -	Antenna 2 Switch used for antenna diversity  (output)
        11001 -	Valid Preamble Detected  (output)
        11010 -	Invalid Preamble Detected  (output)
        11011 -	Sync Word Detected  (output)
        11100 -	Clear Channel Assessement  (output)
        11101 -	VDD
        else    -	GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio1[4:0] = GPIO1 pin function select:
        00000 - 	Power-On-Reset Inverted (output)
        00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - 	Direct Digital Input
        00100 -	External Interrupt, falling edge (input)
        00101 - 	External Interrupt, rising edge (input)
        00110 - 	External Interrupt, state change (input)
        00111 -	ADC Analog Input
        01000 -	Reserved (Analog Test N Intput)
        01001 -	Reserved (Analog Test P Intput)
        01010 -	Direct Digital Output
        01011 -	Reserved (Digital Test Output)
        01100 -	Reserved (Analog Test N Output)
        01101 -	Reserved (Analog Test P Output)
        01110 -	Reference Voltage (output)
        01111 -	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000 -	TX Data input for direct modulation (input)
        10001 -	External Retransmission Request (input)
        10010 -	TX State (output)
        10011 -	TX FIFO Almost Full  (output)
        10100 -	RX Data (output)
        10101 -	RX State (output)
        10110 -	RX FIFO Almost Full  (output)
        10111 -	Antenna 1 Switch used for antenna diversity  (output)
        11000 -	Antenna 2 Switch used for antenna diversity  (output)
        11001 -	Valid Preamble Detected  (output)
        11010 -	Invalid Preamble Detected  (output)
        11011 -	Sync Word Detected  (output)
        11100 -	Clear Channel Assessement  (output)
        11101 -	VDD
        else    -	GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio2[4:0] = GPIO2 pin function select:
        00000 - Microcontroller Clock (output)
        00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - 	Direct Digital Input
        00100 -	External Interrupt, falling edge (input)
        00101 - 	External Interrupt, rising edge (input)
        00110 - 	External Interrupt, state change (input)
        00111 -	ADC Analog Input
        01000 -	Reserved (Analog Test N Intput)
        01001 -	Reserved (Analog Test P Intput)
        01010 -	Direct Digital Output
        01011 -	Reserved (Digital Test Output)
        01100 -	Reserved (Analog Test N Output)
        01101 -	Reserved (Analog Test P Output)
        01110 -	Reference Voltage (output)
        01111 -	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000 -	TX Data input for direct modulation (input)
        10001 -	External Retransmission Request (input)
        10010 -	TX State (output)
        10011 -	TX FIFO Almost Full  (output)
        10100 -	RX Data (output)
        10101 -	RX State (output)
        10110 -	RX FIFO Almost Full  (output)
        10111 -	Antenna 1 Switch used for antenna diversity  (output)
        11000 -	Antenna 2 Switch used for antenna diversity  (output)
        11001 -	Valid Preamble Detected  (output)
        11010 -	Invalid Preamble Detected  (output)
        11011 -	Sync Word Detected  (output)
        11100 -	Clear Channel Assessement  (output)
        11101 -	VDD
        else    -	GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcstart / adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        adcstart / adcdone = ADC Measurement Start bit. Reading this bit gives '1' if the ADC measurement cycle has been finished.
        adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
        000 -	Internal Temperature Sensor
        001 -	GPIO0, single-ended
        010 -	GPIO1, single-ended
        011 - 	GPIO2, single-ended
        100 -	GPIO0(+) - GPIO1(-), differential
        101 -	GPIO1(+) - GPIO2(-), differential
        110 -	GPIO0(+) - GPIO2(-), differential
        111 -	GND
        adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
        0X -	bandgap voltage (1.2V)
        10 -	VDD / 3
        11 - 	VDD / 2
        adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0:	adcref[0] = 1:
        FS = 0.014 * (adcgain[1:0] + 1) * VDD 	FS = 0.021 * (adcgain[1:0] + 1) * VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.</Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>
        tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
        00 -	-40oC .. 64oC (full operating range), with 0.5oC resolution (1 LSB in the 8 bit ADC)
        01 -	-40oC .. 85oC, with 1oC resolution (1 LSB in the 8 bit ADC)
        11 -	   0oC .. 85oC, with 0.5oC resolution (1 LSB in the 8 bit ADC)
        10 -	-40oF .. 216oF, with 1oF resolution (1 LSB in the 8 bit ADC)
        entsoffs = Temperature Sensor Offset to convert from K to oC.
        entstrim = Temperature Sensor Trim enable
        tstrim[3:0] = Temperature Sensor Trim value
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)</Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="wtr[3]" />
      <Bit index="4" name="wtr[2]" />
      <Bit index="3" name="wtr[1]" />
      <Bit index="2" name="wtr[0]" />
      <Bit index="1" name="wtd[1]" />
      <Bit index="0" name="wtd[0]" />
      <Description>
        wtr[3:0] = Wake Up Timer Exponent (R) value.  See formula above.
        wtd[1:0] = Wake Up Timer Exponent (D) value.  See formula above.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>wtm[15:8] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>wtm[7:0] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>wtm[15:8] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>wtm[7:0] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>ldc[7:0] = Low-Duty Cycle Mode Duration (LDC).  See formula above</Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>lbdt[4:0] = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.</Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continouosly.</Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="16" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bypdec3" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>
        bypdec3 - If set to '1' then the decimate by 3 in the RX Modem will be bypassed
        ndec_exp[2:0] = IF Filter decimation rates
        filset[3:0] = IF Filter coefficient sets ; defauts are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz
      </Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="41" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="afcgearl[2]" />
      <Bit index="1" name="afcgearl[1]" />
      <Bit index="0" name="afcgearl[0]" />
      <Description>
        enafc = AFC enable
        afcgearh[2:0] = AFC High Gear Setting
        afcgearl[2:0] = AFC Low Gear Setting
      </Description>
    </Register>
    <Register address="1E" name="AFC Timing Control" size="8" defaultVal="1C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="lgwait[2]" />
      <Bit index="1" name="lgwait[1]" />
      <Bit index="0" name="lgwait[0]" />
      <Description>
        shwait[2:0] = short wait periods after AFC correction used before preamble is detected  (unit is 2*Tbit)
        lgwait[2:0] = long wait periods after correction used after preamble detected  (unit is 2*Tbit)
      </Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="13" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="rxready" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>
        rxready = improves receiver noise immunity when in direct mode. It is recommended to set this bit after preamble is detected. When in FIFO mode this bit should be set to '0' since noise immunity is controlled automatically.
        crfast[2:0] = Clock Recovery Fast Gearshift value
        crslow[2:0] = Clock Recovery Slow Gearshift value
      </Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="30" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>
        rxosr[7:0] = Oversampling Rate, 3 LSBs are the fraction
        default = 0011 0000 = 6 clock cycles per data bit
      </Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="X" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>
        rxosr[10:8] = Oversampling Rate, upper bits

        ncoff[19:16] = NCO offset. See formula above.
      </Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="AA" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>ncoff[15:8] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>ncoff[7:0] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>crgain[10:8] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="53" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>crgain[7:0] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>rssi[7:0] = Received Signal Strength Indicator value</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>rssith[7:0] = RSSI Threshold. Interrupt is set if the RSSI value is above this threshold.</Description>
    </Register>
    <Register address="28" name="Reserved 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="X" />
      <Bit index="2" name="X" />
      <Bit index="1" name="X" />
      <Bit index="0" name="X" />
      <Description>adrssi1[7:0] = Measured RSSI value on antenna 1</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>adrssi2[7:0] = Measured RSSI value on antenna 2</Description>
    </Register>
    <Register address="2A" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description></Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="autophdet" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        enpacrx = Enable Packet RX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpacrx='1' will enable automatic packet handling in the RX path. Register 30-4D allow for various configurations of the packet structure. Setting enpacrx='0' will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
        lsbfrst = LSB First enable. The LSB of the data will be transmitted/received first if this bit is set.
        crcdonly = CRC Data Only enable When this bit is set to '1' the CRC is calculated on and check against the packet data fields only.
        autophdet = Auto Phase Detection enable. Automatic Manchester phase detection during RX if this bit is set.
        enpactx = Enable Packet TX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpactx='1' will enable automatic packet handling in the TX path. Register 30-4D allow for various configurations of the packet structure. Setting enpactx='0' will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
        encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
        crc[1:0] = CRC polynomial selection.
        00 -	CCITT
        01 -	CRC-16
        10 -	IEC-16
        11 -	Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>
        pksrch = Packet Searching. When pksrch = '1' the radio is searching for a valid packet.
        pkrx = Packet Receiving. When pkrx = '1' the radio is currently receiving a valid packet.
        pkvalid = Valid Packet Received. When a pkvalid = '1' a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
        crcerror = CRC Error.  When crcerror = '1' a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
        pktx = Packet Transmitting. When pktx = '1' the radio is currently transmitting a packet.
        pksent = Packet Sent.  A pksent  = '1' a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enbcast[1]" />
      <Bit index="6" name="enbcast[1]" />
      <Bit index="5" name="enbcast[1]" />
      <Bit index="4" name="enbcast[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>
        bcen[3:0] = Broadcast Address (FFh) Check enable.  If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
        0000 -	No broadcast address enable.
        0001 -	Broadcast address enable for header byte 0.
        0010 -	Broadcast address enable for header byte 1.
        0011 -	Broadcast address enable for header bytes 0 &amp; 1.
        0100 -
        hdch[3:0] = Received Header bytes to be checked against the Check Header bytes.  One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.
        0000 -	No Received Header check
        0001 -	Received Header check for byte 0.
        0010 -	Received Header check for bytes 1.
        0011 -	Received header check for bytes 0 &amp; 1.
        0100 -
      </Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="txhdlen[2]" />
      <Bit index="5" name="txhdlen[1]" />
      <Bit index="4" name="txhdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        hdlen[2:0] = Transmit/Receive Header Length. Length of header used if packet handler is enabled for TX (enpactx) or for RX (enpacrx). Headers are sent or received in descending order.
        000 -	NoTX header
        001 - 	Header 3
        010 - 	Header 3 and 2
        011 - 	Header 3 and 2 and 1
        100 - 	Header 3 and 2 and 1 and 0synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00 - 	Synchronization Word 3
        01 - 	Synchronization Word 3 and 2
        10 - 	Synchronization Word 3 and 2 and 1
        11 - 	Synchronization Word 3 and 2 and 1 and 0
        fixpklen = Fix Transmit/Receive Packet Length.  When fixpklen = '1' the packet length (pklen[7:0]) is not included in the packet structure. When fixpklen = '0' the packet length is included in the packet.
        prealen[8] = MSB of Preamble Length. See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="07" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register + 1 corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = '000001000'  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = '111111111' which corresponds to a 255 Bytes  Preamble.  Writing a value of 0 to this register will have the same effect as 1 and one nibble will be sent.</Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="preach[2]" />
      <Bit index="1" name="preach[1]" />
      <Bit index="0" name="preach[0]" />
      <Description>
        preath[4:0] = Number of nibbles processed during detection.
        preach[2:0] = Number of non-consecutive bit errors allowed during detection.
      </Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] - Packet Length.  The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = '00001000' corresponds to a packet length of 8 Bytes.  The maximum packet length is pklen[7:0] = '11111111', a 255 byte packet.  If a '0' is written no data bytes will be sent in the packet structure.</Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>chhd[31:24] = Check Header 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>chhd[23:16] = Check Header 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>chhd[15:8] = Check Header 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>chhd[7:0] = Check Header 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>hden[31:24] = Header Enable 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>hden[23:16] = Header Enable 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>hden[15:8] = Header Enable 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>hden[7:0] = Header Enable 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>rxhd[31:24] = Received Header 3. 4th byte of the received header.</Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>rxhd[23:16] = Received Header 2. 3rd byte of the received header.</Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>rxhd[15:8] = Received Header 1. 2nd byte of the received header.</Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>rxhd[7:0] = Received Header  0. 1st byte of the received header.</Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>rxplen[7:0] = Length byte of the received header.</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>
        atb[4:0] = Analog Test Bus.  The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
        Internal analog signals available on the Analog Test Bus:
        * atb[4:0]
        * GPIOx
        * GPIOx
        * 1
        * MixIp
        * MixIn
        * 2
        * MixQp
        * MixQn
        * 3
        * PGA_Ip
        * PGA_In
        * 4
        * PGA_QP
        * PGA_Qn
        * 5
        * ADC_vcm
        * ADC_vbn
        * 6
        * ADC_refmid
        * ADC_vbiasp
        * 7
        * ADC_vcm
        * ADC_vcmb
        * 8
        * ADC_ipoly10u
        * ADC_ref
        * 9
        * ADC_refdac_p
        * ADC_refdac_m
        * 10
        * ADC_Res1i_p
        * ADCRes1i_m
        * 11
        * ADC_Res1q_p
        * ADC_Res1q_m
        * 12
        * ADC_Res2i_p
        * ADCRes2i_m
        * 13
        * ADC_Res2q_p
        * ADC_Res2q_m
        * 14
        * ADC_Res3i_p
        * ADCRes3i_m
        * 15
        * ADC_Res3q_p
        * ADC_Res3q_m
        * 16
        * spare
        * spare
        * 17
        * ADC_RES_CAL_cap
        * ADC_RES_CAL_res
        * 18
        * ICP_Test
        * PLL_IBG_05
        * 19
        * PLL_VBG
        * VSS_VCO
        * 20
        * Vctrl_Test
        * PLL_IPTAT_05
        * 21
        * PA_vbias
        * spare
        * 22
        * DIGBG
        * DIGVFB
        * 23
        * IFBG
        * IFVFB
        * 24
        * PLLBG
        * PLLVReg
        * 25
        * IBias10u
        * IBias5u
        * 26
        * 32KRC_Ucap
        * 32KRC_Ures
        * 27
        * ADC8_VIN
        * ADC8_VDAC
        * 28
        * LBDcomp
        * LBDcompref
        * 29
        * TSBG
        * TSVtemp
        * 30
        * RFBG
        * RFVREG
        * 31
        * VCOBG
      </Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>
        ensctest = Scan Test Enable. When set to '1' then GPIO0 will be the ScanEn input.
        dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
        Internal digital signals available on the Digital Test Bus:
        * dtb[4:0]
        * GPIO0
        * Signal
        * GPIO1
        * Signal
        * GPIO2
        * Signal
        * 0
        * wkup_clk_32k
        * wake-up 32kHz clock
        * rbase_en
        * first divided clock
        * clk_base
        * timebase clock
        * 1
        * wkup_clk_32k
        * wake-up 32kHz clock
        * wake_up
        * wake-up event
        * tm1sec
        * 1 sec timebase
        * 2
        * ts_adc_en
        * aux. ADC enable
        * adc_rdy_n
        * aux. ADC conversion ready
        * adc_done
        * aux. ADC measurement done
        * 3
        * cont_lbd
        * low battery continouos mode
        * lbd_on
        * low battery ON signal
        * lbd
        * unfiltered output of LBD
        * 4
        * div_clk_g
        * gated divided clock
        * uc_clk
        * microcontroller clock
        * ckout_rcsel
        * slow clock selected
        * 5
        * en_div_sync
        * clock divider enable (sync'ed)
        * en_ckout
        * clock out enable
        * en_ckout_s
        * clock out enable (sync'ed)
        * 6
        * osc30_en
        * oscillator enable
        * osc30_bias2x
        * oscillator bias control
        * xok
        * chip ready
        * 7
        * xok
        * chip ready
        * zero_cap
        * cap. load zero
        * osc30_buff_en
        * buffer enable
        * 8
        * tsadc_needed
        * aux. ADC enable
        * ext_retran
        * ext. retransmission request
        * tx_mod_gpio
        * TX modulation inpit
        * 9
        * gpio_0_oen_n
        * GPIO0 output enable
        * gpio_0_aen
        * GPIO0 analog selection
        * gpio_0_aden
        * GPIO0 ADC input line enable
        * 10
        * int_ack1
        * interrupt acknowledge 1
        * int_ack2
        * interrupt acknowledge 2
        * int_store
        * interrupt latch closed
        * 11
        * ext_int2
        * ext. interrupt from GPIO2
        * irq_bit8
        * combined external status
        * msk_bit8
        * combined masked ext. int.
        * 12
        * sdo_aux_sel
        * SDO aux. function select
        * sdo_aux
        * SDO aux. signal
        * nirq_aux_sel
        * nIRQ aux. function select
        * 13
        * trdata_on_sdi
        * TX/RX data on SDI
        * tx_mod
        * TX modulation input
        * tx_clk_out
        * TX clock output
        * 14
        * start_full_sync
        * RC osc. full calibration start
        * start_fine_sync
        * RC osc. fine calibration start
        * xtal_req
        * crystal req. for RC osc. cal.
        * 15
        * coarse_rdy
        * RC osc. coarse cal. ready
        * fine_rdy
        * RC osc. fine cal. ready
        * xtal_req_sync
        * sync'ed crystal request
        * 16
        * vco_cal_rst_s_n
        * VCO calibration reset
        * vco_cal
        * VCO calibration is running
        * vco_cal_done
        * VCO calibration done
        * 17
        * vco_cal_en
        * VCO calibration enable
        * en_ref_cnt
        * reference counter enable
        * en_freq_cnt_s
        * frequency counter enable
        * 18
        * vco_cal_en
        * VCO calibration enable
        * pos_diff
        * positive difference to goal
        * en_freq_cnt_s
        * frequency counter enable
        * 19
        * dsm_clk_mux
        * DSM multiplexed clock
        * pll_fb_clk_tst
        * PLL feedback clock
        * pll_ref_clk_tst
        * PLL reference clock
        * 20
        * dsm[0]
        * delta-sigma output
        * dsm[1]
        * delta-sigma output
        * dsm[2]
        * delta-sigma output
        * 21
        * dsm[3]
        * delta-sigma output
        * pll_fbdiv15
        *
        * dsm_rst_s_n
        * delta-sigma reset
        * 22
        * pll_en
        * PLL enable: TUNE state
        * pllt0_ok
        * PLL initial settling OK
        * pllts_ok
        * PLL soft settling OK
        * 23
        * ch_freq_req
        * frequency change request
        * pllts_ok
        * PLL soft settling OK
        * vco_cal_done
        * VCO calibration done
        * 24
        * vco_cal_en
        * VCO calibration enable
        * pll_vbias_shunt_en
        * VCO bias shunt enable
        * prog_req
        * frequency recalculation req.
        * 25
        * bandgap_en
        * bandgap enable
        * frac_div_en
        * fractional divider enable
        * buff3_en
        * buffer3 enable
        * 26
        * pll_pfd_up
        * PFD up signal
        * pll_pfd_down
        * PFD down signal
        * pfd_up_down
        * PFD output change (XOR'ed)
        * 27
        * pll_lock_detect
        * PLL lock detect
        * pll_en
        * PLL enable: TUNE state
        * pllt0_ok
        * PLL initial settling OK
        * 28
        * pll_en
        * PLL enable: TUNE state
        * pll_lock_detect
        * PLL lock detect
        * pllts_ok
        * PLL soft settling OK
        * 29
        * pwst[0]
        * internal power state
        * pwst[1]
        * internal power state
        * pwst[2]
        * internal power state
        Internal digital signals available on the Digital Test Bus (continued from the previous page):
        * dtb[4:0]
        * GPIO0
        * Signal
        * GPIO1
        * Signal
        * GPIO2
        * Signal
        * 30
        * xok
        * chip ready: READY state
        * pll_en
        * PLL enable: TUNE state
        * tx_en
        * TX enable: TX state
        * 31
        * ts_en
        * temperature sensor enable
        * auto_tx_on
        * automatic TX ON
        * tx_off
        * TX OFF
        * 32
        * ch_freq_req
        * frequency change request
        * return_tx
        * return from TX
        * pk_sent
        * packet sent
        * 33
        * retran_req
        * retransmission request
        * tx_ffpt_store
        * TX FIFO pointer store
        * tx_ffpt_restore
        * TX FIFO pointer restore
        * 34
        * pa_on_trig
        * PA ON trigger
        * dly_5us_ok
        * 5 us delay expired
        * mod_dly_ok
        * modulator delay expired
        * 35
        * tx_shdwn
        * TX shutdown
        * ramp_start
        * modulator ramp down start
        * ramp_done
        * modulator ramp down ended
        * 36
        * pk_sent_dly
        * delayed packet sent
        * tx_shdwn_done
        * TX shutdown done
        * pa_ramp_en
        * PA ramp enable
        * 37
        * tx_en
        * TX enable: TX state
        * ldo_rf_precharge
        * RF LDO precharge
        * pa_ramp_en
        * PA ramp enable
        * 38
        * pa_on_trig
        * TX enable: TX state
        * dp_tx_en
        * packet handler (TX) enable
        * mod_en
        * modulator enable
        * 39
        * reg_wr_en
        * register write enable
        * reg_rd_en
        * register rdead enable
        * addr_inc
        * register address increment
        * 40
        * dp_tx_en
        * packet handler (TX) enable
        * data_start
        * start of TX data
        * pk_sent
        * packet has been sent
        * 41
        * data_start
        * start of TX data
        * tx_out
        * packet handler TX data out
        * pk_sent
        * packet has been sent
        * 42
        * ramp_done
        * ramp is done
        * data_start
        * start of TX data
        * pk_tx
        * packet is being transmitted
        * 43
        * tx_ffaf
        * TX FIFO almost full
        * tx_fifo_wr_en
        * TX FIFO write enable
        * tx_ffem_tst
        * internal TX FIFO empty
        * 44
        * clk_mod
        * modulator gated 10MHz clock
        * tx_clk
        * TX clock from NCO
        * rd_clk_x8
        * read clock = tx_clk / 10
        * 45
        * mod_en
        * modulator enable
        * ramp_start
        * start modulator ramping down
        * ramp_done
        * modulator ramp done
        * 46
        * data_start
        * data input start from PH
        * ook_en
        * OOK modulation enble
        * ook
        * OOK modulation
        * 47
        * prog_req
        * freq. channel update request
        * freq_err
        * wrong freq. indication
        * dsm_rst_s_n
        * dsm sync. reset
        * 48
        * mod_en
        * modulator enable
        * tx_rdy
        * TX ready
        * tx_clk
        * TX clock from NCO
        * 49
        * dp_rx_en
        * packet handler (RX) enable
        * prea_valid
        * valid preamble
        * pk_srch
        * packet is being searched
        * 50
        * pk_srch
        * packet is being searched
        * sync_ok
        * sync. word has been detected
        * rx_data
        * packet handler RX data input
        * 51
        * pk_rx
        * packet is being received
        * sync_ok
        * sync. word has been detected
        * pk_valid
        * valid packet received
        * 52
        * sync_ok
        * sync. word has been detected
        * crc_error
        * CRC error has been detected
        * hdch_error
        * header error detected
        * 53
        * direct_mode
        * direct mode
        * rx_ffaf
        * RX FIFO almost full
        * rx_fifo_rd_en
        * RX FIFO read enable
        * 54
        * bit_clk
        * bit clock
        * prea_valid
        * valid preamble
        * rx_data
        * demodulator RX data output
        * 55
        * prea_valid
        * valid preamble
        * prea_inval
        * invalid preamble
        * ant_div_sw
        * antenna switch (algorythm)
        * 56
        * sync_ok
        * sync. word has been detected
        * bit_clk
        * bit clock
        * rx_data
        * demodulator RX data output
        * 57
        * clk_demod
        * demodulator gated 30MHz clk
        * adc_lsb_i
        * ADC I channel data LSB
        * demod_tst[0]
        * demodulator test
        * 58
        * prea_valid
        * valid preamble
        * demod_tst[2]
        * demodulator test
        * demod_tst[1]
        * demodulator test
        * 59
        * agc_smp_clk
        * AGC sample clock
        * win_h_tp
        * window comparator high
        * win_l_tp
        * window comparator low dly'd
        * 60
        * agc_smp_clk
        * AGC sample clock
        * win_h_dly_tp
        * window comparator high
        * win_l_dly_tp
        * window comparator low dly'd
        * 61
        * ldc_on
        * active low duty cycle
        * pll_en
        * PLL enable: TUNE state
        * rx_en
        * RX enable: RX state
        * 62
        * ldc_on
        * active low duty cycle
        * no_sync_det
        * no sync word detected
        * prea_valid
        * valid preamble
        * 63
        * adc_en
        * ADC enable
        * adc_refdac_en
        * ADC reference DAC enable
        * adc_rst_n
        * combined ADC reset
      </Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>
        txmod[2:0] = TX Modulation Delay. The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up.  It can be set from 0 us to 28 us in 4 us steps.
        ldoramp[2:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00 -	5 us
        01 -	10 us
        10 -	15 us
        11 -	20 us
        txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00 - 	5 us
        01 - 	10 us
        10 - 	15 us
        11 - 	20 us
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="45" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>
        pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 us and 310 us, in 10 us intervals. The default plltime  corresponds to 80 us. See formula above.
        pllt0 = PLL Settling Time (TO). This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0 us and 70 us, in 10 us steps. The default pllt0 corresponds to 50 us. See fomula above.
      </Description>
    </Register>
    <Register address="54" name="Reserved 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="X" />
      <Bit index="2" name="X" />
      <Bit index="1" name="X" />
      <Bit index="0" name="X" />
      <Description></Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        adccaldone = Delta-sigma ADC Calibration Done. Reading this bit gives '1' if the calibration process has been finished.
        enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to '1' then the RC oscillator performs fine calibration in every app. 30 s.
        rccal = RC Calibration Force. If setting rccal='1' will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a '0' to '1' will initiate the calibration. This bit is cleared automatically.
        vcocaldp = VCO Calibration Double Precision enable. When this bit is set to '1' then the VCO calibration measures longer thus calibrates more precisely.
        vcocal = VCO Calibration Force.  If in Idle Mode and pllon='1', setting vcocal='1' will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        skipvco = Skip VCO Calibration. Setting skipvco='1' will skip the VCO calibration when going from the Idle state to the TX or RX state.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="preabp" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="iqswitch" />
      <Description>
        preabp = Bypass Preamble Detection.
        refclksel = Delta-sigma Reference Clock Source Selection (1: 10MHz, 0: PLL)
        refclkinv = Delta-sigma Reference Clock Inversion enable
        iqswitch = I&amp;Q Channel Switch enable.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>
        cpforceup = Charge Pump Force Up
        cpforcedn = Charge Pump Force Down
        cdconly = Charge Pump DC Offset Only
        cdcurr[2:0] = Charge Pump DC Current selection
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>
        cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        cpcorrov = Charge Pump Correction Override enable
        cpcorr[4:0] = Charge Pump Correction value
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
        d3trim[1:0] = Divider 3 Current Trim value
        d2trim[1:0] = Divider 2 Current Trim value
        d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        vcocorrov = VCO Current Correction override
        vcocorr[3:0] = VCO Current Correction value
        vcocur[1:0] = VCO Current Trim value
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>
        vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov='0' the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov='1' the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives '1' if the calibration process has been finished.
        vcocal[6:0] = VCO Calibration Results
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="vcotype" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>
        vcotype = VCO Type.
        0 - basic, constant K	1 - single varactor, changing K
        enoloop = Open Loop Mode enable
        dsmod = Delta-Sigma Modulus
        0 - 64000	1 - 65 536
        dsorder[1:0] = Delta-Sigma Order
        00 - 	0 order
        01 - 	1st order
        10 - 	2nd order
        11 - 	Mash 111
        dsrstmode = Delta-Sigma Reset Mode
        dsrst = Delta-Sigma Reset
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>
        enmix = Mixer enable override
        enlna = LNA enable override
        enpga = PGA enable override
        enpa = Power Amplifier enable override
        enbf5 = Buffer 5 enable override
        endv32 = Divider 3_2 enable override
        enbf12 = Buffer 1_2 enable override
        enmx2 = Multiplexer 2 enable override
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="enldet" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="enmx1" />
      <Description>
        ends = Delta-Sigma enable override
        enldet = Lock Detect enable (direct control, not override!)
        enmx3 = Mutiplexer 3 enable override
        enbf4 = Buffer 4 enable override
        enbf3 = Buffer 3 enable override
        enbf11 = Buffer 1_1 enable override
        enbf2 = Buffer 2 enable override
        enmx1 = Multiplexer enable override
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>
        enfrdv = Fractional Divider enable override
        endv31 = Divider 3_1 enable override
        endv2 = Divider 2 enable override
        endv1p5 = Divider 1.5 (div-by-1.5) enable override
        dvbshunt = VCO Bias Shunt disable override
        envco = VCO enable override
        encp = Charge Pump enable override
        enbg = Bandgap enable override
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>chfiladd[3:0] = Channel Filter Coefficient Look-up Table Address. The address for channel filter coefficients used in the RX path.  </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>chfilval[5:0] = Filter Coefficient Value in the look-up table addressed by the chfiladd[3:0]</Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        pwst[1:0] = Internal Power States of the chip
        00 -	low power (stand-by / sleep / sensor)
        01 -	ready
        11 -	tune
        10 -	TX
        enspor = Smart POR enable
        clkhyst = Clock Hysteresis Setting
        enbias2x = 2 times higher bias current enable
        enamp2x = 2 times higher amplification enable
        bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
        0 - output buffer is controlled by the state machine
        1 - output buffer is controlled by the enbuf bit
        enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>
        rccov = RC Oscillator Coarse Calibration Override. When rccov='0' the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov='1' the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>
        rcfov = RC Oscillator Fine Calibration Override. When rcfov='0' the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov='1' the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>
        enbias = Bias enable
        envcoldo = VCO LDO enable
        enifldo = IF LDO enable
        enrfldo = RF LDO enable
        enpllldo = PLL LDO enable
        endigldo = Digital LDO enable
        endigpwdn = Digital Power Domain Powerdown enable in Idle mode
      </Description>
    </Register>
    <Register address="66" name="Reserved 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="X" />
      <Bit index="6" name="X" />
      <Bit index="5" name="X" />
      <Bit index="4" name="X" />
      <Bit index="3" name="X" />
      <Bit index="2" name="X" />
      <Bit index="1" name="X" />
      <Bit index="0" name="X" />
      <Description></Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>
        adcrst = delta-sigma ADC reset
        enrefdac = delta-sigma ADC reference DAC enable override
        enadc = delta-sigma ADC enable override
        adctuneovr = resonator RC calibration value override enable
        adctune[3:0] = resonator RC calibration value
      </Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>
        envcm = delta-sigma ADC VCM enable override
        adcoloop = delta-sigma ADC open loop enable
        adcref[2:0] = delta-sigma ADC reference voltage
        000 -	0.5 V
        001 -	0.6 V
        010 -	0.7 V
        ...
        111 -	1.2 V
      </Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>
        agcen = Automatic Gain Control enable When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
        lnagain = LNA Gain select
        0 - min. gain = 5 dB	1 -max. gain = 25 dB
        pga[3:0] = PGA Gain Override value
        000 -	0 dB
        001 -	3 dB
        010 -	6 dB
        ...
        101 -	24 dB max.
      </Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>
        agcslow = AGC Slow Gain Increase enable. When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
        lnacomp[3:0] = LNA Gain Compensation, used for smoothing RSSI value when LNA gain is switched.
        pgath[1:0] = window comparator reference voltage adjust in the PGA
      </Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000 - 	i_coe0 (Default =d1)
        001 - 	i_coe1 (Default =d3)
        010 - 	i_coe2 (Default =d6)
        011 - 	i_coe3 (Default =d10)
        100 - 	i_coe4 (Default =d15)
        101 - 	i_coe5 (Default =d19)
        110 - 	i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>txpow[1:0] = TX Output Power.  The output power is configurable from +20 to +11dBm in ~3dB steps.  txpow[1:0]='11' corresponds to +20dBm and '00' to +11dBm.</Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="AA" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        enmaninv = Manchester Data Inversion is enabled if this bit is set.
        enmanch = Manchester Coding is enabled if this bit is set.
        enwhite = Data Whitening is enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="-" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        trclk[1:0] = TX Data Clock Configuration.
        00 -	No TX Data CLK is available (asynchronous mode)
        01 -	TX Data CLK is available via the GPIO (one of the GPIO's should be programmed as well)
        10 -	TX Data CLK is available via the SCK pin
        11 -	TX Data CLK is available via the nIRQ pin
        dtmod[1:0] = Modulation Source
        00 - 	Direct Mode using TX_Data function via the GPIO pin (one of the GPIO's should be 	programmed accordingly as well)
        01 - 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10 - 	FIFO Mode
        11 - 	PN9 (internally generated)
        eninv = Invert TX and RX Data
        modtyp[2:0] = Modulation Type
        000 -	Unmodulated carrier
        001 -	OOK
        010 -	FSK
        011 -	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="43" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>fd[7:0] = Frequency Deviation Setting. See formula above. </Description>
    </Register>
    <Register address="73" name="Frequency Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>fo[7:0] = Frequency Offset Setting. </Description>
    </Register>
    <Register address="74" name="Frequency Channel Control" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>fo[9:8] = Upper bits of the Frequency Offset Setting. fo[9] is the sign bit.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="35" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="-" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        sbsel = Side Band Select.
        hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-930MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
        fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]='00000' corresponds to the 240-250MHz Band for hbsel='0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0]='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold</Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>rxafthr[5:0] = RX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        fifod[7:0] = A write (R/W='1') to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH. A Read (R/W='0') to this address will begin a burst read of the RX FIFO, in the same manner.
      </Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="13" type="Si4031" revision="X" projectID="0" name="Tamara RevX">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>0</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>0</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="07" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>dt[4:0] = Device Type Code.  This internally hardwired code will allow the user to recognize whether this is a Transmitter, Receiver, or a Transceiver. Tamara = 00111</Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="01" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>vc[4:0] = Version Code.  Internally hardwired version code of the chip</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="0" />
      <Bit index="4" name="0" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="lockdet" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>ffovfl = TX FIFO Overflow status.
ffunfl = TX FIFO Underflow status.

freqerr = Frequency Error status. The programmed frequency is outside of the operating range. The actual frequency is saturated to the max/min value.
lockdet = Synthesizer Lock Detect status. 
cps[1:0] = Chip Power State:
00 -	Idle State
10 -	TX State</Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="0" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="0" />
      <Bit index="0" name="0" />
      <Description>ifferr = FIFO Underflow/Overflow Error.  When set to '1' the TX or RX FIFO has overflowed or underflowed.
itxffafull = TX FIFO Almost Full.  When set to '1' the TX FIFO has met its almost full threshold and needs to be transmitted.
itxffaem= TX FIFO Almost Empty.  When set to '1' the TX FIFO is almost empty and needs to be filled.

iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
ipksent = Packet Sent Interrupt. When set to'1' a valid packet has been transmitted.

When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
Bit
Status Name
Set/Clear conditions:
[7]
ifferr
Set if there is a TX FIFO Overflow or Underflow.  It is cleared only by applying FIFO reset to the TX FIFO.
[6]
itxffafull
Will be set when the number of bytes written to TX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we start transmitting and the FIFO data is read out and the number of bytes left in the FIFO is smaller or equal to the threshold).
[5]
itxffaem
Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
[4]
Not used
[3]
iext
External interrupt source
[2]
ipksent
Will go high once a packet is sent all the way through (no TX abort). This status will be cleaned if 1) We leave FIFO mode or 2) In FIFO mode we start a new transmission.
[1:0]
Not used</Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.  
ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.  
When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
Bit
Status Name
Set/Clear conditions:
[7:4]
[3]
iwut
Wake time timer interrupt. Use as an interrupt, not as a status.
[2]
ilbd
Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
[1]
ichiprdy
Chip ready goes high once we enable the xtal, Tx or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
[0]
ipor
Power on status. </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="0" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="0" />
      <Bit index="0" name="0" />
      <Description>enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
entxffafull = Enable TX FIFO Almost Full. When set to '1' the TX FIFO Almost Full interrupt will be enabled.
entxffaem = Enable TX FIFO Almost Empty. When set to '1' the TX FIFO Almost Empty interrupt will be enabled.
[4]
-
0
enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
enpksent = Enable Packet Sent. When ipksent ='1' the Packet Sense Interrupt will be enabled.
[1:0]
-
0</Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.</Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="0" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.  
enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.  
enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
txon = TX on in manual transmit mode. It is automatically cleared in FIFO mode once the packet is sent.
[2]
-
0
pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.  
xton = READY Mode (Xtal is ON).</Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="0" />
      <Bit index="1" name="0" />
      <Bit index="0" name="ffclrtx" />
      <Description>autotx = Automatic Transmission. When autotx = '1' the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.  

ffclrtx = TX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrtx='1' followed by ffclrtx= '0' will clear the contents of the TX FIFO.</Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>xtalshft = Direct control to Analog
xlc[6:0] = Tuning Capacitance for the 30MHz XTAL</Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>clkt[1:0] = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
00 - 	0 cycle
01 - 	128 cycles
10 - 	256 cycles
11 - 	512 cycles 
enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = '1' except the '111'.  
000 - 	30 MHz
001 - 	15 MHz
010 - 	10 MHz
011 - 	4 MHz
100 - 	3 MHz
101 - 	2 MHz
110 - 	1 MHz
111 -	32.768 kHz</Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>gpiodrv0[1:0] - Gpio driving capability setting
pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio0[4:0] = GPIO0pin function select:
00000 - 	Power-On-Reset (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>gpiodrv1[1:0] - Gpio driving capability setting
pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio1[4:0] = GPIO1 pin function select:
00000 - 	Power-On-Reset Inverted (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>gpiodrv2[1:0] - Gpio driving capability setting
pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio2[4:0] = GPIO2 pin function select:
00000 - Microcontroller Clock (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.</Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcstart / adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>adcstart / adcdone = ADC Measurement Start bit. Reading this bit gives '1' if the ADC measurement cycle has been finished.
adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
000 -	Internal Temperature Sensor
001 -	GPIO0, single-ended
010 -	GPIO1, single-ended
011 - 	GPIO2, single-ended
100 -	GPIO0(+) - GPIO1(-), differential
101 -	GPIO1(+) - GPIO2(-), differential
110 -	GPIO0(+) - GPIO2(-), differential
111 -	GND, ADC is disabled
adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
0X -	bandgap voltage (1.2V)
10 -	VDD / 3
11 - 	VDD / 2
adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
adcref[0] = 0:	adcref[0] = 1:
FS = 0.014 * (adcgain[1:0] + 1) * VDD 	FS = 0.021 * (adcgain[1:0] + 1) * VDD</Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.</Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
00 -	-40oC .. 64oC (full operating range), with 0.5oC resolution (1 LSB in the 8 bit ADC)
01 -	-40oC .. 85oC, with 1oC resolution (1 LSB in the 8 bit ADC)
11 -	   0oC .. 85oC, with 0.5oC resolution (1 LSB in the 8 bit ADC)
10 -	-40oF .. 216oF, with 1oF resolution (1 LSB in the 8 bit ADC)
entsoffs = Temperature Sensor Offset to convert from K to oC.
entstrim = Temperature Sensor Trim enable
tstrim[3:0] = Temperature Sensor Trim value</Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)</Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="wtr[3]" />
      <Bit index="4" name="wtr[2]" />
      <Bit index="3" name="wtr[1]" />
      <Bit index="2" name="wtr[0]" />
      <Bit index="1" name="wtd[1]" />
      <Bit index="0" name="wtd[0]" />
      <Description>wtr[3:0] = Wake Up Timer Exponent (R) value.  See formula above.
wtd[1:0] = Wake Up Timer Exponent (D) value.  See formula above.</Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>wtm[15:8] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>wtm[7:0] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>wtm[15:8] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>wtm[7:0] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>lbdt[4:0] = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.</Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continouosly.</Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="0D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="0" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>lsbfrst = LSB First enable. The LSB of the data will be transmitted/received first if this bit is set.
crcdonly = CRC Data Only enable When this bit is set to '1' the CRC is calculated on and check against the packet data fields only.
autophdet = Auto Phase Detection enable. Automatic Manchester phase detection during RX if this bit is set.
enpactx = Enable Packet TX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpactx='1' will enable automatic packet handling in the TX path. Register 30-4D allow for various configurations of the packet structure. Setting enpactx='0' will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
crc[1:0] = CRC polynomial selection.
00 -	CCITT
01 -	CRC-16
10 -	IEC-16
11 -	Biacheva</Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>pktx = Packet Transmitting. When pktx = '1' the radio is currently transmitting a packet.
pksent = Packet Sent.  A pksent  = '1' a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)</Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enbcast[1]" />
      <Bit index="6" name="enbcast[1]" />
      <Bit index="5" name="enbcast[1]" />
      <Bit index="4" name="enbcast[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>bcen[3:0] = Broadcast Address (FFh) Check enable.  If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
0000 -	No broadcast address enable.
0001 -	Broadcast address enable for header byte 0.
0010 -	Broadcast address enable for header byte 1.
0011 -	Broadcast address enable for header bytes 0 &amp; 1.
0100 -	...
hdch[3:0] = Received Header bytes to be checked against the Check Header bytes.  One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.   
0000 -	No Received Header check
0001 -	Received Header check for byte 0.  
0010 -	Received Header check for bytes 1.
0011 -	Received header check for bytes 0 &amp; 1.
0100 -	...</Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>hdlen[2:0] = Transmit Header Length. Length of header used if packet handler is enabled for TX (enpactx). Headers are transmitted in descending order.  
000 -	NoTX header
001 - 	Header 3
010 - 	Header 3 and 2
011 - 	Header 3 and 2 and 1
100 - 	Header 3 and 2 and 1 and 0synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
00 - 	Synchronization Word 3 
01 - 	Synchronization Word 3 and 2
10 - 	Synchronization Word 3 and 2 and 1
11 - 	Synchronization Word 3 and 2 and 1 and 0
fixpklen = Fix Transmit Packet Length.  When fixpklen = '1' the packet length (pklen[7:0]) is not included in the header. When fixpklen = '0' the packet length is included in the header.
prealen[8] = MSB of Preamble Length. See register Preamble Length.</Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="07" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register  corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = '000001000'  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = '111111111' which corresponds to a 255 Bytes Preamble. Writing '0' will have the same result as if writing '1', which will send one single nibble of preamble.</Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] - Packet Length.  The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = '00001000' corresponds to a packet length of 8 Bytes.  The maximum packet length is pklen[7:0] = '11111111', a 255 byte packet. Writing '0' is possible, in this case we do not send any data in the packet. During RX, if fixpklen = 1, this will specify also the Packet Length for RX mode.</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>atb[4:0] = Analog Test Bus.  The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
Internal analog signals available on the Analog Test Bus:
atb[4:0]
GPIOx
GPIOx
1
MixIp
MixIn
2
MixQp
MixQn
3
PGA_Ip
PGA_In
4
PGA_QP
PGA_Qn
5
ADC_vcm
ADC_vcmb
6
ADC_ipoly10u
ADC_ref
7
ADC_Refdac_p
ADC_Refdac_n
8
ADC_ipoly10
ADC_ipoly10
9
ADC_Res1Ip
ADC_Res1In
10
ADC_Res1Qp
ADC_Res1Qn
11
spare
spare
12
spare
spare
13
spare
spare
14
spare
spare
15
spare
spare
16
spare
spare
17
spare
spare
18
ICP_Test
PLL_IBG_05
19
PLL_VBG
VSS_VCO
20
Vctrl_Test
PLL_IPTAT_05
21
PA_vbias
spare
22
DIGBG
DIGVFB
23
IFBG
IFVFB
24
PLLBG
PLLVReg
25
IBias10u
IBias5u
26
32KRC_Ucap
32KRC_Ures
27
ADC8_VIN
ADC8_VDAC
28
LBDcomp
LBDcompref
29
TSBG
TSVtemp
30
RFBG
RFVREG
31
VCOBG
VCOVREG</Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>ensctest = Scan Test Enable. When set to '1' then GPIO0 will be the ScanEn input.
dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
Internal digital signals available on the Digital Test Bus:
dtb[4:0]
GPIO0
Signal
GPIO1
Signal
GPIO2
Signal
0
wkup_clk_32k
wake-up 32kHz clock
rbase_en
first divided clock
clk_base
timebase clock
1
wkup_clk_32k
wake-up 32kHz clock
wake_up
wake-up event
tm1sec
1 sec timebase
2
ts_adc_en
aux. ADC enable
adc_rdy_n
aux. ADC conversion ready
adc_done
aux. ADC measurement done
3
cont_lbd
low battery continouos mode
lbd_on
low battery ON signal
lbd
unfiltered output of LBD
4
div_clk_g
gated divided clock
uc_clk
microcontroller clock
ckout_rcsel
slow clock selected
5
en_div_sync
clock divider enable (sync'ed)
en_ckout
clock out enable
en_ckout_s
clock out enable (sync'ed)
6
osc30_en
oscillator enable
osc30_bias2x
oscillator bias control
xok
chip ready
7
xok
chip ready
zero_cap
cap. load zero
osc30_buff_en
buffer enable
8
tsadc_needed
aux. ADC enable
ext_retran
ext. retransmission request
tx_mod_gpio
TX modulation inpit
9
gpio_0_oen_n
GPIO0 output enable
gpio_0_aen
GPIO0 analog selection
gpio_0_aden
GPIO0 ADC input line enable
10
int_ack1
interrupt acknowledge 1
int_ack2
interrupt acknowledge 2
int_store
interrupt latch closed
11
ext_int2
ext. interrupt from GPIO2
irq_bit8
combined external status
msk_bit8
combined masked ext. int.
12
sdo_aux_sel
SDO aux. function select
sdo_aux
SDO aux. signal
nirq_aux_sel
nIRQ aux. function select
13
trdata_on_sdi
TX data on SDI
tx_mod
TX modulation input
tx_clk_out
TX clock output
14
start_full_sync
RC osc. full calibration start
start_fine_sync
RC osc. fine calibration start
xtal_req
crystal req. for RC osc. cal.
15
coarse_rdy
RC osc. coarse cal. ready
fine_rdy
RC osc. fine cal. ready
xtal_req_sync
sync'ed crystal request
16
vco_cal_rst_s_n
VCO calibration reset
vco_cal
VCO calibration is running
vco_cal_done
VCO calibration done
17
vco_cal_en
VCO calibration enable
en_ref_cnt
reference counter enable
en_freq_cnt_s
frequency counter enable
18
vco_cal_en
VCO calibration enable
pos_diff
positive difference to goal
en_freq_cnt_s
frequency counter enable
19
dsm_clk_mux
DSM multiplexed clock
pll_fb_clk_tst
PLL feedback clock
pll_ref_clk_tst
PLL reference clock
20
dsm[0]
delta-sigma output
dsm[1]
delta-sigma output
dsm[2]
delta-sigma output
21
dsm[3]
delta-sigma output
pll_fbdiv15
dsm_rst_s_n
delta-sigma reset
22
pll_en
PLL enable: TUNE state
pllt0_ok
PLL initial settling OK
pllts_ok
PLL soft settling OK
23
ch_freq_req
frequency change request
pllts_ok
PLL soft settling OK
vco_cal_done
VCO calibration done
24
vco_cal_en
VCO calibration enable
pll_vbias_shunt_en
VCO bias shunt enable
prog_req
frequency recalculation req.
25
bandgap_en
bandgap enable
frac_div_en
fractional divider enable
buff3_en
buffer3 enable
26
pll_pfd_up
PFD up signal
pll_pfd_down
PFD down signal
pfd_up_down
PFD output change (XOR'ed)
27
pll_lock_detect
PLL lock detect
pll_en
PLL enable: TUNE state
pllt0_ok
PLL initial settling OK
28
pll_en
PLL enable: TUNE state
pll_lock_detect
PLL lock detect
pllts_ok
PLL soft settling OK
29
pwst[0]
internal power state
pwst[1]
internal power state
pwst[2]
internal power state
Internal digital signals available on the Digital Test Bus (continued from the previous page):
dtb[4:0]
GPIO0
Signal
GPIO1
Signal
GPIO2
Signal
30
xok
chip ready: READY state
pll_en
PLL enable: TUNE state
tx_en
TX enable: TX state
31
ts_en
temperature sensor enable
auto_tx_on
automatic TX ON
tx_off
TX OFF
32
ch_freq_req
frequency change request
return_tx
return from TX
pk_sent
packet sent
33
retran_req
retransmission request
tx_ffpt_store
TX FIFO pointer store
tx_ffpt_restore
TX FIFO pointer restore
34
pa_on_trig
PA ON trigger
dly_5us_ok
5 us delay expired
mod_dly_ok
modulator delay expired
35
tx_shdwn
TX shutdown
ramp_start
modulator ramp down start
ramp_done
modulator ramp down ended
36
pk_sent_dly
delayed packet sent
tx_shdwn_done
TX shutdown done
pa_ramp_en
PA ramp enable
37
tx_en
TX enable: TX state
ldo_rf_precharge
RF LDO precharge
pa_ramp_en
PA ramp enable
38
pa_on_trig
TX enable: TX state
dp_tx_en
packet handler (TX) enable
mod_en
modulator enable
39
reg_wr_en
register write enable
reg_rd_en
register rdead enable
addr_inc
register address increment
40
dp_tx_en
packet handler (TX) enable
data_start
start of TX data
pk_sent
packet has been sent
41
data_start
start of TX data
tx_out
packet handler TX data out
pk_sent
packet has been sent
42
ramp_done
ramp is done
data_start
start of TX data
pk_tx
packet is being transmitted
43
tx_ffaf
TX FIFO almost full
tx_fifo_wr_en
TX FIFO write enable
tx_ffem_tst
internal TX FIFO empty
44
clk_mod
modulator gated 10MHz clock
tx_clk
TX clock from NCO
rd_clk_x8
read clock = tx_clk / 10
45
mod_en
modulator enable
ramp_start
start modulator ramping down
ramp_done
modulator ramp done
46
data_start
data input start from PH
ook_en
OOK modulation enble
ook
OOK modulation
47
prog_req
freq. channel update request
freq_err
wrong freq. indication
dsm_rst_s_n
dsm sync. reset
48
mod_en
modulator enable
tx_rdy
TX ready
tx_clk
TX clock from NCO</Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>txmod[2:0] = TX Modulation Delay. The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up.  It can be set from 0 us to 28 us in 4 us steps. This also works during PA ramp down.
ldoramp[1:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
00 -	5 us
01 -	10 us
10 -	15 us
11 -	20 us
txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up. 
00 - 	5 us
01 - 	10 us
10 - 	15 us
11 - 	20 us</Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 us and 310 us, in 10 us intervals. The default plltime  corresponds to 100 us. See formula above.
pllt0 = PLL Settling Time (TO). This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0 us and 70 us, in 10 us steps. The default pllt0 corresponds to 20 us. See fomula above.</Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to '1' then the RC oscillator performs fine calibration in every app. 30 s.
rccal = RC Calibration Force. If setting rccal='1' will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a '0' to '1' will initiate the calibration. This bit is cleared automatically.
vcocaldp = VCO Calibration Double Precision enable. When this bit is set to '1' then the VCO calibration measures longer thus calibrates more precisely.
vcocal = VCO Calibration Force.  If in Idle Mode and pllon='1', setting vcocal='1' will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
skipvco = Skip VCO Calibration. Setting skipvco='1' will skip the VCO calibration when going from the Idle state to the TX or RX state.</Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="0" />
      <Bit index="3" name="0" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="0" />
      <Description>dttype = Dithering Type: If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add +1/-1.

refclksel = Delta-sigma Reference Clock Source Selection (1: 10MHz, 0: PLL)
refclkinv = Delta-sigma Reference Clock Inversion enable 
iqswitch = I&amp;Q Channel Switch enable. </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>pfdrst = Direct control to analog.
fbdiv_rst = Direct control to analog
cpforceup = Charge Pump Force Up
cpforcedn = Charge Pump Force Down
cdconly = Charge Pump DC Offset Only
cdcurr[2:0] = Charge Pump DC Current selection</Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
cpcorrov = Charge Pump Correction Override enable
cpcorr[4:0] = Charge Pump Correction value</Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
d3trim[1:0] = Divider 3 Current Trim value
d2trim[1:0] = Divider 2 Current Trim value
d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value</Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcoboost" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>vco_boost_en = VCO Boost enable override
vcocorrov = VCO Current Correction override
vcocorr[3:0] = VCO Current Correction value
vcocur[1:0] = VCO Current Trim value</Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov='0' the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov='1' the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives '1' if the calibration process has been finished.
vcocal[6:0] = VCO Calibration Results</Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="vcotype" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>dsmdt = Enable DSM ditherting. If low, dithering is disabled.
vcotype = VCO Type.
0 - basic, constant K	1 - single varactor, changing K
enoloop = Open Loop Mode enable
dsmod = Delta-Sigma Modulus
0 - 64000	1 - 65 536
dsorder[1:0] = Delta-Sigma Order
00 - 	0 order
01 - 	1st order
10 - 	2nd order
11 - 	Mash 111
dsrstmode = Delta-Sigma Reset Mode
dsrst = Delta-Sigma Reset</Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>enpa = Power Amplifier enable override
enbf5 = Buffer 5 enable override
endv32 = Divider 3_2 enable override
enbf12 = Buffer 1_2 enable override
enmx2 = Multiplexer 2 enable override</Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="enldet" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>ends = Delta-Sigma enable override
enldet = Lock Detect enable (direct control, does not need override!)
enmx3 = Mutiplexer 3 enable override
enbf4 = Buffer 4 enable override
enbf3 = Buffer 3 enable override
enbf11 = Buffer 1_1 enable override
enbf2 = Buffer 2 enable override
pllreset = PLL reset enable override</Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>enfrdv = Fractional Divider enable override
endv31 = Divider 3_1 enable override
endv2 = Divider 2 enable override
endv1p5 = Divider 1.5 (div-by-1.5) enable override
dvbshunt = VCO Bias Shunt enable override mode.
envco = VCO enable override
encp = Charge Pump enable override
enbg = Bandgap enable override</Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>pwst[2:0] = Internal Power States of the chip
000 -	low power (stand-by / sleep / sensor)
001 -	ready
011 -	tune
010 -	TX 
010 -	RX 
clkhyst = Clock Hysteresis Setting
enbias2x = 2 times higher bias current enable
enamp2x = 2 times higher amplification enable
bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
0 - output buffer is controlled by the state machine
1 - output buffer is controlled by the enbuf bit 
enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.</Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>rccov = RC Oscillator Coarse Calibration Override. When rccov='0' the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov='1' the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>rcfov = RC Oscillator Fine Calibration Override. When rcfov='0' the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov='1' the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="0" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="0" />
      <Description>enspor = Smart POR enable
enbias = Bias enable
envcoldo = VCO LDO enable
enifldo = IF LDO enable
enrfldo = RF LDO enable
enpllldo = PLL LDO enable
endigldo = Digital LDO enable
[0]
-
0</Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="*" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>enovr = Enable Overrides (If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks).
enxtal = Xtal override enable value.
ents = temperature sensor enable.
enrc32 = 32K oscillator enable.

diglvl = digital LDO level setting</Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.   
000 - 	i_coe0 (Default =d1)
001 - 	i_coe1 (Default =d3)
010 - 	i_coe2 (Default =d6)
011 - 	i_coe3 (Default =d10)
100 - 	i_coe4 (Default =d15)
101 - 	i_coe5 (Default =d19)
110 - 	i_coe6 (Default =d20)</Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>txpow[2:0] = TX Output Power.  The output power is configurable from +13 to -8dBm in ~3dB steps.  txpow[2:0]='111' corresponds to +13dBm and '000' to -8dBm.</Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="AA" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>manppol = Manchester Preamble Polarity (will transmit a series of '1' if set, or series of '0' if reset). This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester mode is enabled.
enmaninv = Manchester Data Inversion is enabled if this bit is set.
enmanch = Manchester Coding is enabled if this bit is set.
enwhite = Data Whitening is enabled if this bit is set.</Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="*" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>trclk[1:0] = TX Data Clock Configuration. 
00 -	No TX Data CLK is available (asynchronous mode - Can only work with modulations FSK or OOK)
01 -	TX Data CLK is available via the GPIO (one of the GPIO's should be programmed as well)
10 -	TX Data CLK is available via the SCK pin
11 -	TX Data CLK is available via the nIRQ pin
dtmod[1:0] = Modulation Source
00 - 	Direct Mode using TX_Data function via the GPIO pin (one of the GPIO's should be 	programmed accordingly as well)
01 - 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
10 - 	FIFO Mode
11 - 	PN9 (internally generated)
eninv = Invert TX and RX Data

modtyp[1:0] = Modulation Type 
00 -	Unmodulated carrier
01 -	OOK
10 -	FSK
11 -	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)</Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="43" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>fd[7:0] = Frequency Deviation Setting. See formula above. </Description>
    </Register>
    <Register address="73" name="Frequency Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>fo[7:0] = Frequency Offset Setting. </Description>
    </Register>
    <Register address="74" name="Frequency Channel Control" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>fo[9:8] = Upper bits of the Frequency Offset Setting. fo[9] is the sign bit.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="35" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-960MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]='00000' corresponds to the 240-250MHz Band for hbsel='0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0]='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.  </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold</Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="0" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>fifod[7:0] = A write (W='1') to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH.</Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="25" type="Si4033" revision="B2" projectID="0" name="Tamara RevB2">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>0</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>0</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="07" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>dt[4:0] = Device Type Code.  This internally hardwired code will allow the user to recognize whether this is a Transmitter, Receiver, or a Transceiver. Tamara = 00111</Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="01" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>vc[4:0] = Version Code.  Internally hardwired version code of the chip</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="0" />
      <Bit index="4" name="0" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="lockdet" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>
        ffovfl = TX FIFO Overflow status.
        ffunfl = TX FIFO Underflow status.

        freqerr = Frequency Error status. The programmed frequency is outside of the operating range. The actual frequency is saturated to the max/min value.
        lockdet = Synthesizer Lock Detect status.
        cps[1:0] = Chip Power State:
        00 -	Idle State
        10 -	TX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="0" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="0" />
      <Bit index="0" name="0" />
      <Description>
        ifferr = FIFO Underflow/Overflow Error.  When set to '1' the TX or RX FIFO has overflowed or underflowed.
        itxffafull = TX FIFO Almost Full.  When set to '1' the TX FIFO has met its almost full threshold and needs to be transmitted.
        itxffaem= TX FIFO Almost Empty.  When set to '1' the TX FIFO is almost empty and needs to be filled.

        iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        ipksent = Packet Sent Interrupt. When set to'1' a valid packet has been transmitted.

        When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
        Bit
        Status Name
        Set/Clear conditions:
        [7]
        ifferr
        Set if there is a TX FIFO Overflow or Underflow.  It is cleared only by applying FIFO reset to the TX FIFO.
        [6]
        itxffafull
        Will be set when the number of bytes written to TX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we start transmitting and the FIFO data is read out and the number of bytes left in the FIFO is smaller or equal to the threshold).
        [5]
        itxffaem
        Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
        [4]
        Not used
        [3]
        iext
        External interrupt source
        [2]
        ipksent
        Will go high once a packet is sent all the way through (no TX abort). This status will be cleaned if 1) We leave FIFO mode or 2) In FIFO mode we start a new transmission.
        [1:0]
        Not used
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
        iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.
        ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
        ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.
        When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
        Bit
        Status Name
        Set/Clear conditions:
        [7:4]
        [3]
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        [2]
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        [1]
        ichiprdy
        Chip ready goes high once we enable the xtal, Tx or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        [0]
        ipor
        Power on status.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="0" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="0" />
      <Bit index="0" name="0" />
      <Description>
        enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
        entxffafull = Enable TX FIFO Almost Full. When set to '1' the TX FIFO Almost Full interrupt will be enabled.
        entxffaem = Enable TX FIFO Almost Empty. When set to '1' the TX FIFO Almost Empty interrupt will be enabled.
        [4]
        -
        0
        enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
        enpksent = Enable Packet Sent. When ipksent ='1' the Packet Sense Interrupt will be enabled.
        [1:0]
        -
        0
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
        enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
        enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
        enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="0" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.
        enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.
        enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
        txon = TX on in manual transmit mode. It is automatically cleared in FIFO mode once the packet is sent.
        [2]
        -
        0
        pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        xton = READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="0" />
      <Bit index="1" name="0" />
      <Bit index="0" name="ffclrtx" />
      <Description>
        autotx = Automatic Transmission. When autotx = '1' the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.

        ffclrtx = TX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrtx='1' followed by ffclrtx= '0' will clear the contents of the TX FIFO.
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>
        xtalshft = Direct control to Analog
        xlc[6:0] = Tuning Capacitance for the 30MHz XTAL
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        clkt[1:0] = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00 - 	0 cycle
        01 - 	128 cycles
        10 - 	256 cycles
        11 - 	512 cycles
        enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = '1' except the '111'.
        000 - 	30 MHz
        001 - 	15 MHz
        010 - 	10 MHz
        011 - 	4 MHz
        100 - 	3 MHz
        101 - 	2 MHz
        110 - 	1 MHz
        111 -	32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        gpiodrv0[1:0] - Gpio driving capability setting
        pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio0[4:0] = GPIO0pin function select:
        00000 - 	Power-On-Reset (output)
        00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - 	Direct Digital Input
        00100 -	External Interrupt, falling edge (input)
        00101 - 	External Interrupt, rising edge (input)
        00110 - 	External Interrupt, state change (input)
        00111 -	ADC Analog Input
        01000 -	Reserved (Analog Test N Intput)
        01001 -	Reserved (Analog Test P Intput)
        01010 -	Direct Digital Output
        01011 -	Reserved (Digital Test Output)
        01100 -	Reserved (Analog Test N Output)
        01101 -	Reserved (Analog Test P Output)
        01110 -	Reference Voltage (output)
        01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000 -	TX Data input for direct modulation (input)
        10001 -	External Retransmission Request (input)
        10010 -	TX State (output)
        10011 -	TX FIFO Almost Full  (output)
        10100 -	RX Data (output)
        10101 -	RX State (output)
        10110 -	RX FIFO Almost Full  (output)
        10111 -	Antenna 1 Switch used for antenna diversity  (output)
        11000 -	Antenna 2 Switch used for antenna diversity  (output)
        11001 -	Valid Preamble Detected  (output)
        11010 -	Invalid Preamble Detected  (output)
        11011 -	Sync Word Detected  (output)
        11100 -	Clear Channel Assessement  (output)
        11101 -	VDD
        else    -	GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        gpiodrv1[1:0] - Gpio driving capability setting
        pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio1[4:0] = GPIO1 pin function select:
        00000 - 	Power-On-Reset Inverted (output)
        00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - 	Direct Digital Input
        00100 -	External Interrupt, falling edge (input)
        00101 - 	External Interrupt, rising edge (input)
        00110 - 	External Interrupt, state change (input)
        00111 -	ADC Analog Input
        01000 -	Reserved (Analog Test N Intput)
        01001 -	Reserved (Analog Test P Intput)
        01010 -	Direct Digital Output
        01011 -	Reserved (Digital Test Output)
        01100 -	Reserved (Analog Test N Output)
        01101 -	Reserved (Analog Test P Output)
        01110 -	Reference Voltage (output)
        01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000 -	TX Data input for direct modulation (input)
        10001 -	External Retransmission Request (input)
        10010 -	TX State (output)
        10011 -	TX FIFO Almost Full  (output)
        10100 -	RX Data (output)
        10101 -	RX State (output)
        10110 -	RX FIFO Almost Full  (output)
        10111 -	Antenna 1 Switch used for antenna diversity  (output)
        11000 -	Antenna 2 Switch used for antenna diversity  (output)
        11001 -	Valid Preamble Detected  (output)
        11010 -	Invalid Preamble Detected  (output)
        11011 -	Sync Word Detected  (output)
        11100 -	Clear Channel Assessement  (output)
        11101 -	VDD
        else    -	GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        gpiodrv2[1:0] - Gpio driving capability setting
        pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio2[4:0] = GPIO2 pin function select:
        00000 - Microcontroller Clock (output)
        00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - 	Direct Digital Input
        00100 -	External Interrupt, falling edge (input)
        00101 - 	External Interrupt, rising edge (input)
        00110 - 	External Interrupt, state change (input)
        00111 -	ADC Analog Input
        01000 -	Reserved (Analog Test N Intput)
        01001 -	Reserved (Analog Test P Intput)
        01010 -	Direct Digital Output
        01011 -	Reserved (Digital Test Output)
        01100 -	Reserved (Analog Test N Output)
        01101 -	Reserved (Analog Test P Output)
        01110 -	Reference Voltage (output)
        01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000 -	TX Data input for direct modulation (input)
        10001 -	External Retransmission Request (input)
        10010 -	TX State (output)
        10011 -	TX FIFO Almost Full  (output)
        10100 -	RX Data (output)
        10101 -	RX State (output)
        10110 -	RX FIFO Almost Full  (output)
        10111 -	Antenna 1 Switch used for antenna diversity  (output)
        11000 -	Antenna 2 Switch used for antenna diversity  (output)
        11001 -	Valid Preamble Detected  (output)
        11010 -	Invalid Preamble Detected  (output)
        11011 -	Sync Word Detected  (output)
        11100 -	Clear Channel Assessement  (output)
        11101 -	VDD
        else    -	GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcstart / adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        adcstart / adcdone = ADC Measurement Start bit. Reading this bit gives '1' if the ADC measurement cycle has been finished.
        adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
        000 -	Internal Temperature Sensor
        001 -	GPIO0, single-ended
        010 -	GPIO1, single-ended
        011 - 	GPIO2, single-ended
        100 -	GPIO0(+) - GPIO1(-), differential
        101 -	GPIO1(+) - GPIO2(-), differential
        110 -	GPIO0(+) - GPIO2(-), differential
        111 -	GND, ADC is disabled
        adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
        0X -	bandgap voltage (1.2V)
        10 -	VDD / 3
        11 - 	VDD / 2
        adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0:	adcref[0] = 1:
        FS = 0.014 * (adcgain[1:0] + 1) * VDD 	FS = 0.021 * (adcgain[1:0] + 1) * VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.</Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>
        tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
        00 -	-40oC .. 64oC (full operating range), with 0.5oC resolution (1 LSB in the 8 bit ADC)
        01 -	-40oC .. 85oC, with 1oC resolution (1 LSB in the 8 bit ADC)
        11 -	   0oC .. 85oC, with 0.5oC resolution (1 LSB in the 8 bit ADC)
        10 -	-40oF .. 216oF, with 1oF resolution (1 LSB in the 8 bit ADC)
        entsoffs = Temperature Sensor Offset to convert from K to oC.
        entstrim = Temperature Sensor Trim enable
        tstrim[3:0] = Temperature Sensor Trim value
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)</Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="wtr[3]" />
      <Bit index="4" name="wtr[2]" />
      <Bit index="3" name="wtr[1]" />
      <Bit index="2" name="wtr[0]" />
      <Bit index="1" name="wtd[1]" />
      <Bit index="0" name="wtd[0]" />
      <Description>
        wtr[3:0] = Wake Up Timer Exponent (R) value.  See formula above.
        wtd[1:0] = Wake Up Timer Exponent (D) value.  See formula above.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>wtm[15:8] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>wtm[7:0] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>wtm[15:8] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>wtm[7:0] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>lbdt[4:0] = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.</Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continouosly.</Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="0D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="0" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        lsbfrst = LSB First enable. The LSB of the data will be transmitted/received first if this bit is set.
        crcdonly = CRC Data Only enable When this bit is set to '1' the CRC is calculated on and check against the packet data fields only.
        autophdet = Auto Phase Detection enable. Automatic Manchester phase detection during RX if this bit is set.
        enpactx = Enable Packet TX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpactx='1' will enable automatic packet handling in the TX path. Register 30-4D allow for various configurations of the packet structure. Setting enpactx='0' will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
        encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
        crc[1:0] = CRC polynomial selection.
        00 -	CCITT
        01 -	CRC-16
        10 -	IEC-16
        11 -	Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>
        pktx = Packet Transmitting. When pktx = '1' the radio is currently transmitting a packet.
        pksent = Packet Sent.  A pksent  = '1' a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enbcast[1]" />
      <Bit index="6" name="enbcast[1]" />
      <Bit index="5" name="enbcast[1]" />
      <Bit index="4" name="enbcast[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>
        bcen[3:0] = Broadcast Address (FFh) Check enable.  If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
        0000 -	No broadcast address enable.
        0001 -	Broadcast address enable for header byte 0.
        0010 -	Broadcast address enable for header byte 1.
        0011 -	Broadcast address enable for header bytes 0 &amp; 1.
        0100 -	...
        hdch[3:0] = Received Header bytes to be checked against the Check Header bytes.  One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.
        0000 -	No Received Header check
        0001 -	Received Header check for byte 0.
        0010 -	Received Header check for bytes 1.
        0011 -	Received header check for bytes 0 &amp; 1.
        0100 -	...
      </Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        hdlen[2:0] = Transmit Header Length. Length of header used if packet handler is enabled for TX (enpactx). Headers are transmitted in descending order.
        000 -	NoTX header
        001 - 	Header 3
        010 - 	Header 3 and 2
        011 - 	Header 3 and 2 and 1
        100 - 	Header 3 and 2 and 1 and 0synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00 - 	Synchronization Word 3
        01 - 	Synchronization Word 3 and 2
        10 - 	Synchronization Word 3 and 2 and 1
        11 - 	Synchronization Word 3 and 2 and 1 and 0
        fixpklen = Fix Transmit Packet Length.  When fixpklen = '1' the packet length (pklen[7:0]) is not included in the header. When fixpklen = '0' the packet length is included in the header.
        prealen[8] = MSB of Preamble Length. See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="07" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register  corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = '000001000'  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = '111111111' which corresponds to a 255 Bytes Preamble. Writing '0' will have the same result as if writing '1', which will send one single nibble of preamble.</Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] - Packet Length.  The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = '00001000' corresponds to a packet length of 8 Bytes.  The maximum packet length is pklen[7:0] = '11111111', a 255 byte packet. Writing '0' is possible, in this case we do not send any data in the packet. During RX, if fixpklen = 1, this will specify also the Packet Length for RX mode.</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>
        atb[4:0] = Analog Test Bus.  The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
        Internal analog signals available on the Analog Test Bus:
        atb[4:0]
        GPIOx
        GPIOx
        1
        MixIp
        MixIn
        2
        MixQp
        MixQn
        3
        PGA_Ip
        PGA_In
        4
        PGA_QP
        PGA_Qn
        5
        ADC_vcm
        ADC_vcmb
        6
        ADC_ipoly10u
        ADC_ref
        7
        ADC_Refdac_p
        ADC_Refdac_n
        8
        ADC_ipoly10
        ADC_ipoly10
        9
        ADC_Res1Ip
        ADC_Res1In
        10
        ADC_Res1Qp
        ADC_Res1Qn
        11
        spare
        spare
        12
        spare
        spare
        13
        spare
        spare
        14
        spare
        spare
        15
        spare
        spare
        16
        spare
        spare
        17
        spare
        spare
        18
        ICP_Test
        PLL_IBG_05
        19
        PLL_VBG
        VSS_VCO
        20
        Vctrl_Test
        PLL_IPTAT_05
        21
        PA_vbias
        spare
        22
        DIGBG
        DIGVFB
        23
        IFBG
        IFVFB
        24
        PLLBG
        PLLVReg
        25
        IBias10u
        IBias5u
        26
        32KRC_Ucap
        32KRC_Ures
        27
        ADC8_VIN
        ADC8_VDAC
        28
        LBDcomp
        LBDcompref
        29
        TSBG
        TSVtemp
        30
        RFBG
        RFVREG
        31
        VCOBG
        VCOVREG
      </Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>
        ensctest = Scan Test Enable. When set to '1' then GPIO0 will be the ScanEn input.
        dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
        Internal digital signals available on the Digital Test Bus:
        dtb[4:0]
        GPIO0
        Signal
        GPIO1
        Signal
        GPIO2
        Signal
        0
        wkup_clk_32k
        wake-up 32kHz clock
        rbase_en
        first divided clock
        clk_base
        timebase clock
        1
        wkup_clk_32k
        wake-up 32kHz clock
        wake_up
        wake-up event
        tm1sec
        1 sec timebase
        2
        ts_adc_en
        aux. ADC enable
        adc_rdy_n
        aux. ADC conversion ready
        adc_done
        aux. ADC measurement done
        3
        cont_lbd
        low battery continouos mode
        lbd_on
        low battery ON signal
        lbd
        unfiltered output of LBD
        4
        div_clk_g
        gated divided clock
        uc_clk
        microcontroller clock
        ckout_rcsel
        slow clock selected
        5
        en_div_sync
        clock divider enable (sync'ed)
        en_ckout
        clock out enable
        en_ckout_s
        clock out enable (sync'ed)
        6
        osc30_en
        oscillator enable
        osc30_bias2x
        oscillator bias control
        xok
        chip ready
        7
        xok
        chip ready
        zero_cap
        cap. load zero
        osc30_buff_en
        buffer enable
        8
        tsadc_needed
        aux. ADC enable
        ext_retran
        ext. retransmission request
        tx_mod_gpio
        TX modulation inpit
        9
        gpio_0_oen_n
        GPIO0 output enable
        gpio_0_aen
        GPIO0 analog selection
        gpio_0_aden
        GPIO0 ADC input line enable
        10
        int_ack1
        interrupt acknowledge 1
        int_ack2
        interrupt acknowledge 2
        int_store
        interrupt latch closed
        11
        ext_int2
        ext. interrupt from GPIO2
        irq_bit8
        combined external status
        msk_bit8
        combined masked ext. int.
        12
        sdo_aux_sel
        SDO aux. function select
        sdo_aux
        SDO aux. signal
        nirq_aux_sel
        nIRQ aux. function select
        13
        trdata_on_sdi
        TX data on SDI
        tx_mod
        TX modulation input
        tx_clk_out
        TX clock output
        14
        start_full_sync
        RC osc. full calibration start
        start_fine_sync
        RC osc. fine calibration start
        xtal_req
        crystal req. for RC osc. cal.
        15
        coarse_rdy
        RC osc. coarse cal. ready
        fine_rdy
        RC osc. fine cal. ready
        xtal_req_sync
        sync'ed crystal request
        16
        vco_cal_rst_s_n
        VCO calibration reset
        vco_cal
        VCO calibration is running
        vco_cal_done
        VCO calibration done
        17
        vco_cal_en
        VCO calibration enable
        en_ref_cnt
        reference counter enable
        en_freq_cnt_s
        frequency counter enable
        18
        vco_cal_en
        VCO calibration enable
        pos_diff
        positive difference to goal
        en_freq_cnt_s
        frequency counter enable
        19
        dsm_clk_mux
        DSM multiplexed clock
        pll_fb_clk_tst
        PLL feedback clock
        pll_ref_clk_tst
        PLL reference clock
        20
        dsm[0]
        delta-sigma output
        dsm[1]
        delta-sigma output
        dsm[2]
        delta-sigma output
        21
        dsm[3]
        delta-sigma output
        pll_fbdiv15
        dsm_rst_s_n
        delta-sigma reset
        22
        pll_en
        PLL enable: TUNE state
        pllt0_ok
        PLL initial settling OK
        pllts_ok
        PLL soft settling OK
        23
        ch_freq_req
        frequency change request
        pllts_ok
        PLL soft settling OK
        vco_cal_done
        VCO calibration done
        24
        vco_cal_en
        VCO calibration enable
        pll_vbias_shunt_en
        VCO bias shunt enable
        prog_req
        frequency recalculation req.
        25
        bandgap_en
        bandgap enable
        frac_div_en
        fractional divider enable
        buff3_en
        buffer3 enable
        26
        pll_pfd_up
        PFD up signal
        pll_pfd_down
        PFD down signal
        pfd_up_down
        PFD output change (XOR'ed)
        27
        pll_lock_detect
        PLL lock detect
        pll_en
        PLL enable: TUNE state
        pllt0_ok
        PLL initial settling OK
        28
        pll_en
        PLL enable: TUNE state
        pll_lock_detect
        PLL lock detect
        pllts_ok
        PLL soft settling OK
        29
        pwst[0]
        internal power state
        pwst[1]
        internal power state
        pwst[2]
        internal power state
        Internal digital signals available on the Digital Test Bus (continued from the previous page):
        dtb[4:0]
        GPIO0
        Signal
        GPIO1
        Signal
        GPIO2
        Signal
        30
        xok
        chip ready: READY state
        pll_en
        PLL enable: TUNE state
        tx_en
        TX enable: TX state
        31
        ts_en
        temperature sensor enable
        auto_tx_on
        automatic TX ON
        tx_off
        TX OFF
        32
        ch_freq_req
        frequency change request
        return_tx
        return from TX
        pk_sent
        packet sent
        33
        retran_req
        retransmission request
        tx_ffpt_store
        TX FIFO pointer store
        tx_ffpt_restore
        TX FIFO pointer restore
        34
        pa_on_trig
        PA ON trigger
        dly_5us_ok
        5 us delay expired
        mod_dly_ok
        modulator delay expired
        35
        tx_shdwn
        TX shutdown
        ramp_start
        modulator ramp down start
        ramp_done
        modulator ramp down ended
        36
        pk_sent_dly
        delayed packet sent
        tx_shdwn_done
        TX shutdown done
        pa_ramp_en
        PA ramp enable
        37
        tx_en
        TX enable: TX state
        ldo_rf_precharge
        RF LDO precharge
        pa_ramp_en
        PA ramp enable
        38
        pa_on_trig
        TX enable: TX state
        dp_tx_en
        packet handler (TX) enable
        mod_en
        modulator enable
        39
        reg_wr_en
        register write enable
        reg_rd_en
        register rdead enable
        addr_inc
        register address increment
        40
        dp_tx_en
        packet handler (TX) enable
        data_start
        start of TX data
        pk_sent
        packet has been sent
        41
        data_start
        start of TX data
        tx_out
        packet handler TX data out
        pk_sent
        packet has been sent
        42
        ramp_done
        ramp is done
        data_start
        start of TX data
        pk_tx
        packet is being transmitted
        43
        tx_ffaf
        TX FIFO almost full
        tx_fifo_wr_en
        TX FIFO write enable
        tx_ffem_tst
        internal TX FIFO empty
        44
        clk_mod
        modulator gated 10MHz clock
        tx_clk
        TX clock from NCO
        rd_clk_x8
        read clock = tx_clk / 10
        45
        mod_en
        modulator enable
        ramp_start
        start modulator ramping down
        ramp_done
        modulator ramp done
        46
        data_start
        data input start from PH
        ook_en
        OOK modulation enble
        ook
        OOK modulation
        47
        prog_req
        freq. channel update request
        freq_err
        wrong freq. indication
        dsm_rst_s_n
        dsm sync. reset
        48
        mod_en
        modulator enable
        tx_rdy
        TX ready
        tx_clk
        TX clock from NCO
      </Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>
        txmod[2:0] = TX Modulation Delay. The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up.  It can be set from 0 us to 28 us in 4 us steps. This also works during PA ramp down.
        ldoramp[1:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00 -	5 us
        01 -	10 us
        10 -	15 us
        11 -	20 us
        txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00 - 	5 us
        01 - 	10 us
        10 - 	15 us
        11 - 	20 us
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>
        pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 us and 310 us, in 10 us intervals. The default plltime  corresponds to 100 us. See formula above.
        pllt0 = PLL Settling Time (TO). This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0 us and 70 us, in 10 us steps. The default pllt0 corresponds to 20 us. See fomula above.
      </Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to '1' then the RC oscillator performs fine calibration in every app. 30 s.
        rccal = RC Calibration Force. If setting rccal='1' will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a '0' to '1' will initiate the calibration. This bit is cleared automatically.
        vcocaldp = VCO Calibration Double Precision enable. When this bit is set to '1' then the VCO calibration measures longer thus calibrates more precisely.
        vcocal = VCO Calibration Force.  If in Idle Mode and pllon='1', setting vcocal='1' will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        skipvco = Skip VCO Calibration. Setting skipvco='1' will skip the VCO calibration when going from the Idle state to the TX or RX state.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="0" />
      <Bit index="3" name="0" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="0" />
      <Description>
        dttype = Dithering Type: If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add +1/-1.

        refclksel = Delta-sigma Reference Clock Source Selection (1: 10MHz, 0: PLL)
        refclkinv = Delta-sigma Reference Clock Inversion enable
        iqswitch = I&amp;Q Channel Switch enable.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>
        pfdrst = Direct control to analog.
        fbdiv_rst = Direct control to analog
        cpforceup = Charge Pump Force Up
        cpforcedn = Charge Pump Force Down
        cdconly = Charge Pump DC Offset Only
        cdcurr[2:0] = Charge Pump DC Current selection
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>
        cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        cpcorrov = Charge Pump Correction Override enable
        cpcorr[4:0] = Charge Pump Correction value
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
        d3trim[1:0] = Divider 3 Current Trim value
        d2trim[1:0] = Divider 2 Current Trim value
        d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcoboost" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        vco_boost_en = VCO Boost enable override
        vcocorrov = VCO Current Correction override
        vcocorr[3:0] = VCO Current Correction value
        vcocur[1:0] = VCO Current Trim value
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>
        vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov='0' the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov='1' the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives '1' if the calibration process has been finished.
        vcocal[6:0] = VCO Calibration Results
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="vcotype" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>
        dsmdt = Enable DSM ditherting. If low, dithering is disabled.
        vcotype = VCO Type.
        0 - basic, constant K	1 - single varactor, changing K
        enoloop = Open Loop Mode enable
        dsmod = Delta-Sigma Modulus
        0 - 64000	1 - 65 536
        dsorder[1:0] = Delta-Sigma Order
        00 - 	0 order
        01 - 	1st order
        10 - 	2nd order
        11 - 	Mash 111
        dsrstmode = Delta-Sigma Reset Mode
        dsrst = Delta-Sigma Reset
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>
        enpa = Power Amplifier enable override
        enbf5 = Buffer 5 enable override
        endv32 = Divider 3_2 enable override
        enbf12 = Buffer 1_2 enable override
        enmx2 = Multiplexer 2 enable override
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="enldet" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>
        ends = Delta-Sigma enable override
        enldet = Lock Detect enable (direct control, does not need override!)
        enmx3 = Mutiplexer 3 enable override
        enbf4 = Buffer 4 enable override
        enbf3 = Buffer 3 enable override
        enbf11 = Buffer 1_1 enable override
        enbf2 = Buffer 2 enable override
        pllreset = PLL reset enable override
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>
        enfrdv = Fractional Divider enable override
        endv31 = Divider 3_1 enable override
        endv2 = Divider 2 enable override
        endv1p5 = Divider 1.5 (div-by-1.5) enable override
        dvbshunt = VCO Bias Shunt enable override mode.
        envco = VCO enable override
        encp = Charge Pump enable override
        enbg = Bandgap enable override
      </Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        pwst[2:0] = Internal Power States of the chip
        000 -	low power (stand-by / sleep / sensor)
        001 -	ready
        011 -	tune
        010 -	TX
        010 -	RX
        clkhyst = Clock Hysteresis Setting
        enbias2x = 2 times higher bias current enable
        enamp2x = 2 times higher amplification enable
        bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
        0 - output buffer is controlled by the state machine
        1 - output buffer is controlled by the enbuf bit
        enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>
        rccov = RC Oscillator Coarse Calibration Override. When rccov='0' the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov='1' the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>
        rcfov = RC Oscillator Fine Calibration Override. When rcfov='0' the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov='1' the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="0" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="0" />
      <Description>
        enspor = Smart POR enable
        enbias = Bias enable
        envcoldo = VCO LDO enable
        enifldo = IF LDO enable
        enrfldo = RF LDO enable
        enpllldo = PLL LDO enable
        endigldo = Digital LDO enable
        [0]
        -
        0
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="*" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>
        enovr = Enable Overrides (If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks).
        enxtal = Xtal override enable value.
        ents = temperature sensor enable.
        enrc32 = 32K oscillator enable.

        diglvl = digital LDO level setting
      </Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000 - 	i_coe0 (Default =d1)
        001 - 	i_coe1 (Default =d3)
        010 - 	i_coe2 (Default =d6)
        011 - 	i_coe3 (Default =d10)
        100 - 	i_coe4 (Default =d15)
        101 - 	i_coe5 (Default =d19)
        110 - 	i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>txpow[2:0] = TX Output Power.  The output power is configurable from +13 to -8dBm in ~3dB steps.  txpow[2:0]='111' corresponds to +13dBm and '000' to -8dBm.</Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="AA" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        manppol = Manchester Preamble Polarity (will transmit a series of '1' if set, or series of '0' if reset). This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester mode is enabled.
        enmaninv = Manchester Data Inversion is enabled if this bit is set.
        enmanch = Manchester Coding is enabled if this bit is set.
        enwhite = Data Whitening is enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="*" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        trclk[1:0] = TX Data Clock Configuration.
        00 -	No TX Data CLK is available (asynchronous mode - Can only work with modulations FSK or OOK)
        01 -	TX Data CLK is available via the GPIO (one of the GPIO's should be programmed as well)
        10 -	TX Data CLK is available via the SCK pin
        11 -	TX Data CLK is available via the nIRQ pin
        dtmod[1:0] = Modulation Source
        00 - 	Direct Mode using TX_Data function via the GPIO pin (one of the GPIO's should be 	programmed accordingly as well)
        01 - 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10 - 	FIFO Mode
        11 - 	PN9 (internally generated)
        eninv = Invert TX and RX Data

        modtyp[1:0] = Modulation Type
        00 -	Unmodulated carrier
        01 -	OOK
        10 -	FSK
        11 -	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="43" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>fd[7:0] = Frequency Deviation Setting. See formula above. </Description>
    </Register>
    <Register address="73" name="Frequency Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>fo[7:0] = Frequency Offset Setting. </Description>
    </Register>
    <Register address="74" name="Frequency Channel Control" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>fo[9:8] = Upper bits of the Frequency Offset Setting. fo[9] is the sign bit.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="35" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-960MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
        fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]='00000' corresponds to the 240-250MHz Band for hbsel='0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0]='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold</Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="0" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>fifod[7:0] = A write (W='1') to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH.</Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="14" type="Si4432" revision="V2" projectID="0" name="Ara RevV">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>dt[4:0] = Device Type Code.  This internally hardwired code will allow the user to recognize whether this is a Transmitter, Receiver, or a Transceiver.  Ara = 01000/ Tamara = 00111</Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="01" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>vc[4:0] = Version Code.  Internally hardwired version code of the chip</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="lockdet" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>ffovfl = RX/TX FIFO Overflow status.
ffunfl = RX/TX FIFO Underflow status.
rxffem = RX FIFO Empty status.
headerr = Header Error status. The actual received packet has a header check error.
freqerr = Frequency Error status. The programmed frequency is outside of the operating range. The actual frequency is saturated to the max/min value.
lockdet = Synthesizer Lock Detect status. 
cps[1:0] = Chip Power State:
00 -	Idle State
01 -	RX State
10 -	TX State</Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>ifferr = FIFO Underflow/Overflow Error.  When set to '1' the TX or RX FIFO has overflowed or underflowed.
itxffafull = TX FIFO Almost Full.  When set to '1' the TX FIFO has met its almost full threshold and needs to be transmitted.
itxffaem= TX FIFO Almost Empty.  When set to '1' the TX FIFO is almost empty and needs to be filled.
irxffafull = RX FIFO Almost Full.  When set to '1' the RX FIFO has met its almost full threshold and needs to be read by the microcontroller
iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
ipksent = Packet Sent Interrupt. When set to'1' a valid packet has been transmitted.
ipkvalid =  Valid Packet Received. When set to '1' a valid packet has been received.
icrcerror = CRC Error. When set to '1' the cyclic redundancy check is failed.  
When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
Bit
Status Name
Set/Clear conditions:
[7]
ifferr
Set if there is a Tx or RX FIFO Overflow or Underflow.  It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
[6]
itxffafull
Will be set when the number of bytes written to TX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we start transmitting and the FIFO data is read out and the number of bytes left in the FIFO is smaller or equal to the threshold).
[5]
itxffaem
Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
[4]
irxffafull
Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we read enough data from RX FIFO so that the number of data bytes not yet read is below the Almost Full threshold.
[3]
iext
External interrupt source
[2]
ipksent
Will go high once a packet is sent all the way through (no TX abort). This status will be cleaned if 1) We leave FIFO mode or 2) In FIFO mode we start a new transmission.
[1]
ipkvalid
Goes high once a packet is fully received (no RX abort). It is automatically cleaned once we receive and acknowledge the Sync Word for the next packet.
[0]
icrcerror
Goes High once the CRC computed during RX differs from the CRC sent in the packet by the TX. It is cleaned once we start receiving new data in the next packet.</Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
ipreaval = Valid Preamble Detected. When a preamble is detected this bit will be set to 1.
ipreainval = Invalid Preamble Detected. When the preamble is not found within a period of time after the RX is enabled, this bit will be set to 1.
irssi = RSSI. When RSSI level exceeds the programmed thershold this bit will be set to 1.
iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.  
ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.  
When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
Bit
Status Name
Set/Clear conditions:
[7]
iswdet
Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
[6]
ipreaval
Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
[5]
ipreainval
Self cleaning, user should use this as an interrupt source rather than a status.
[4]
irssi
Should remain high as long as the RSSI value is above programmed threshold level
[3]
iwut
Wake time timer interrupt. Use as an interrupt, not as a status.
[2]
ilbd
Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
[1]
ichiprdy
Chip ready goes high once we enable the xtal, Tx or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
[0]
ipor
Power on status. </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
entxffafull = Enable TX FIFO Almost Full. When set to '1' the TX FIFO Almost Full interrupt will be enabled.
entxffaem = Enable TX FIFO Almost Empty. When set to '1' the TX FIFO Almost Empty interrupt will be enabled.
enrxffafull = Enable RX FIFO Almost Full. When set to '1' the RX FIFO Almost Full interrupt will be enabled.
enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
enpksent = Enable Packet Sent. When ipksent ='1' the Packet Sense Interrupt will be enabled.
enpkvalid = Enable Valid Packet Received. When ipkvalid = '1' the Valid Packet Received Interrupt will be  enabled
encrcerror = Enable CRC Error. When set to '1' the CRC Error  interrupt will be enabled.</Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>enswdet = Enable Sync Word Detected. When mpreadet ='1' the Preamble Detected Interrupt will be enabled.
enpreaval = Enable Valid Preamble Detected. When mpreadet ='1' the Valid Preamble Detected Interrupt will be enabled.
enpreainval = Enable Invalid Preamble Detected. When mpreadet ='1' the Invalid Preamble Detected Interrupt will be enabled.
enrssi = Enable RSSI. When set to '1' the RSSI Interrupt will be  enabled.
enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.</Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.  
enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.  
enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
txon = TX on in manual transmit mode. It is automatically cleared in FIFO mode once the packet is sent.
rxon = RX on in manual receiver mode. It is automatically cleared if Multiple Packets config. is disabled and a valid packet received.
pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.  
xton = READY Mode (Xtal is ON).</Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="ffclrtx" />
      <Description>antdiv[2:0] = Enable Antenna Diversity. The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
	RX/TX state	non RX/TX state
	GPIO Ant1	GPIO Ant2	GPIO Ant1	GPIO Ant2
000 - 	1	0	0	0
001 -	0	1	0	0
010 - 	1	0	1	1
011 -	0	1	1	1
100 -	antenna diversity algorythm	0	0
101 - 	antenna diversity algorythm	1	1 
110 -	ant. div. algorythm in beacon mode	0	0
111 - 	ant. div. algorythm in beacon mode 		1	1
rxmpk = RX Multi Packet. When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the transceiver will automatically leave the RX State after the first valid packet has been received.
autotx = Automatic Transmission. When autotx = '1' the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.  
enldm = Enable Low Duty Cycle Mode. If this bit is set to '1' then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
ffclrrx = RX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrrx='1' followed by ffclrrx= '0' will clear the contents of the RX FIFO. 
ffclrtx = TX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrtx='1' followed by ffclrtx= '0' will clear the contents of the TX FIFO.</Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>xtalshft = Direct control to Analog
xlc[6:0] = Tuning Capacitance for the 30MHz XTAL</Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>clkt[1:0] = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
00 - 	0 cycle
01 - 	128 cycles
10 - 	256 cycles
11 - 	512 cycles 
enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = '1' except the '111'.  
000 - 	30 MHz
001 - 	15 MHz
010 - 	10 MHz
011 - 	4 MHz
100 - 	3 MHz
101 - 	2 MHz
110 - 	1 MHz
111 -	32.768 kHz</Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>gpiodrv0[1:0] - Gpio driving capability setting
pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio0[4:0] = GPIO0pin function select:
00000 - 	Power-On-Reset (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>gpiodrv1[1:0] - Gpio driving capability setting
pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio1[4:0] = GPIO1 pin function select:
00000 - 	Power-On-Reset Inverted (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>gpiodrv2[1:0] - Gpio driving capability setting
pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio2[4:0] = GPIO2 pin function select:
00000 - Microcontroller Clock (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.</Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart / adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>adcstart / adcdone = ADC Measurement Start bit. Reading this bit gives '1' if the ADC measurement cycle has been finished.
adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
000 -	Internal Temperature Sensor
001 -	GPIO0, single-ended
010 -	GPIO1, single-ended
011 - 	GPIO2, single-ended
100 -	GPIO0(+) - GPIO1(-), differential
101 -	GPIO1(+) - GPIO2(-), differential
110 -	GPIO0(+) - GPIO2(-), differential
111 -	GND, ADC is disabled
adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
0X -	bandgap voltage (1.2V)
10 -	VDD / 3
11 - 	VDD / 2
adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
adcref[0] = 0:	adcref[0] = 1:
FS = 0.014 * (adcgain[1:0] + 1) * VDD 	FS = 0.021 * (adcgain[1:0] + 1) * VDD</Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.</Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
00 -	-40oC .. 64oC (full operating range), with 0.5oC resolution (1 LSB in the 8 bit ADC)
01 -	-40oC .. 85oC, with 1oC resolution (1 LSB in the 8 bit ADC)
11 -	   0oC .. 85oC, with 0.5oC resolution (1 LSB in the 8 bit ADC)
10 -	-40oF .. 216oF, with 1oF resolution (1 LSB in the 8 bit ADC)
entsoffs = Temperature Sensor Offset to convert from K to oC.
entstrim = Temperature Sensor Trim enable
tstrim[3:0] = Temperature Sensor Trim value</Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)</Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="wtr[3]" />
      <Bit index="4" name="wtr[2]" />
      <Bit index="3" name="wtr[1]" />
      <Bit index="2" name="wtr[0]" />
      <Bit index="1" name="wtd[1]" />
      <Bit index="0" name="wtd[0]" />
      <Description>wtr[3:0] = Wake Up Timer Exponent (R) value.  See formula above.
wtd[1:0] = Wake Up Timer Exponent (D) value.  See formula above.</Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>wtm[15:8] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>wtm[7:0] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>wtm[15:8] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>wtm[7:0] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>ldc[7:0] = Low-Duty Cycle Mode Duration (LDC).  See formula above</Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>lbdt[4:0] = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.</Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continouosly.</Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>dwn3_bypass = Bypass decimator by 3 (if set).
ndec_exp[2:0] = IF Filter decimation rates
filset[3:0] = IF Filter coefficient sets ; defauts are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz</Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afcbd" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="afcgearl[2]" />
      <Bit index="1" name="afcgearl[1]" />
      <Bit index="0" name="afcgearl[0]" />
      <Description>afcbd = If set, the tolerated AFC frequency error will be halved.
enafc = AFC enable
afcgearh[2:0] = AFC High Gear Setting
afcgearl[2:0] = AFC Low Gear Setting</Description>
    </Register>
    <Register address="1E" name="AFC Timing Control" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="lgwait[2]" />
      <Bit index="1" name="lgwait[1]" />
      <Bit index="0" name="lgwait[0]" />
      <Description>shwait[2:0] = short wait periods after AFC correction used before preamble is detected. Short wait = (RegValue+1)*2Tb. If set to '0' then no AFC correction will occur before preamble detect, i.e. AFC will be disabled. 
lgwait[2:0] = long wait periods after correction used after preamble detected. Long wait = (RegValue+1)*2Tb. If set to '0' then no AFC correction will occur after the preamble detect.</Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="13" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="rxready" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>rxready = improves receiver noise immunity when in direct mode. It is recommended to set this bit after preamble is detected. When in FIFO mode this bit should be set to '0' since noise immunity is controlled automatically.
crfast[2:0] = Clock Recovery Fast Gearshift value
crslow[2:0] = Clock Recovery Slow Gearshift value</Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>rxosr[7:0] = Oversampling Rate, 3 LSBs are the fraction
default = 0110 0100 = 12.5 clock cycles per data bit</Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="stallctrl" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>rxosr[10:8] = Oversampling Rate, upper bits
stallctrl = Used for BCR purposes
ncoff[19:16] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>ncoff[15:8] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>ncoff[7:0] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>crgain[10:8] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>crgain[7:0] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>rssi[7:0] = Received Signal Strength Indicator value</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>rssith[7:0] = RSSI Threshold. Interrupt is set if the RSSI value is above this threshold.</Description>
    </Register>
    <Register address="28" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>adrssi1[7:0] = Measured RSSI value on antenna 1</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description>adrssi2[7:0] = Measured RSSI value on antenna 2</Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>enpacrx = Enable Packet RX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpacrx='1' will enable automatic packet handling in the RX path. Register 30-4D allow for various configurations of the packet structure. Setting enpacrx='0' will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
lsbfrst = LSB First enable. The LSB of the data will be transmitted/received first if this bit is set.
crcdonly = CRC Data Only enable When this bit is set to '1' the CRC is calculated on and check against the packet data fields only.
reserved
enpactx = Enable Packet TX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpactx='1' will enable automatic packet handling in the TX path. Register 30-4D allow for various configurations of the packet structure. Setting enpactx='0' will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
crc[1:0] = CRC polynomial selection.
00 -	CCITT
01 -	CRC-16 (IBM)
10 -	IEC-16
11 -	Biacheva</Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="rxcrc1" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>rxcrc1 = If high, it indicates the last CRC received is all one's. May indicated Transmitter underflow in case of CRC error.
pksrch = Packet Searching. When pksrch = '1' the radio is searching for a valid packet.  
pkrx = Packet Receiving. When pkrx = '1' the radio is currently receiving a valid packet. 
pkvalid = Valid Packet Received. When a pkvalid = '1' a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
crcerror = CRC Error.  When crcerror = '1' a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
pktx = Packet Transmitting. When pktx = '1' the radio is currently transmitting a packet.
pksent = Packet Sent.  A pksent  = '1' a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)</Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enbcast[1]" />
      <Bit index="6" name="enbcast[1]" />
      <Bit index="5" name="enbcast[1]" />
      <Bit index="4" name="enbcast[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>bcen[3:0] = Broadcast Address (FFh) Check enable.  If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
0000 -	No broadcast address enable.
0001 -	Broadcast address enable for header byte 0.
0010 -	Broadcast address enable for header byte 1.
0011 -	Broadcast address enable for header bytes 0 &amp; 1.
0100 -	...
hdch[3:0] = Received Header bytes to be checked against the Check Header bytes.  One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.   
0000 -	No Received Header check
0001 -	Received Header check for byte 0.  
0010 -	Received Header check for bytes 1.
0011 -	Received header check for bytes 0 &amp; 1.
0100 -	...</Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>hdlen[2:0] = Transmit/Receive Header Length. Length of header used if packet handler is enabled for TX/RX (enpactx/rx). Headers are transmitted/received in descending order.  
000 -	NoTX/RX header
001 - 	Header 3
010 - 	Header 3 and 2
011 - 	Header 3 and 2 and 1
100 - 	Header 3 and 2 and 1 and 0
fixpklen = Fix Transmit/Receive Packet Length.  When fixpklen = '1' the packet length (pklen[7:0]) is not included in the header. When fixpklen = '0' the packet length is included in the header.
synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
00 - 	Synchronization Word 3 
01 - 	Synchronization Word 3 and 2
10 - 	Synchronization Word 3 and 2 and 1
11 - 	Synchronization Word 3 and 2 and 1 and 0
prealen[8] = MSB of Preamble Length. See register Preamble Length.</Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="07" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register  corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = '000001000'  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = '111111111' which corresponds to a 255 Bytes Preamble. Writing '0' will have the same result as if writing '1', which will send one single nibble of preamble.</Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="spare" />
      <Bit index="1" name="spare" />
      <Bit index="0" name="spare" />
      <Description>preath[4:0] = Number of nibbles processed during detection.
SPARE bits</Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] - Packet Length.  The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = '00001000' corresponds to a packet length of 8 Bytes.  The maximum packet length is pklen[7:0] = '11111111', a 255 byte packet. Writing '0' is possible, in this case we do not send any data in the packet. During RX, if fixpklen = 1, this will specify also the Packet Length for RX mode.</Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>chhd[31:24] = Check Header 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>chhd[23:16] = Check Header 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>chhd[15:8] = Check Header 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>chhd[7:0] = Check Header 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>hden[31:24] = Header Enable 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>hden[23:16] = Header Enable 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>hden[15:8] = Header Enable 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>hden[7:0] = Header Enable 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>rxhd[31:24] = Received Header 3. 4th byte of the received header.</Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>rxhd[23:16] = Received Header 2. 3rd byte of the received header.</Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>rxhd[15:8] = Received Header 1. 2nd byte of the received header.</Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>rxhd[7:0] = Received Header  0. 1st byte of the received header.</Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>rxplen[7:0] = Length byte of the received packet during fixpklen = 0 (specifies the number of Data bytes in the last received packet). This will be relevant  ONLY if fixpklen ( address 33h, bit[3]) is low during the receive time. If fixpklen is high, then the number of received Data Bytes can be read from the pklen register (address h3E).</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>atb[4:0] = Analog Test Bus.  The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
Internal analog signals available on the Analog Test Bus:
atb[4:0]
GPIOx
GPIOx
1
MixIp
MixIn
2
MixQp
MixQn
3
PGA_Ip
PGA_In
4
PGA_QP
PGA_Qn
5
ADC_vcm
ADC_vcmb
6
ADC_ipoly10u
ADC_ref
7
ADC_Refdac_p
ADC_Refdac_n
8
ADC_ipoly10
ADC_ipoly10
9
ADC_Res1Ip
ADC_Res1In
10
ADC_Res1Qp
ADC_Res1Qn
11
spare
spare
12
spare
spare
13
spare
spare
14
spare
spare
15
spare
spare
16
spare
spare
17
spare
spare
18
ICP_Test
PLL_IBG_05
19
PLL_VBG
VSS_VCO
20
Vctrl_Test
PLL_IPTAT_05
21
PA_vbias
spare
22
DIGBG
DIGVFB
23
IFBG
IFVFB
24
PLLBG
PLLVReg
25
IBias10u
IBias5u
26
32KRC_Ucap
32KRC_Ures
27
ADC8_VIN
ADC8_VDAC
28
LBDcomp
LBDcompref
29
TSBG
TSVtemp
30
RFBG
RFVREG
31
VCOBG
VCOVREG</Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>ensctest = Scan Test Enable. When set to '1' then GPIO0 will be the ScanEn input.
dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
Internal digital signals available on the Digital Test Bus:
dtb[4:0]
GPIO0
Signal
GPIO1
Signal
GPIO2
Signal
0
wkup_clk_32k
wake-up 32kHz clock
rbase_en
first divided clock
clk_base
timebase clock
1
wkup_clk_32k
wake-up 32kHz clock
wake_up
wake-up event
tm1sec
1 sec timebase
2
ts_adc_en
aux. ADC enable
adc_rdy_n
aux. ADC conversion ready
adc_done
aux. ADC measurement done
3
cont_lbd
low battery continouos mode
lbd_on
low battery ON signal
lbd
unfiltered output of LBD
4
div_clk_g
gated divided clock
uc_clk
microcontroller clock
ckout_rcsel
slow clock selected
5
en_div_sync
clock divider enable (sync'ed)
en_ckout
clock out enable
en_ckout_s
clock out enable (sync'ed)
6
osc30_en
oscillator enable
osc30_bias2x
oscillator bias control
xok
chip ready
7
xok
chip ready
zero_cap
cap. load zero
osc30_buff_en
buffer enable
8
tsadc_needed
aux. ADC enable
ext_retran
ext. retransmission request
tx_mod_gpio
TX modulation inpit
9
gpio_0_oen_n
GPIO0 output enable
gpio_0_aen
GPIO0 analog selection
gpio_0_aden
GPIO0 ADC input line enable
10
int_ack1
interrupt acknowledge 1
int_ack2
interrupt acknowledge 2
int_store
interrupt latch closed
11
ext_int2
ext. interrupt from GPIO2
irq_bit8
combined external status
msk_bit8
combined masked ext. int.
12
sdo_aux_sel
SDO aux. function select
sdo_aux
SDO aux. signal
nirq_aux_sel
nIRQ aux. function select
13
trdata_on_sdi
TX/RX data on SDI
tx_mod
TX modulation input
tx_clk_out
TX clock output
14
start_full_sync
RC osc. full calibration start
start_fine_sync
RC osc. fine calibration start
xtal_req
crystal req. for RC osc. cal.
15
coarse_rdy
RC osc. coarse cal. ready
fine_rdy
RC osc. fine cal. ready
xtal_req_sync
sync'ed crystal request
16
vco_cal_rst_s_n
VCO calibration reset
vco_cal
VCO calibration is running
vco_cal_done
VCO calibration done
17
vco_cal_en
VCO calibration enable
en_ref_cnt
reference counter enable
en_freq_cnt_s
frequency counter enable
18
vco_cal_en
VCO calibration enable
pos_diff
positive difference to goal
en_freq_cnt_s
frequency counter enable
19
dsm_clk_mux
DSM multiplexed clock
pll_fb_clk_tst
PLL feedback clock
pll_ref_clk_tst
PLL reference clock
20
dsm[0]
delta-sigma output
dsm[1]
delta-sigma output
dsm[2]
delta-sigma output
21
dsm[3]
delta-sigma output
pll_fbdiv15
dsm_rst_s_n
delta-sigma reset
22
pll_en
PLL enable: TUNE state
pllt0_ok
PLL initial settling OK
pllts_ok
PLL soft settling OK
23
ch_freq_req
frequency change request
pllts_ok
PLL soft settling OK
vco_cal_done
VCO calibration done
24
vco_cal_en
VCO calibration enable
pll_vbias_shunt_en
VCO bias shunt enable
prog_req
frequency recalculation req.
25
bandgap_en
bandgap enable
frac_div_en
fractional divider enable
buff3_en
buffer3 enable
26
pll_pfd_up
PFD up signal
pll_pfd_down
PFD down signal
pfd_up_down
PFD output change (XOR'ed)
27
pll_lock_detect
PLL lock detect
pll_en
PLL enable: TUNE state
pllt0_ok
PLL initial settling OK
28
pll_en
PLL enable: TUNE state
pll_lock_detect
PLL lock detect
pllts_ok
PLL soft settling OK
29
pwst[0]
internal power state
pwst[1]
internal power state
pwst[2]
internal power state
Internal digital signals available on the Digital Test Bus (continued from the previous page):
dtb[4:0]
GPIO0
Signal
GPIO1
Signal
GPIO2
Signal
30
xok
chip ready: READY state
pll_en
PLL enable: TUNE state
tx_en
TX enable: TX state
31
ts_en
temperature sensor enable
auto_tx_on
automatic TX ON
tx_off
TX OFF
32
ch_freq_req
frequency change request
return_tx
return from TX
pk_sent
packet sent
33
retran_req
retransmission request
tx_ffpt_store
TX FIFO pointer store
tx_ffpt_restore
TX FIFO pointer restore
34
pa_on_trig
PA ON trigger
dly_5us_ok
5 us delay expired
mod_dly_ok
modulator delay expired
35
tx_shdwn
TX shutdown
ramp_start
modulator ramp down start
ramp_done
modulator ramp down ended
36
pk_sent_dly
delayed packet sent
tx_shdwn_done
TX shutdown done
pa_ramp_en
PA ramp enable
37
tx_en
TX enable: TX state
ldo_rf_precharge
RF LDO precharge
pa_ramp_en
PA ramp enable
38
pa_on_trig
TX enable: TX state
dp_tx_en
packet handler (TX) enable
mod_en
modulator enable
39
reg_wr_en
register write enable
reg_rd_en
register rdead enable
addr_inc
register address increment
40
dp_tx_en
packet handler (TX) enable
data_start
start of TX data
pk_sent
packet has been sent
41
data_start
start of TX data
tx_out
packet handler TX data out
pk_sent
packet has been sent
42
ramp_done
ramp is done
data_start
start of TX data
pk_tx
packet is being transmitted
43
tx_ffaf
TX FIFO almost full
tx_fifo_wr_en
TX FIFO write enable
tx_ffem_tst
internal TX FIFO empty
44
clk_mod
modulator gated 10MHz clock
tx_clk
TX clock from NCO
rd_clk_x8
read clock = tx_clk / 10
45
mod_en
modulator enable
ramp_start
start modulator ramping down
ramp_done
modulator ramp done
46
data_start
data input start from PH
ook_en
OOK modulation enable
ook (also internal PN9)
OOK modulation
47
prog_req
freq. channel update request
freq_err
wrong freq. indication
dsm_rst_s_n
dsm sync. reset
48
mod_en
modulator enable
tx_rdy
TX ready
tx_clk
TX clock from NCO
49
dp_rx_en
packet handler (RX) enable
prea_valid
valid preamble
pk_srch
packet is being searched
50
pk_srch
packet is being searched
sync_ok
sync. word has been detected
rx_data
packet handler RX data input
51
pk_rx
packet is being received
sync_ok
sync. word has been detected
pk_valid
valid packet received
52
sync_ok
sync. word has been detected
crc_error
CRC error has been detected
hdch_error
header error detected
53
direct_mode
direct mode
rx_ffaf
RX FIFO almost full
rx_fifo_rd_en
RX FIFO read enable
54
bit_clk
bit clock
prea_valid
valid preamble
rx_data
demodulator RX data output
55
prea_valid
valid preamble
prea_inval
invalid preamble
ant_div_sw
antenna switch (algorythm)
56
sync_ok
sync. word has been detected
bit_clk
bit clock
rx_data
demodulator RX data output
57
demod phase[4]
demodulator phase MSB
demod phase [3]
demodulator MSB-1
demod phase [2]
demodulator MSB-2
58
prea_valid
valid preamble
demod_tst[2]
demodulator test
demod_tst[1]
demodulator test
59
agc_smp_clk
AGC sample clock
win_h_tp
window comparator high
win_l_tp
window comparator low dly'd
60
agc_smp_clk
AGC sample clock
win_h_dly_tp
window comparator high
win_l_dly_tp
window comparator low dly'd
61
ldc_on
active low duty cycle
pll_en
PLL enable: TUNE state
rx_en
RX enable: RX state
62
ldc_on
active low duty cycle
no_sync_det
no sync word detected
prea_valid
valid preamble
63
adc_en
ADC enable
adc_refdac_en
ADC reference DAC enable
adc_rst_n
combined ADC reset</Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>txmod[2:0] = TX Modulation Delay. The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up.  It can be set from 0 us to 28 us in 4 us steps. This also works during PA ramp down.
ldoramp[1:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
00 -	5 us
01 -	10 us
10 -	15 us
11 -	20 us
txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up. 
00 - 	5 us
01 - 	10 us
10 - 	15 us
11 - 	20 us</Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 us and 310 us, in 10 us intervals. The default plltime  corresponds to 100 us. See formula above.
pllt0 = PLL Settling Time (TO). This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0 us and 70 us, in 10 us steps. The default pllt0 corresponds to 20 us. See fomula above.</Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>xtalstarthalf = If set, the Xtal wake time period is halved.
adccaldone = Delta-sigma ADC Calibration Done. Reading this bit gives '1' if the calibration process has been finished.
enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to '1' then the RC oscillator performs fine calibration in every app. 30 s.
rccal = RC Calibration Force. If setting rccal='1' will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a '0' to '1' will initiate the calibration. This bit is cleared automatically.
vcocaldp = VCO Calibration Double Precision enable. When this bit is set to '1' then the VCO calibration measures longer thus calibrates more precisely.
vcocal = VCO Calibration Force.  If in Idle Mode and pllon='1', setting vcocal='1' will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
skipvco = Skip VCO Calibration. Setting skipvco='1' will skip the VCO calibration when going from the Idle state to the TX or RX state.</Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="afcpol" />
      <Bit index="3" name="spare" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="iqswitch" />
      <Description>bcrfbyp = If set, BCR phase compensation will be bypassed. 
slicfbyp = If set,slicer phase compensation will be bypassed.
dttype = Dithering Type: If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add +1/-1.
afcpol  = AFC loop polarity selector (costumer should not touch it).
Spare bit
refclksel = Delta-sigma Reference Clock Source Selection (1: 10MHz, 0: PLL)
refclkinv = Delta-sigma Reference Clock Inversion enable 
iqswitch = I&amp;Q Channel Switch enable. </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>pfdrst = Direct control to analog.
fbdiv_rst = Direct control to analog
cpforceup = Charge Pump Force Up
cpforcedn = Charge Pump Force Down
cdconly = Charge Pump DC Offset Only
cdcurr[2:0] = Charge Pump DC Current selection</Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
cpcorrov = Charge Pump Correction Override enable
cpcorr[4:0] = Charge Pump Correction value</Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Txcor boosten" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>txcorboosten = If this is set, then vcocorr (reg 5A[5:2]) = 1111 during TX mode and VCO CAL followed by TX.
fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
d3trim[1:0] = Divider 3 Current Trim value
d2trim[1:0] = Divider 2 Current Trim value
d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value</Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="83" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Txcur boosten" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>txcurboosten = If this is set, then vcocur = 11 during TX mode and VCO CAL followed by TX.
vcocorrov = VCO Current Correction override
vcocorr[3:0] = VCO Current Correction value
vcocur[1:0] = VCO Current Trim value</Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov='0' the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov='1' the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives '1' if the calibration process has been finished.
vcocal[6:0] = VCO Calibration Results</Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="vcotype" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>dsmdt = Enable DSM ditherting. If low, dithering is disabled.
vcotype = VCO Type.
0 - basic, constant K	1 - single varactor, changing K
enoloop = Open Loop Mode enable
dsmod = Delta-Sigma Modulus
0 - 64000	1 - 65 536
dsorder[1:0] = Delta-Sigma Order
00 - 	0 order
01 - 	1st order
10 - 	2nd order
11 - 	Mash 111
dsrstmode = Delta-Sigma Reset Mode
dsrst = Delta-Sigma Reset</Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>enmix = Mixer enable override
enlna = LNA enable override
enpga = PGA enable override
enpa = Power Amplifier enable override
enbf5 = Buffer 5 enable override
endv32 = Divider 3_2 enable override
enbf12 = Buffer 1_2 enable override
enmx2 = Multiplexer 2 enable override</Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="enldet" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>ends = Delta-Sigma enable override
enldet = Lock Detect enable (direct control, does not need override!)
enmx3 = Mutiplexer 3 enable override
enbf4 = Buffer 4 enable override
enbf3 = Buffer 3 enable override
enbf11 = Buffer 1_1 enable override
enbf2 = Buffer 2 enable override
pllreset = PLL reset enable override</Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>enfrdv = Fractional Divider enable override
endv31 = Divider 3_1 enable override
endv2 = Divider 2 enable override
endv1p5 = Divider 1.5 (div-by-1.5) enable override
dvbshunt = VCO Bias Shunt enable override mode.
envco = VCO enable override
encp = Charge Pump enable override
enbg = Bandgap enable override</Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>chfiladd[3:0] = Channel Filter Coefficient Look-up Table Address. The address for channel filter coefficients used in the RX path.  </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>chfilval[5:0] = Filter Coefficient Value in the look-up table addressed by the chfiladd[3:0]</Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>pwst[2:0] = Internal Power States of the chip
000 -	low power (stand-by / sleep / sensor)
001 -	ready
011 -	tune
010 -	TX 
010 -	RX 
clkhyst = Clock Hysteresis Setting
enbias2x = 2 times higher bias current enable
enamp2x = 2 times higher amplification enable
bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
0 - output buffer is controlled by the state machine
1 - output buffer is controlled by the enbuf bit 
enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.</Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>rccov = RC Oscillator Coarse Calibration Override. When rccov='0' the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov='1' the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>rcfov = RC Oscillator Fine Calibration Override. When rcfov='0' the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov='1' the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>enspor = Smart POR enable
enbias = Bias enable
envcoldo = VCO LDO enable
enifldo = IF LDO enable
enrfldo = RF LDO enable
enpllldo = PLL LDO enable
endigldo = Digital LDO enable
endigpwdn = Digital Power Domain Powerdown enable in Idle mode</Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="*" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>enovr = Enable Overrides (If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks).
enxtal = Xtal override enable value.
ents = temperature sensor enable.
enrc32 = 32K oscillator enable.

diglvl = digital LDO level setting</Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>adcrst = delta-sigma ADC reset
enrefdac = delta-sigma ADC reference DAC enable override
enadc = delta-sigma ADC enable override
adctuneovr = resonator RC calibration value override enable
adctune[3:0] = resonator RC calibration value</Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>envcm = delta-sigma ADC VCM enable override
adcoloop = delta-sigma ADC open loop enable
adcref[2:0] = delta-sigma ADC reference voltage
000 -	0.5 V
001 -	0.6 V
010 -	0.7 V
...
111 -	1.2 V</Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>agcen = Automatic Gain Control enable When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
lnagain = LNA Gain select
0 - min. gain = 5 dB	1 -max. gain = 25 dB
pga[3:0] = PGA Gain Override value
000 -	0 dB
001 -	3 dB
010 -	6 dB 
...
101 -	24 dB max.</Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="agcovpm" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>agcovpm  = If set, AGC will ignore the preamble detection.
agcslow = AGC Slow Gain Increase enable. When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
lnacomp[3:0] = LNA Gain Compensation, used for smoothing RSSI value when LNA gain is switched.
pgath[1:0] = window comparator reference voltage adjust in the PGA</Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.   
000 - 	i_coe0 (Default =d1)
001 - 	i_coe1 (Default =d3)
010 - 	i_coe2 (Default =d6)
011 - 	i_coe3 (Default =d10)
100 - 	i_coe4 (Default =d15)
101 - 	i_coe5 (Default =d19)
110 - 	i_coe6 (Default =d20)</Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>txpow[1:0] = TX Output Power.  The output power is configurable from +20dBm to +11dBm in ~3dBm steps.  txpow[1:0]='11' corresponds to +20dBm and '00' to +11dBm.</Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="3D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txdtrtscale" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>txdtrtscale = This bit should be set for data rates below 30 [kbps].
enphpwdn = If set, the Packet Handler will be powered down when chip is in low power mode.
manppol = Manchester Preamble Polarity (will transmit a series of '1' if set, or series of '0' if reset). This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester mode is enabled.
enmaninv = Manchester Data Inversion is enabled if this bit is set.
enmanch = Manchester Coding is enabled if this bit is set.
enwhite = Data Whitening is enabled if this bit is set.</Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>trclk[1:0] = TX Data Clock Configuration. 
00 -	No TX Data CLK is available (asynchronous mode - Can only work with modulations FSK or OOK)
01 -	TX Data CLK is available via the GPIO (one of the GPIO's should be programmed as well)
10 -	TX Data CLK is available via the SCK pin
11 -	TX Data CLK is available via the nIRQ pin
dtmod[1:0] = Modulation Source
00 - 	Direct Mode using TX_Data function via the GPIO pin (one of the GPIO's should be 	programmed accordingly as well)
01 - 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
10 - 	FIFO Mode
11 - 	PN9 (internally generated)
eninv = Invert TX and RX Data
fd[8]  = See register 72h
modtyp[1:0] = Modulation Type 
00 -	Unmodulated carrier
01 -	OOK
10 -	FSK
11 -	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)</Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>fd[7:0] = Frequency Deviation Setting. See formula above. (please see note below)
Note: It's recommended to use modulation index of 1 or higher (maximum allowable modulation index is 32). The modulation index is defined by  were FD is the deviation and RB is the data rate. When Manchester coding is enabled the modulation index is defined by .</Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>fo[7:0] = Frequency Offset Setting. Values written to it will be used during TX, reading from it will result in reading the last AFC correction value.</Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>fo[9:8] = Upper bits of the Frequency Offset Setting. fo[9] is the sign bit. Values written to it will be used during TX, reading from it will result in reading the last AFC correction value.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>sbsel = Side Band Select.
hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-960MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]='00000' corresponds to the 240-250MHz Band for hbsel='0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0]='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.  </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold</Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>rxafthr[5:0] = RX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>fifod[7:0] = A write (R/W='1') to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH. A Read (R/W='0') to this address will begin a burst read of the RX FIFO, in the same manner.</Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="15" type="Si4432" revision="V3" projectID="0" name="Ara RevV MFIX">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>dt[4:0] = Device Type Code.  This internally hardwired code will allow the user to recognize whether this is a Transmitter, Receiver, or a Transceiver.  Ara = 01000/ Tamara = 00111</Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="03" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>vc[4:0] = Version Code.  Internally hardwired version code of the chip</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="lockdet" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>ffovfl = RX/TX FIFO Overflow status.
ffunfl = RX/TX FIFO Underflow status.
rxffem = RX FIFO Empty status.
headerr = Header Error status. The actual received packet has a header check error.
freqerr = Frequency Error status. The programmed frequency is outside of the operating range. The actual frequency is saturated to the max/min value.
lockdet = Synthesizer Lock Detect status. 
cps[1:0] = Chip Power State:
00 -	Idle State
01 -	RX State
10 -	TX State</Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>ifferr = FIFO Underflow/Overflow Error.  When set to '1' the TX or RX FIFO has overflowed or underflowed.
itxffafull = TX FIFO Almost Full.  When set to '1' the TX FIFO has met its almost full threshold and needs to be transmitted.
itxffaem= TX FIFO Almost Empty.  When set to '1' the TX FIFO is almost empty and needs to be filled.
irxffafull = RX FIFO Almost Full.  When set to '1' the RX FIFO has met its almost full threshold and needs to be read by the microcontroller
iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
ipksent = Packet Sent Interrupt. When set to'1' a valid packet has been transmitted.
ipkvalid =  Valid Packet Received. When set to '1' a valid packet has been received.
icrcerror = CRC Error. When set to '1' the cyclic redundancy check is failed.  
When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
Bit
Status Name
Set/Clear conditions:
[7]
ifferr
Set if there is a Tx or RX FIFO Overflow or Underflow.  It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
[6]
itxffafull
Will be set when the number of bytes written to TX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we start transmitting and the FIFO data is read out and the number of bytes left in the FIFO is smaller or equal to the threshold).
[5]
itxffaem
Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
[4]
irxffafull
Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we read enough data from RX FIFO so that the number of data bytes not yet read is below the Almost Full threshold.
[3]
iext
External interrupt source
[2]
ipksent
Will go high once a packet is sent all the way through (no TX abort). This status will be cleaned if 1) We leave FIFO mode or 2) In FIFO mode we start a new transmission.
[1]
ipkvalid
Goes high once a packet is fully received (no RX abort). It is automatically cleaned once we receive and acknowledge the Sync Word for the next packet.
[0]
icrcerror
Goes High once the CRC computed during RX differs from the CRC sent in the packet by the TX. It is cleaned once we start receiving new data in the next packet.</Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
ipreaval = Valid Preamble Detected. When a preamble is detected this bit will be set to 1.
ipreainval = Invalid Preamble Detected. When the preamble is not found within a period of time after the RX is enabled, this bit will be set to 1.
irssi = RSSI. When RSSI level exceeds the programmed thershold this bit will be set to 1.
iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.  
ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.  
When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
Bit
Status Name
Set/Clear conditions:
[7]
iswdet
Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
[6]
ipreaval
Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
[5]
ipreainval
Self cleaning, user should use this as an interrupt source rather than a status.
[4]
irssi
Should remain high as long as the RSSI value is above programmed threshold level
[3]
iwut
Wake time timer interrupt. Use as an interrupt, not as a status.
[2]
ilbd
Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
[1]
ichiprdy
Chip ready goes high once we enable the xtal, Tx or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
[0]
ipor
Power on status. 
Invalid Preamble time is defined as:  (pm_detection_th+2)*2Tb - Where pm_detection_th is equal to the value written in register 35h (bits [7:4]) multiplied by 4, and Tb is the bit clock rate period.</Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
entxffafull = Enable TX FIFO Almost Full. When set to '1' the TX FIFO Almost Full interrupt will be enabled.
entxffaem = Enable TX FIFO Almost Empty. When set to '1' the TX FIFO Almost Empty interrupt will be enabled.
enrxffafull = Enable RX FIFO Almost Full. When set to '1' the RX FIFO Almost Full interrupt will be enabled.
enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
enpksent = Enable Packet Sent. When ipksent ='1' the Packet Sense Interrupt will be enabled.
enpkvalid = Enable Valid Packet Received. When ipkvalid = '1' the Valid Packet Received Interrupt will be  enabled
encrcerror = Enable CRC Error. When set to '1' the CRC Error  interrupt will be enabled.</Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>enswdet = Enable Sync Word Detected. When mpreadet ='1' the Preamble Detected Interrupt will be enabled.
enpreaval = Enable Valid Preamble Detected. When mpreadet ='1' the Valid Preamble Detected Interrupt will be enabled.
enpreainval = Enable Invalid Preamble Detected. When mpreadet ='1' the Invalid Preamble Detected Interrupt will be enabled.
enrssi = Enable RSSI. When set to '1' the RSSI Interrupt will be  enabled.
enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.</Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.  
enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.  
enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
txon = TX on in manual transmit mode. It is automatically cleared in FIFO mode once the packet is sent.
rxon = RX on in manual receiver mode. It is automatically cleared if Multiple Packets config. is disabled and a valid packet received.
pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.  
xton = READY Mode (Xtal is ON).</Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="ffclrtx" />
      <Description>antdiv[2:0] = Enable Antenna Diversity. The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
	RX/TX state	non RX/TX state
	GPIO Ant1	GPIO Ant2	GPIO Ant1	GPIO Ant2
000 - 	1	0	0	0
001 -	0	1	0	0
010 - 	1	0	1	1
011 -	0	1	1	1
100 -	antenna diversity algorythm	0	0
101 - 	antenna diversity algorythm	1	1 
110 -	ant. div. algorythm in beacon mode	0	0
111 - 	ant. div. algorythm in beacon mode 		1	1
rxmpk = RX Multi Packet. When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the transceiver will automatically leave the RX State after the first valid packet has been received.
autotx = Automatic Transmission. When autotx = '1' the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.  
enldm = Enable Low Duty Cycle Mode. If this bit is set to '1' then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
ffclrrx = RX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrrx='1' followed by ffclrrx= '0' will clear the contents of the RX FIFO. 
ffclrtx = TX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrtx='1' followed by ffclrtx= '0' will clear the contents of the TX FIFO.</Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>xtalshft = Direct control to Analog
xlc[6:0] = Tuning Capacitance for the 30MHz XTAL</Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>clkt[1:0] = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
00 - 	0 cycle
01 - 	128 cycles
10 - 	256 cycles
11 - 	512 cycles 
enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = '1' except the '111'.  
000 - 	30 MHz
001 - 	15 MHz
010 - 	10 MHz
011 - 	4 MHz
100 - 	3 MHz
101 - 	2 MHz
110 - 	1 MHz
111 -	32.768 kHz</Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>gpiodrv0[1:0] - Gpio driving capability setting
pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio0[4:0] = GPIO0pin function select:
00000 - 	Power-On-Reset (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>gpiodrv1[1:0] - Gpio driving capability setting
pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio1[4:0] = GPIO1 pin function select:
00000 - 	Power-On-Reset Inverted (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>gpiodrv2[1:0] - Gpio driving capability setting
pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio2[4:0] = GPIO2 pin function select:
00000 - Microcontroller Clock (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.</Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart / adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>adcstart / adcdone = ADC Measurement Start bit. Reading this bit gives '1' if the ADC measurement cycle has been finished.
adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
000 -	Internal Temperature Sensor
001 -	GPIO0, single-ended
010 -	GPIO1, single-ended
011 - 	GPIO2, single-ended
100 -	GPIO0(+) - GPIO1(-), differential
101 -	GPIO1(+) - GPIO2(-), differential
110 -	GPIO0(+) - GPIO2(-), differential
111 -	GND, ADC is disabled
adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
0X -	bandgap voltage (1.2V)
10 -	VDD / 3
11 - 	VDD / 2
adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
adcref[0] = 0:	adcref[0] = 1:
FS = 0.014 * (adcgain[1:0] + 1) * VDD 	FS = 0.021 * (adcgain[1:0] + 1) * VDD</Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.</Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
00 -	-40oC .. 64oC (full operating range), with 0.5oC resolution (1 LSB in the 8 bit ADC)
01 -	-40oC .. 85oC, with 1oC resolution (1 LSB in the 8 bit ADC)
11 -	   0oC .. 85oC, with 0.5oC resolution (1 LSB in the 8 bit ADC)
10 -	-40oF .. 216oF, with 1oF resolution (1 LSB in the 8 bit ADC)
entsoffs = Temperature Sensor Offset to convert from K to oC.
entstrim = Temperature Sensor Trim enable
tstrim[3:0] = Temperature Sensor Trim value</Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)</Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="wtr[3]" />
      <Bit index="4" name="wtr[2]" />
      <Bit index="3" name="wtr[1]" />
      <Bit index="2" name="wtr[0]" />
      <Bit index="1" name="wtd[1]" />
      <Bit index="0" name="wtd[0]" />
      <Description>wtr[3:0] = Wake Up Timer Exponent (R) value.  See formula above.
wtd[1:0] = Wake Up Timer Exponent (D) value.  See formula above.</Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>wtm[15:8] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>wtm[7:0] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>wtm[15:8] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>wtm[7:0] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>ldc[7:0] = Low-Duty Cycle Mode Duration (LDC).  See formula above</Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>lbdt[4:0] = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.</Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continouosly.</Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>dwn3_bypass = Bypass decimator by 3 (if set).
ndec_exp[2:0] = IF Filter decimation rates
filset[3:0] = IF Filter coefficient sets ; defauts are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz
When the required bandwidth (BW) is calculated then the three filter parameters, ndec_exp, dwn3_bypass and filset, can be found from the table below. When the calculated bandwidth value is not exactly available then select the higher available bandwidth closest to the calculated bandwidth.
BW [kHz]
ndec_exp
1C-[6:4]
dwn3_bypass
1C-[7]
filset
1C-[3:0]
BW [kHz]
ndec_exp
1C-[6:4]
dwn3_bypass
1C-[7]
filset
1C-[3:0]
2.6
5
0
1
41.7
1
0
2
2.8
5
0
2
45.2
1
0
3
3.1
5
0
3
47.9
1
0
4
3.2
5
0
4
56.2
1
0
5
3.7
5
0
5
64.1
1
0
6
4.2
5
0
6
69.2
1
0
7
4.5
5
0
7
75.2
0
0
1
4.9
4
0
1
83.2
0
0
2
5.4
4
0
2
90.0
0
0
3
5.9
4
0
3
95.3
0
0
4
6.1
4
0
4
112.1
0
0
5
7.2
4
0
5
127.9
0
0
6
8.2
4
0
6
137.9
0
0
7
8.8
4
0
7
142.8
1
1
4
9.5
3
0
1
167.8
1
1
5
10.6
3
0
2
181.1
1
1
9
11.5
3
0
3
191.5
0
1
15
12.1
3
0
4
225.1
0
1
1
14.2
3
0
5
248.8
0
1
2
16.2
3
0
6
269.3
0
1
3
17.5
3
0
7
284.9
0
1
4
18.9
2
0
1
335.5
0
1
8
21.0
2
0
2
361.8
0
1
9
22.7
2
0
3
420.2
0
1
10
24.0
2
0
4
468.4
0
1
11
28.2
2
0
5
518.8
0
1
12
32.2
2
0
6
577.0
0
1
13
34.7
2
0
7
620.7
0
1
14
37.7
1
0
1</Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afcbd" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="afcgearl[2]" />
      <Bit index="1" name="afcgearl[1]" />
      <Bit index="0" name="afcgearl[0]" />
      <Description>afcbd = If set, the tolerated AFC frequency error will be halved.
enafc = AFC enable
afcgearh[2:0] = AFC High Gear Setting
afcgearl[2:0] = AFC Low Gear Setting</Description>
    </Register>
    <Register address="1E" name="AFC Timing Control" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="lgwait[2]" />
      <Bit index="1" name="lgwait[1]" />
      <Bit index="0" name="lgwait[0]" />
      <Description>shwait[2:0] = short wait periods after AFC correction used before preamble is detected. Short wait = (RegValue+1)*2Tb. If set to '0' then no AFC correction will occur before preamble detect, i.e. AFC will be disabled. 
lgwait[2:0] = long wait periods after correction used after preamble detected. Long wait = (RegValue+1)*2Tb. If set to '0' then no AFC correction will occur after the preamble detect.</Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="rxready" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>rxready = improves receiver noise immunity when in direct mode. It is recommended to set this bit after preamble is detected. When in FIFO mode this bit should be set to '0' since noise immunity is controlled automatically.
crfast[2:0] = Clock Recovery Fast Gearshift value
crslow[2:0] = Clock Recovery Slow Gearshift value</Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>rxosr[7:0] = Oversampling Rate, 3 LSBs are the fraction
default = 0110 0100 = 12.5 clock cycles per data bit</Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="stallctrl" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>rxosr[10:8] = Oversampling Rate, upper bits
stallctrl = Used for BCR purposes
ncoff[19:16] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>ncoff[15:8] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>ncoff[7:0] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>crgain[10:8] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>crgain[7:0] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>rssi[7:0] = Received Signal Strength Indicator value</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="1E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>rssith[7:0] = RSSI Threshold. Interrupt is set if the RSSI value is above this threshold.</Description>
    </Register>
    <Register address="28" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>adrssi1[7:0] = Measured RSSI value on antenna 1</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description>adrssi2[7:0] = Measured RSSI value on antenna 2</Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="*" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>enpacrx = Enable Packet RX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpacrx='1' will enable automatic packet handling in the RX path. Register 30-4D allow for various configurations of the packet structure. Setting enpacrx='0' will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
lsbfrst = LSB First enable. The LSB of the data will be transmitted/received first if this bit is set.
crcdonly = CRC Data Only enable When this bit is set to '1' the CRC is calculated on and check against the packet data fields only.
reserved
enpactx = Enable Packet TX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpactx='1' will enable automatic packet handling in the TX path. Register 30-4D allow for various configurations of the packet structure. Setting enpactx='0' will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
crc[1:0] = CRC polynomial selection.
00 -	CCITT
01 -	CRC-16 (IBM)
10 -	IEC-16
11 -	Biacheva</Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="rxcrc1" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>rxcrc1 = If high, it indicates the last CRC received is all one's. May indicated Transmitter underflow in case of CRC error.
pksrch = Packet Searching. When pksrch = '1' the radio is searching for a valid packet.  
pkrx = Packet Receiving. When pkrx = '1' the radio is currently receiving a valid packet. 
pkvalid = Valid Packet Received. When a pkvalid = '1' a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
crcerror = CRC Error.  When crcerror = '1' a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
pktx = Packet Transmitting. When pktx = '1' the radio is currently transmitting a packet.
pksent = Packet Sent.  A pksent  = '1' a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)</Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enbcast[1]" />
      <Bit index="6" name="enbcast[1]" />
      <Bit index="5" name="enbcast[1]" />
      <Bit index="4" name="enbcast[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>bcen[3:0] = Broadcast Address (FFh) Check enable.  If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
0000 -	No broadcast address enable.
0001 -	Broadcast address enable for header byte 0.
0010 -	Broadcast address enable for header byte 1.
0011 -	Broadcast address enable for header bytes 0 &amp; 1.
0100 -	...
hdch[3:0] = Received Header bytes to be checked against the Check Header bytes.  One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.   
0000 -	No Received Header check
0001 -	Received Header check for byte 0.  
0010 -	Received Header check for bytes 1.
0011 -	Received header check for bytes 0 &amp; 1.
0100 -	...</Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>hdlen[2:0] = Transmit/Receive Header Length. Length of header used if packet handler is enabled for TX/RX (enpactx/rx). Headers are transmitted/received in descending order.  
000 -	NoTX/RX header
001 - 	Header 3
010 - 	Header 3 and 2
011 - 	Header 3 and 2 and 1
100 - 	Header 3 and 2 and 1 and 0
fixpklen = Fix Transmit/Receive Packet Length.  When fixpklen = '1' the packet length (pklen[7:0]) is not included in the header. When fixpklen = '0' the packet length is included in the header.
synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
00 - 	Synchronization Word 3 
01 - 	Synchronization Word 3 and 2
10 - 	Synchronization Word 3 and 2 and 1
11 - 	Synchronization Word 3 and 2 and 1 and 0
prealen[8] = MSB of Preamble Length. See register Preamble Length.</Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register  corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = '000001000'  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = '111111111' which corresponds to a 255 Bytes Preamble. Writing '0' will have the same result as if writing '1', which will send one single nibble of preamble.</Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description>preath[4:0] = Number of nibbles processed during detection.
rssi_offset[2:0] = Value added as offset to RSSI calculation. Every increment in this register results in an increment of +4dB in the RSSI.</Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] - Packet Length.  The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = '00001000' corresponds to a packet length of 8 Bytes.  The maximum packet length is pklen[7:0] = '11111111', a 255 byte packet. Writing '0' is possible, in this case we do not send any data in the packet. During RX, if fixpklen = 1, this will specify also the Packet Length for RX mode.</Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>chhd[31:24] = Check Header 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>chhd[23:16] = Check Header 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>chhd[15:8] = Check Header 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>chhd[7:0] = Check Header 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>hden[31:24] = Header Enable 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>hden[23:16] = Header Enable 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>hden[15:8] = Header Enable 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>hden[7:0] = Header Enable 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>rxhd[31:24] = Received Header 3. 4th byte of the received header.</Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>rxhd[23:16] = Received Header 2. 3rd byte of the received header.</Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>rxhd[15:8] = Received Header 1. 2nd byte of the received header.</Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>rxhd[7:0] = Received Header  0. 1st byte of the received header.</Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>rxplen[7:0] = Length byte of the received packet during fixpklen = 0 (specifies the number of Data bytes in the last received packet). This will be relevant  ONLY if fixpklen ( address 33h, bit[3]) is low during the receive time. If fixpklen is high, then the number of received Data Bytes can be read from the pklen register (address h3E).</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>atb[4:0] = Analog Test Bus.  The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
Internal analog signals available on the Analog Test Bus:
atb[4:0]
GPIOx
GPIOx
1
MixIp
MixIn
2
MixQp
MixQn
3
PGA_Ip
PGA_In
4
PGA_QP
PGA_Qn
5
ADC_vcm
ADC_vcmb
6
ADC_ipoly10u
ADC_ref
7
ADC_Refdac_p
ADC_Refdac_n
8
ADC_ipoly10
ADC_ipoly10
9
ADC_Res1Ip
ADC_Res1In
10
ADC_Res1Qp
ADC_Res1Qn
11
spare
spare
12
spare
spare
13
spare
spare
14
spare
spare
15
spare
spare
16
spare
spare
17
spare
spare
18
ICP_Test
PLL_IBG_05
19
PLL_VBG
VSS_VCO
20
Vctrl_Test
PLL_IPTAT_05
21
PA_vbias
spare
22
DIGBG
DIGVFB
23
IFBG
IFVFB
24
PLLBG
PLLVReg
25
IBias10u
IBias5u
26
32KRC_Ucap
32KRC_Ures
27
ADC8_VIN
ADC8_VDAC
28
LBDcomp
LBDcompref
29
TSBG
TSVtemp
30
RFBG
RFVREG
31
VCOBG
VCOVREG</Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>ensctest = Scan Test Enable. When set to '1' then GPIO0 will be the ScanEn input.
dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
Internal digital signals available on the Digital Test Bus:
dtb[4:0]
GPIO0
Signal
GPIO1
Signal
GPIO2
Signal
0
wkup_clk_32k
wake-up 32kHz clock
rbase_en
first divided clock
clk_base
timebase clock
1
wkup_clk_32k
wake-up 32kHz clock
wake_up
wake-up event
tm1sec
1 sec timebase
2
ts_adc_en
aux. ADC enable
adc_rdy_n
aux. ADC conversion ready
adc_done
aux. ADC measurement done
3
cont_lbd
low battery continouos mode
lbd_on
low battery ON signal
lbd
unfiltered output of LBD
4
div_clk_g
gated divided clock
uc_clk
microcontroller clock
ckout_rcsel
slow clock selected
5
en_div_sync
clock divider enable (sync'ed)
en_ckout
clock out enable
en_ckout_s
clock out enable (sync'ed)
6
osc30_en
oscillator enable
osc30_bias2x
oscillator bias control
xok
chip ready
7
xok
chip ready
zero_cap
cap. load zero
osc30_buff_en
buffer enable
8
tsadc_needed
aux. ADC enable
ext_retran
ext. retransmission request
tx_mod_gpio
TX modulation inpit
9
gpio_0_oen_n
GPIO0 output enable
gpio_0_aen
GPIO0 analog selection
gpio_0_aden
GPIO0 ADC input line enable
10
int_ack1
interrupt acknowledge 1
int_ack2
interrupt acknowledge 2
int_store
interrupt latch closed
11
ext_int2
ext. interrupt from GPIO2
irq_bit8
combined external status
msk_bit8
combined masked ext. int.
12
sdo_aux_sel
SDO aux. function select
sdo_aux
SDO aux. signal
nirq_aux_sel
nIRQ aux. function select
13
trdata_on_sdi
TX/RX data on SDI
tx_mod
TX modulation input
tx_clk_out
TX clock output
14
start_full_sync
RC osc. full calibration start
start_fine_sync
RC osc. fine calibration start
xtal_req
crystal req. for RC osc. cal.
15
coarse_rdy
RC osc. coarse cal. ready
fine_rdy
RC osc. fine cal. ready
xtal_req_sync
sync'ed crystal request
16
vco_cal_rst_s_n
VCO calibration reset
vco_cal
VCO calibration is running
vco_cal_done
VCO calibration done
17
vco_cal_en
VCO calibration enable
en_ref_cnt
reference counter enable
en_freq_cnt_s
frequency counter enable
18
vco_cal_en
VCO calibration enable
pos_diff
positive difference to goal
en_freq_cnt_s
frequency counter enable
19
dsm_clk_mux
DSM multiplexed clock
pll_fb_clk_tst
PLL feedback clock
pll_ref_clk_tst
PLL reference clock
20
dsm[0]
delta-sigma output
dsm[1]
delta-sigma output
dsm[2]
delta-sigma output
21
dsm[3]
delta-sigma output
pll_fbdiv15
dsm_rst_s_n
delta-sigma reset
22
pll_en
PLL enable: TUNE state
pllt0_ok
PLL initial settling OK
pllts_ok
PLL soft settling OK
23
ch_freq_req
frequency change request
pllts_ok
PLL soft settling OK
vco_cal_done
VCO calibration done
24
vco_cal_en
VCO calibration enable
pll_vbias_shunt_en
VCO bias shunt enable
prog_req
frequency recalculation req.
25
bandgap_en
bandgap enable
frac_div_en
fractional divider enable
buff3_en
buffer3 enable
26
pll_pfd_up
PFD up signal
pll_pfd_down
PFD down signal
pfd_up_down
PFD output change (XOR'ed)
27
pll_lock_detect
PLL lock detect
pll_en
PLL enable: TUNE state
pllt0_ok
PLL initial settling OK
28
pll_en
PLL enable: TUNE state
pll_lock_detect
PLL lock detect
pllts_ok
PLL soft settling OK
29
pwst[0]
internal power state
pwst[1]
internal power state
pwst[2]
internal power state
Internal digital signals available on the Digital Test Bus (continued from the previous page):
dtb[4:0]
GPIO0
Signal
GPIO1
Signal
GPIO2
Signal
30
xok
chip ready: READY state
pll_en
PLL enable: TUNE state
tx_en
TX enable: TX state
31
ts_en
temperature sensor enable
auto_tx_on
automatic TX ON
tx_off
TX OFF
32
ch_freq_req
frequency change request
return_tx
return from TX
pk_sent
packet sent
33
retran_req
retransmission request
tx_ffpt_store
TX FIFO pointer store
tx_ffpt_restore
TX FIFO pointer restore
34
pa_on_trig
PA ON trigger
dly_5us_ok
5 us delay expired
mod_dly_ok
modulator delay expired
35
tx_shdwn
TX shutdown
ramp_start
modulator ramp down start
ramp_done
modulator ramp down ended
36
pk_sent_dly
delayed packet sent
tx_shdwn_done
TX shutdown done
pa_ramp_en
PA ramp enable
37
tx_en
TX enable: TX state
ldo_rf_precharge
RF LDO precharge
pa_ramp_en
PA ramp enable
38
pa_on_trig
TX enable: TX state
dp_tx_en
packet handler (TX) enable
mod_en
modulator enable
39
reg_wr_en
register write enable
reg_rd_en
register rdead enable
addr_inc
register address increment
40
dp_tx_en
packet handler (TX) enable
data_start
start of TX data
pk_sent
packet has been sent
41
data_start
start of TX data
tx_out
packet handler TX data out
pk_sent
packet has been sent
42
ramp_done
ramp is done
data_start
start of TX data
pk_tx
packet is being transmitted
43
tx_ffaf
TX FIFO almost full
tx_fifo_wr_en
TX FIFO write enable
tx_ffem_tst
internal TX FIFO empty
44
clk_mod
modulator gated 10MHz clock
tx_clk
TX clock from NCO
rd_clk_x8
read clock = tx_clk / 10
45
mod_en
modulator enable
ramp_start
start modulator ramping down
ramp_done
modulator ramp done
46
data_start
data input start from PH
ook_en
OOK modulation enable
ook (also internal PN9)
OOK modulation
47
prog_req
freq. channel update request
freq_err
wrong freq. indication
dsm_rst_s_n
dsm sync. reset
48
mod_en
modulator enable
tx_rdy
TX ready
tx_clk
TX clock from NCO
49
dp_rx_en
packet handler (RX) enable
prea_valid
valid preamble
pk_srch
packet is being searched
50
pk_srch
packet is being searched
sync_ok
sync. word has been detected
rx_data
packet handler RX data input
51
pk_rx
packet is being received
sync_ok
sync. word has been detected
pk_valid
valid packet received
52
sync_ok
sync. word has been detected
crc_error
CRC error has been detected
hdch_error
header error detected
53
direct_mode
direct mode
rx_ffaf
RX FIFO almost full
rx_fifo_rd_en
RX FIFO read enable
54
bit_clk
bit clock
prea_valid
valid preamble
rx_data
demodulator RX data output
55
prea_valid
valid preamble
prea_inval
invalid preamble
ant_div_sw
antenna switch (algorythm)
56
sync_ok
sync. word has been detected
bit_clk
bit clock
rx_data
demodulator RX data output
57
demod phase[4]
demodulator phase MSB
demod phase [3]
demodulator MSB-1
demod phase [2]
demodulator MSB-2
58
prea_valid
valid preamble
demod_tst[2]
demodulator test
demod_tst[1]
demodulator test
59
agc_smp_clk
AGC sample clock
win_h_tp
window comparator high
win_l_tp
window comparator low dly'd
60
agc_smp_clk
AGC sample clock
win_h_dly_tp
window comparator high
win_l_dly_tp
window comparator low dly'd
61
ldc_on
active low duty cycle
pll_en
PLL enable: TUNE state
rx_en
RX enable: RX state
62
ldc_on
active low duty cycle
no_sync_det
no sync word detected
prea_valid
valid preamble
63
adc_en
ADC enable
adc_refdac_en
ADC reference DAC enable
adc_rst_n</Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="2F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>txmod[2:0] = TX Modulation Delay. The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up.  It can be set from 0 us to 28 us in 4 us steps. This also works during PA ramp down.
ldoramp[1:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
00 -	5 us
01 -	10 us
10 -	15 us
11 -	20 us
txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up. 
00 - 	5 us
01 - 	10 us
10 - 	15 us
11 - 	20 us</Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="  52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 us and 310 us, in 10 us intervals. The default plltime  corresponds to 100 us. See formula above.
pllt0 = PLL Settling Time (TO). This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0 us and 70 us, in 10 us steps. The default pllt0 corresponds to 20 us. See fomula above.</Description>
    </Register>
    <Register address="54" name="PA Boost" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Inv_pre_th [5]" />
      <Bit index="6" name="Inv_pre_th [4]" />
      <Bit index="5" name="Inv_pre_th [3]" />
      <Bit index="4" name="Inv_pre_th [2]" />
      <Bit index="3" name="Inv_pre_th [1]" />
      <Bit index="2" name="Inv_pre_th [0]" />
      <Bit index="1" name="ldo_pa_boost" />
      <Bit index="0" name="pa_vbias_boost" />
      <Description>Invalid_preamble_Threshold[5:0]
LDO_PA_BOOST
PA_VBIAS_BOOST</Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>xtalstarthalf = If set, the Xtal wake time period is halved.
adccaldone = Delta-sigma ADC Calibration Done. Reading this bit gives '1' if the calibration process has been finished.
enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to '1' then the RC oscillator performs fine calibration in every app. 30 s.
rccal = RC Calibration Force. If setting rccal='1' will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a '0' to '1' will initiate the calibration. This bit is cleared automatically.
vcocaldp = VCO Calibration Double Precision enable. When this bit is set to '1' then the VCO calibration measures longer thus calibrates more precisely.
vcocal = VCO Calibration Force.  If in Idle Mode and pllon='1', setting vcocal='1' will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
skipvco = Skip VCO Calibration. Setting skipvco='1' will skip the VCO calibration when going from the Idle state to the TX or RX state.</Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="afcpol" />
      <Bit index="3" name="ookth" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>bcrfbyp = If set, BCR phase compensation will be bypassed. 
slicfbyp = If set,slicer phase compensation will be bypassed.
dttype = Dithering Type: If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add +1/-1.
afcpol  = AFC loop polarity selector (costumer should not touch it).
ookth  = If set, in OOK mode, the slicer threshold will be estimated by 8 bits of preamble. By default, this bit is low and the demod estimate the threshold after 4 bits.
refclksel = Delta-sigma Reference Clock Source Selection (1: 10MHz, 0: PLL)
refclkinv = Delta-sigma Reference Clock Inversion enable 
distogg = If reset, the discriminator toggling is disabled.</Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cptristate" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>pfdrst = Direct control to analog.
fbdiv_rst = Direct control to analog
cpforceup = Charge Pump Force Up
cpforcedn = Charge Pump Force Down
cdconly = Charge Pump DC Offset Only
cdcurr[2:0] = Charge Pump DC Current selection</Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
cpcorrov = Charge Pump Correction Override enable
cpcorr[4:0] = Charge Pump Correction value</Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcor boosten" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>txcorboosten = If this is set, then vcocorr (reg 5A[5:2]) = 1111 during TX mode and VCO CAL followed by TX.
fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
d3trim[1:0] = Divider 3 Current Trim value
d2trim[1:0] = Divider 2 Current Trim value
d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value</Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcur boosten" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>txcurboosten = If this is set, then vcocur = 11 during TX mode and VCO CAL followed by TX.
vcocorrov = VCO Current Correction override
vcocorr[3:0] = VCO Current Correction value
vcocur[1:0] = VCO Current Trim value</Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov='0' the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov='1' the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives '1' if the calibration process has been finished.
vcocal[6:0] = VCO Calibration Results</Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="vcotype" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>dsmdt = Enable DSM ditherting. If low, dithering is disabled.
vcotype = VCO Type.
0 - basic, constant K	1 - single varactor, changing K
enoloop = Open Loop Mode enable
dsmod = Delta-Sigma Modulus
0 - 64000	1 - 65 536
dsorder[1:0] = Delta-Sigma Order
00 - 	0 order
01 - 	1st order
10 - 	2nd order
11 - 	Mash 111
dsrstmode = Delta-Sigma Reset Mode
dsrst = Delta-Sigma Reset</Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>enmix = Mixer enable override
enlna = LNA enable override
enpga = PGA enable override
enpa = Power Amplifier enable override
enbf5 = Buffer 5 enable override
endv32 = Divider 3_2 enable override
enbf12 = Buffer 1_2 enable override
enmx2 = Multiplexer 2 enable override</Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="enldet" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>ends = Delta-Sigma enable override
enldet = Lock Detect enable (direct control, does not need override!)
enmx3 = Mutiplexer 3 enable override
enbf4 = Buffer 4 enable override
enbf3 = Buffer 3 enable override
enbf11 = Buffer 1_1 enable override
enbf2 = Buffer 2 enable override
pllreset = PLL reset enable override</Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>enfrdv = Fractional Divider enable override
endv31 = Divider 3_1 enable override
endv2 = Divider 2 enable override
endv1p5 = Divider 1.5 (div-by-1.5) enable override
dvbshunt = VCO Bias Shunt enable override mode.
envco = VCO enable override
encp = Charge Pump enable override
enbg = Bandgap enable override</Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>chfiladd[3:0] = Channel Filter Coefficient Look-up Table Address. The address for channel filter coefficients used in the RX path.  </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>chfilval[5:0] = Filter Coefficient Value in the look-up table addressed by the chfiladd[3:0]</Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>pwst[2:0] = Internal Power States of the chip
000 -	low power (stand-by / sleep / sensor)
001 -	ready
011 -	tune
010 -	TX 
010 -	RX 
clkhyst = Clock Hysteresis Setting
enbias2x = 2 times higher bias current enable
enamp2x = 2 times higher amplification enable
bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
0 - output buffer is controlled by the state machine
1 - output buffer is controlled by the enbuf bit 
enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.</Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>rccov = RC Oscillator Coarse Calibration Override. When rccov='0' the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov='1' the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>rcfov = RC Oscillator Fine Calibration Override. When rcfov='0' the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov='1' the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>enspor = Smart POR enable
enbias = Bias enable
envcoldo = VCO LDO enable
enifldo = IF LDO enable
enrfldo = RF LDO enable
enpllldo = PLL LDO enable
endigldo = Digital LDO enable
endigpwdn = Digital Power Domain Powerdown enable in Idle mode</Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="0" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>enovr = Enable Overrides (If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks).
enxtal = Xtal override enable value.
ents = temperature sensor enable.
enrc32 = 32K oscillator enable.

diglvl = digital LDO level setting</Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>adcrst = delta-sigma ADC reset
enrefdac = delta-sigma ADC reference DAC enable override
enadc = delta-sigma ADC enable override
adctuneovr = resonator RC calibration value override enable
adctune[3:0] = resonator RC calibration value</Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>envcm = delta-sigma ADC VCM enable override
adcoloop = delta-sigma ADC open loop enable
adcref[2:0] = delta-sigma ADC reference voltage
000 -	0.5 V
001 -	0.6 V
010 -	0.7 V
...
111 -	1.2 V</Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>agcen = Automatic Gain Control enable When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
lnagain = LNA Gain select
0 - min. gain = 5 dB	1 -max. gain = 25 dB
pga[3:0] = PGA Gain Override value
000 -	0 dB
001 -	3 dB
010 -	6 dB 
...
101 -	24 dB max.</Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="agcovpm" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>agcovpm  = If set, AGC will ignore the preamble detection.
agcslow = AGC Slow Gain Increase enable. When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
lnacomp[3:0] = LNA Gain Compensation, used for smoothing RSSI value when LNA gain is switched.
pgath[1:0] = window comparator reference voltage adjust in the PGA</Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.   
000 - 	i_coe0 (Default =d1)
001 - 	i_coe1 (Default =d3)
010 - 	i_coe2 (Default =d6)
011 - 	i_coe3 (Default =d10)
100 - 	i_coe4 (Default =d15)
101 - 	i_coe5 (Default =d19)
110 - 	i_coe6 (Default =d20)</Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>txpow[1:0] = TX Output Power.  The output power is configurable from +20dBm to +11dBm in ~3dBm steps.  txpow[1:0]='11' corresponds to +20dBm and '00' to +11dBm.</Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="3D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txdtrtscale" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>txdtrtscale = This bit should be set for data rates below 30 [kbps].
enphpwdn = If set, the Packet Handler will be powered down when chip is in low power mode.
manppol = Manchester Preamble Polarity (will transmit a series of '1' if set, or series of '0' if reset). This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester mode is enabled.
enmaninv = Manchester Data Inversion is enabled if this bit is set.
enmanch = Manchester Coding is enabled if this bit is set.
enwhite = Data Whitening is enabled if this bit is set.</Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>trclk[1:0] = TX Data Clock Configuration. 
00 -	No TX Data CLK is available (asynchronous mode - Can only work with modulations FSK or OOK)
01 -	TX Data CLK is available via the GPIO (one of the GPIO's should be programmed as well)
10 -	TX Data CLK is available via the SDO pin
11 -	TX Data CLK is available via the nIRQ pin
dtmod[1:0] = Modulation Source
00 - 	Direct Mode using TX_Data function via the GPIO pin (one of the GPIO's should be 	programmed accordingly as well)
01 - 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
10 - 	FIFO Mode
11 - 	PN9 (internally generated)
eninv = Invert TX and RX Data
fd[8]  = See register 72h
modtyp[1:0] = Modulation Type 
00 -	Unmodulated carrier
01 -	OOK
10 -	FSK
11 -	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)</Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>fd[7:0] = Frequency Deviation Setting. See formula above. (please see note below)
Note: It's recommended to use modulation index of 1 or higher (maximum allowable modulation index is 62). The modulation index is defined by </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>fo[7:0] = Frequency Offset Setting. Values written to it will be used during TX, reading from it will result in reading the last AFC correction value.</Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="" />
      <Bit index="4" name="" />
      <Bit index="3" name="" />
      <Bit index="2" name="" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>fo[9:8] = Upper bits of the Frequency Offset Setting. fo[9] is the sign bit. Values written to it will be used during TX, reading from it will result in reading the last AFC correction value.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>sbsel = Side Band Select.
hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-960MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]='00000' corresponds to the 240-250MHz Band for hbsel='0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0]='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.  </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold</Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="" />
      <Bit index="6" name="" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>rxafthr[5:0] = RX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>fifod[7:0] = A write (R/W='1') to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH. A Read (R/W='0') to this address will begin a burst read of the RX FIFO, in the same manner.</Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="16" type="Si4431" revision="A0" projectID="P929" name="Ara 31A0">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>dt[4:0] = Device Type Code.  This internally hardwired code will allow the user to recognize whether this is a Transmitter, Receiver, or a Transceiver.  Ara = 01000/ Tamara = 00111</Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="04" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>vc[4:0] = Version Code.  Internally hardwired version code of the chip</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="lockdet" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>ffovfl = RX/TX FIFO Overflow status.
ffunfl = RX/TX FIFO Underflow status.
rxffem = RX FIFO Empty status.
headerr = Header Error status. The actual received packet has a header check error.
freqerr = Frequency Error status. The programmed frequency is outside of the operating range. The actual frequency is saturated to the max/min value.
lockdet = Synthesizer Lock Detect status. 
cps[1:0] = Chip Power State:
00 -	Idle State
01 -	RX State
10 -	TX State</Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>ifferr = FIFO Underflow/Overflow Error.  When set to '1' the TX or RX FIFO has overflowed or underflowed.
itxffafull = TX FIFO Almost Full.  When set to '1' the TX FIFO has met its almost full threshold and needs to be transmitted.
itxffaem= TX FIFO Almost Empty.  When set to '1' the TX FIFO is almost empty and needs to be filled.
irxffafull = RX FIFO Almost Full.  When set to '1' the RX FIFO has met its almost full threshold and needs to be read by the microcontroller
iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
ipksent = Packet Sent Interrupt. When set to'1' a valid packet has been transmitted.
ipkvalid =  Valid Packet Received. When set to '1' a valid packet has been received.
icrcerror = CRC Error. When set to '1' the cyclic redundancy check is failed.  
When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
Bit
Status Name
Set/Clear conditions:
[7]
ifferr
Set if there is a Tx or RX FIFO Overflow or Underflow.  It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
[6]
itxffafull
Will be set when the number of bytes written to TX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we start transmitting and the FIFO data is read out and the number of bytes left in the FIFO is smaller or equal to the threshold).
[5]
itxffaem
Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
[4]
irxffafull
Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we read enough data from RX FIFO so that the number of data bytes not yet read is below the Almost Full threshold.
[3]
iext
External interrupt source
[2]
ipksent
Will go high once a packet is sent all the way through (no TX abort). This status will be cleaned if 1) We leave FIFO mode or 2) In FIFO mode we start a new transmission.
[1]
ipkvalid
Goes high once a packet is fully received (no RX abort). It is automatically cleaned once we receive and acknowledge the Sync Word for the next packet.
[0]
icrcerror
Goes High once the CRC computed during RX differs from the CRC sent in the packet by the TX. It is cleaned once we start receiving new data in the next packet.</Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
ipreaval = Valid Preamble Detected. When a preamble is detected this bit will be set to 1.
ipreainval = Invalid Preamble Detected. When the preamble is not found within a period of time after the RX is enabled, this bit will be set to 1.
irssi = RSSI. When RSSI level exceeds the programmed thershold this bit will be set to 1.
iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.  
ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.  
When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
Bit
Status Name
Set/Clear conditions:
[7]
iswdet
Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
[6]
ipreaval
Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
[5]
ipreainval
Self cleaning, user should use this as an interrupt source rather than a status.
[4]
irssi
Should remain high as long as the RSSI value is above programmed threshold level
[3]
iwut
Wake time timer interrupt. Use as an interrupt, not as a status.
[2]
ilbd
Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
[1]
ichiprdy
Chip ready goes high once we enable the xtal, Tx or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
[0]
ipor
Power on status. 
Invalid Preamble time is defined as:  (pm_detection_th+2)*2Tb - Where pm_detection_th is equal to the value written in register 35h (bits [7:4]) multiplied by 4, and Tb is the bit clock rate period.</Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
entxffafull = Enable TX FIFO Almost Full. When set to '1' the TX FIFO Almost Full interrupt will be enabled.
entxffaem = Enable TX FIFO Almost Empty. When set to '1' the TX FIFO Almost Empty interrupt will be enabled.
enrxffafull = Enable RX FIFO Almost Full. When set to '1' the RX FIFO Almost Full interrupt will be enabled.
enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
enpksent = Enable Packet Sent. When ipksent ='1' the Packet Sense Interrupt will be enabled.
enpkvalid = Enable Valid Packet Received. When ipkvalid = '1' the Valid Packet Received Interrupt will be  enabled
encrcerror = Enable CRC Error. When set to '1' the CRC Error  interrupt will be enabled.</Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>enswdet = Enable Sync Word Detected. When mpreadet ='1' the Preamble Detected Interrupt will be enabled.
enpreaval = Enable Valid Preamble Detected. When mpreadet ='1' the Valid Preamble Detected Interrupt will be enabled.
enpreainval = Enable Invalid Preamble Detected. When mpreadet ='1' the Invalid Preamble Detected Interrupt will be enabled.
enrssi = Enable RSSI. When set to '1' the RSSI Interrupt will be  enabled.
enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.</Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.  
enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.  
enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
txon = TX on in manual transmit mode. It is automatically cleared in FIFO mode once the packet is sent.
rxon = RX on in manual receiver mode. It is automatically cleared if Multiple Packets config. is disabled and a valid packet received.
pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.  
xton = READY Mode (Xtal is ON).</Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="ffclrtx" />
      <Description>antdiv[2:0] = Enable Antenna Diversity. The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
	RX/TX state	non RX/TX state
	GPIO Ant1	GPIO Ant2	GPIO Ant1	GPIO Ant2
000 - 	1	0	0	0
001 -	0	1	0	0
010 - 	1	0	1	1
011 -	0	1	1	1
100 -	antenna diversity algorythm	0	0
101 - 	antenna diversity algorythm	1	1 
110 -	ant. div. algorythm in beacon mode	0	0
111 - 	ant. div. algorythm in beacon mode 		1	1
rxmpk = RX Multi Packet. When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the transceiver will automatically leave the RX State after the first valid packet has been received.
autotx = Automatic Transmission. When autotx = '1' the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.  
enldm = Enable Low Duty Cycle Mode. If this bit is set to '1' then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
ffclrrx = RX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrrx='1' followed by ffclrrx= '0' will clear the contents of the RX FIFO. 
ffclrtx = TX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrtx='1' followed by ffclrtx= '0' will clear the contents of the TX FIFO.</Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>xtalshft = Direct control to Analog
xlc[6:0] = Tuning Capacitance for the 30MHz XTAL</Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>clkt[1:0] = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
00 - 	0 cycle
01 - 	128 cycles
10 - 	256 cycles
11 - 	512 cycles 
enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = '1' except the '111'.  
000 - 	30 MHz
001 - 	15 MHz
010 - 	10 MHz
011 - 	4 MHz
100 - 	3 MHz
101 - 	2 MHz
110 - 	1 MHz
111 -	32.768 kHz</Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>gpiodrv0[1:0] - Gpio driving capability setting
pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio0[4:0] = GPIO0pin function select:
00000 - 	Power-On-Reset (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>gpiodrv1[1:0] - Gpio driving capability setting
pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio1[4:0] = GPIO1 pin function select:
00000 - 	Power-On-Reset Inverted (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>gpiodrv2[1:0] - Gpio driving capability setting
pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
gpio2[4:0] = GPIO2 pin function select:
00000 - Microcontroller Clock (output)
00001 - 	Wake-Up Timer: '1' when WUT has expired  (output)
00010 - 	Low Battery Detect: '1' when battery is below threshold setting (output)
00011 - 	Direct Digital Input
00100 -	External Interrupt, falling edge (input)
00101 - 	External Interrupt, rising edge (input)
00110 - 	External Interrupt, state change (input)
00111 -	ADC Analog Input
01000 -	Reserved (Analog Test N Intput)
01001 -	Reserved (Analog Test P Intput)
01010 -	Direct Digital Output
01011 -	Reserved (Digital Test Output)
01100 -	Reserved (Analog Test N Output)
01101 -	Reserved (Analog Test P Output)
01110 -	Reference Voltage (output)
01111 -	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
10000 -	TX Data input for direct modulation (input)
10001 -	External Retransmission Request (input)
10010 -	TX State (output)
10011 -	TX FIFO Almost Full  (output)
10100 -	RX Data (output) 
10101 -	RX State (output) 
10110 -	RX FIFO Almost Full  (output)
10111 -	Antenna 1 Switch used for antenna diversity  (output)
11000 -	Antenna 2 Switch used for antenna diversity  (output)
11001 -	Valid Preamble Detected  (output)
11010 -	Invalid Preamble Detected  (output)
11011 -	Sync Word Detected  (output)
11100 -	Clear Channel Assessement  (output)
11101 -	VDD
else    -	GND</Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.</Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart / adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>adcstart / adcdone = ADC Measurement Start bit. Reading this bit gives '1' if the ADC measurement cycle has been finished.
adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
000 -	Internal Temperature Sensor
001 -	GPIO0, single-ended
010 -	GPIO1, single-ended
011 - 	GPIO2, single-ended
100 -	GPIO0(+) - GPIO1(-), differential
101 -	GPIO1(+) - GPIO2(-), differential
110 -	GPIO0(+) - GPIO2(-), differential
111 -	GND, ADC is disabled
adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
0X -	bandgap voltage (1.2V)
10 -	VDD / 3
11 - 	VDD / 2
adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
adcref[0] = 0:	adcref[0] = 1:
FS = 0.014 * (adcgain[1:0] + 1) * VDD 	FS = 0.021 * (adcgain[1:0] + 1) * VDD</Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.</Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
00 -	-40oC .. 64oC (full operating range), with 0.5oC resolution (1 LSB in the 8 bit ADC)
01 -	-40oC .. 85oC, with 1oC resolution (1 LSB in the 8 bit ADC)
11 -	   0oC .. 85oC, with 0.5oC resolution (1 LSB in the 8 bit ADC)
10 -	-40oF .. 216oF, with 1oF resolution (1 LSB in the 8 bit ADC)
entsoffs = Temperature Sensor Offset to convert from K to oC.
entstrim = Temperature Sensor Trim enable
tstrim[3:0] = Temperature Sensor Trim value</Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)</Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description>wtr[4:0] = Wake Up Timer Exponent (R) value.  See formula above.</Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>wtm[15:8] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>wtm[7:0] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>wtm[15:8] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>wtm[7:0] = Wake Up Timer Current Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>ldc[7:0] = Low-Duty Cycle Mode Duration (LDC).  See formula above</Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>lbdt[4:0] = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.</Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continouosly.</Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>dwn3_bypass = Bypass decimator by 3 (if set).
ndec_exp[2:0] = IF Filter decimation rates
filset[3:0] = IF Filter coefficient sets ; defauts are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz
When the required bandwidth (BW) is calculated then the three filter parameters, ndec_exp, dwn3_bypass and filset, can be found from the table below. When the calculated bandwidth value is not exactly available then select the higher available bandwidth closest to the calculated bandwidth.
BW [kHz]
ndec_exp
1C-[6:4]
dwn3_bypass
1C-[7]
filset
1C-[3:0]
BW [kHz]
ndec_exp
1C-[6:4]
dwn3_bypass
1C-[7]
filset
1C-[3:0]
2.6
5
0
1
41.7
1
0
2
2.8
5
0
2
45.2
1
0
3
3.1
5
0
3
47.9
1
0
4
3.2
5
0
4
56.2
1
0
5
3.7
5
0
5
64.1
1
0
6
4.2
5
0
6
69.2
1
0
7
4.5
5
0
7
75.2
0
0
1
4.9
4
0
1
83.2
0
0
2
5.4
4
0
2
90.0
0
0
3
5.9
4
0
3
95.3
0
0
4
6.1
4
0
4
112.1
0
0
5
7.2
4
0
5
127.9
0
0
6
8.2
4
0
6
137.9
0
0
7
8.8
4
0
7
142.8
1
1
4
9.5
3
0
1
167.8
1
1
5
10.6
3
0
2
181.1
1
1
9
11.5
3
0
3
191.5
0
1
15
12.1
3
0
4
225.1
0
1
1
14.2
3
0
5
248.8
0
1
2
16.2
3
0
6
269.3
0
1
3
17.5
3
0
7
284.9
0
1
4
18.9
2
0
1
335.5
0
1
8
21.0
2
0
2
361.8
0
1
9
22.7
2
0
3
420.2
0
1
10
24.0
2
0
4
468.4
0
1
11
28.2
2
0
5
518.8
0
1
12
32.2
2
0
6
577.0
0
1
13
34.7
2
0
7
620.7
0
1
14
37.7
1
0
1</Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="spare" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="afcgearl[2]" />
      <Bit index="1" name="afcgearl[1]" />
      <Bit index="0" name="afcgearl[0]" />
      <Description>spare register
enafc = AFC enable
afcgearh[2:0] = AFC High Gear Setting
afcgearl[2:0] = AFC Low Gear Setting</Description>
    </Register>
    <Register address="1E" name="AFC Timing Control" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="anwait[2]" />
      <Bit index="1" name="anwait[1]" />
      <Bit index="0" name="anwait[0]" />
      <Description>shwait[2:0] = short wait periods after AFC correction used before preamble is detected. Short wait = (RegValue+1)*2Tb. If set to '0' then no AFC correction will occur before preamble detect, i.e. AFC will be disabled. 
anwait[2:0] = antenna switching wait time, in bit count resolution.</Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="rxready" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>rxready = improves receiver noise immunity when in direct mode. It is recommended to set this bit after preamble is detected. When in FIFO mode this bit should be set to '0' since noise immunity is controlled automatically.
crfast[2:0] = Clock Recovery Fast Gearshift value
crslow[2:0] = Clock Recovery Slow Gearshift value</Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>rxosr[7:0] = Oversampling Rate, 3 LSBs are the fraction
default = 0110 0100 = 12.5 clock cycles per data bit</Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="stallctrl" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>rxosr[10:8] = Oversampling Rate, upper bits
stallctrl = Used for BCR purposes
ncoff[19:16] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>ncoff[15:8] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>ncoff[7:0] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>crgain[10:8] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>crgain[7:0] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>rssi[7:0] = Received Signal Strength Indicator value</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="1E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>rssith[7:0] = RSSI Threshold. Interrupt is set if the RSSI value is above this threshold.</Description>
    </Register>
    <Register address="28" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>adrssi1[7:0] = Measured RSSI value on antenna 1</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description>adrssi2[7:0] = Measured RSSI value on antenna 2</Description>
    </Register>
    <Register address="2A" name="AFC Limiter" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Afclim[7]" />
      <Bit index="6" name="Afclim[6]" />
      <Bit index="5" name="Afclim[5]" />
      <Bit index="4" name="Afclim[4]" />
      <Bit index="3" name="Afclim[3]" />
      <Bit index="2" name="Afclim[2]" />
      <Bit index="1" name="Afclim[1]" />
      <Bit index="0" name="Afclim[0]" />
      <Description>AFC Limiter[7:0] = AFC limiter value.
For the following registers (addresses 2Bh and 2Ch), use the following equation:</Description>
    </Register>
    <Register address="2B" name="AFC Correction Read" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[8]" />
      <Bit index="5" name="afc_corr[7]" />
      <Bit index="4" name="afc_corr[6]" />
      <Bit index="3" name="afc_corr[5]" />
      <Bit index="2" name="afc_corr[4]" />
      <Bit index="1" name="afc_corr[3]" />
      <Bit index="0" name="afc_corr[2]" />
      <Description>AFC Correction Values = AFC loop correction values [9:2]  (MSB's only). Values are updated once, after sync word is found during receiving. See also address 2Ch.</Description>
    </Register>
    <Register address="2C" name="OOK Counter Value 1" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[1]" />
      <Bit index="6" name="afc_corr[0]" />
      <Bit index="5" name="ookfrzen" />
      <Bit index="4" name="peakdeten" />
      <Bit index="3" name="madeten" />
      <Bit index="2" name="ookcnt[10]" />
      <Bit index="1" name="ookcnt[9]" />
      <Bit index="0" name="ookcnt[8]" />
      <Description>AFC Correction Values = AFC loop correction values [1:0] (LSB's). Values are updated once, after sync word is found during receiving. See also address 2Bh.
OOK Freeze = OOK AGC freeze if this bit is set.
Peak Detector Enable = Peak detector enable if high.
MA_ Enable  = MA block enable if high.
OOK Counter [10:8] = OOK counter Value MSBs</Description>
    </Register>
    <Register address="2D" name="OOK Counter Value 2" size="8" defaultVal="BC" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ookcnt[7]" />
      <Bit index="6" name="ookcnt[6]" />
      <Bit index="5" name="ookcnt[5]" />
      <Bit index="4" name="ookcnt[4]" />
      <Bit index="3" name="ookcnt[3]" />
      <Bit index="2" name="ookcnt[2]" />
      <Bit index="1" name="ookcnt[1]" />
      <Bit index="0" name="ookcnt[0]" />
      <Description>OOK Counter [7:0] = OOK counter Value LSBs.</Description>
    </Register>
    <Register address="2E" name="Slicer Peak Hold" size="8" defaultVal="26" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserv." />
      <Bit index="6" name="attack[2]" />
      <Bit index="5" name="attack[1]" />
      <Bit index="4" name="attack[0]" />
      <Bit index="3" name="decay[3]" />
      <Bit index="2" name="decay[2]" />
      <Bit index="1" name="decay[1]" />
      <Bit index="0" name="decay[0]" />
      <Description>Reserved
attack[2:0] = .
decay [3:0] = .</Description>
    </Register>
    <Register address="2F" name="***** RESERVED *******" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="*" />
      <Bit index="6" name="*" />
      <Bit index="5" name="*" />
      <Bit index="4" name="*" />
      <Bit index="3" name="*" />
      <Bit index="2" name="*" />
      <Bit index="1" name="*" />
      <Bit index="0" name="*" />
      <Description></Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="reserv." />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>enpacrx = Enable Packet RX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpacrx='1' will enable automatic packet handling in the RX path. Register 30-4D allow for various configurations of the packet structure. Setting enpacrx='0' will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
lsbfrst = LSB First enable. The LSB of the data will be transmitted/received first if this bit is set.
crcdonly = CRC Data Only enable When this bit is set to '1' the CRC is calculated on and check against the packet data fields only.
reserved
enpactx = Enable Packet TX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpactx='1' will enable automatic packet handling in the TX path. Register 30-4D allow for various configurations of the packet structure. Setting enpactx='0' will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
crc[1:0] = CRC polynomial selection.
00 -	CCITT
01 -	CRC-16 (IBM)
10 -	IEC-16
11 -	Biacheva</Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="rxcrc1" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>rxcrc1 = If high, it indicates the last CRC received is all one's. May indicated Transmitter underflow in case of CRC error.
pksrch = Packet Searching. When pksrch = '1' the radio is searching for a valid packet.  
pkrx = Packet Receiving. When pkrx = '1' the radio is currently receiving a valid packet. 
pkvalid = Valid Packet Received. When a pkvalid = '1' a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
crcerror = CRC Error.  When crcerror = '1' a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
pktx = Packet Transmitting. When pktx = '1' the radio is currently transmitting a packet.
pksent = Packet Sent.  A pksent  = '1' a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)</Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enbcast[1]" />
      <Bit index="6" name="enbcast[1]" />
      <Bit index="5" name="enbcast[1]" />
      <Bit index="4" name="enbcast[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>bcen[3:0] = Broadcast Address (FFh) Check enable.  If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
0000 -	No broadcast address enable.
0001 -	Broadcast address enable for header byte 0.
0010 -	Broadcast address enable for header byte 1.
0011 -	Broadcast address enable for header bytes 0 &amp; 1.
0100 -	...
hdch[3:0] = Received Header bytes to be checked against the Check Header bytes.  One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.   
0000 -	No Received Header check
0001 -	Received Header check for byte 0.  
0010 -	Received Header check for bytes 1.
0011 -	Received header check for bytes 0 &amp; 1.
0100 -	...</Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>hdlen[2:0] = Transmit/Receive Header Length. Length of header used if packet handler is enabled for TX/RX (enpactx/rx). Headers are transmitted/received in descending order.  
000 -	NoTX/RX header
001 - 	Header 3
010 - 	Header 3 and 2
011 - 	Header 3 and 2 and 1
100 - 	Header 3 and 2 and 1 and 0
fixpklen = Fix Transmit/Receive Packet Length.  When fixpklen = '1' the packet length (pklen[7:0]) is not included in the header. When fixpklen = '0' the packet length is included in the header.
synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
00 - 	Synchronization Word 3 
01 - 	Synchronization Word 3 and 2
10 - 	Synchronization Word 3 and 2 and 1
11 - 	Synchronization Word 3 and 2 and 1 and 0
prealen[8] = MSB of Preamble Length. See register Preamble Length.</Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register  corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = '000001000'  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = '111111111' which corresponds to a 255 Bytes Preamble. Writing '0' will have the same result as if writing '1', which will send one single nibble of preamble.</Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description>preath[4:0] = Number of nibbles processed during detection.
rssi_offset[2:0] = Value added as offset to RSSI calculation. Every increment in this register results in an increment of +4dB in the RSSI.</Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] - Packet Length.  The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = '00001000' corresponds to a packet length of 8 Bytes.  The maximum packet length is pklen[7:0] = '11111111', a 255 byte packet. Writing '0' is possible, in this case we do not send any data in the packet. During RX, if fixpklen = 1, this will specify also the Packet Length for RX mode.</Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>chhd[31:24] = Check Header 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>chhd[23:16] = Check Header 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>chhd[15:8] = Check Header 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>chhd[7:0] = Check Header 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>hden[31:24] = Header Enable 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>hden[23:16] = Header Enable 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>hden[15:8] = Header Enable 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>hden[7:0] = Header Enable 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>rxhd[31:24] = Received Header 3. 4th byte of the received header.</Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>rxhd[23:16] = Received Header 2. 3rd byte of the received header.</Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>rxhd[15:8] = Received Header 1. 2nd byte of the received header.</Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>rxhd[7:0] = Received Header  0. 1st byte of the received header.</Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>rxplen[7:0] = Length byte of the received packet during fixpklen = 0 (specifies the number of Data bytes in the last received packet). This will be relevant  ONLY if fixpklen ( address 33h, bit[3]) is low during the receive time. If fixpklen is high, then the number of received Data Bytes can be read from the pklen register (address h3E).</Description>
    </Register>
    <Register address="4C" name="***** RESERVED *******" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="*" />
      <Bit index="6" name="*" />
      <Bit index="5" name="*" />
      <Bit index="4" name="*" />
      <Bit index="3" name="*" />
      <Bit index="2" name="*" />
      <Bit index="1" name="*" />
      <Bit index="0" name="*" />
      <Description></Description>
    </Register>
    <Register address="4D" name="***** RESERVED *******" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="*" />
      <Bit index="6" name="*" />
      <Bit index="5" name="*" />
      <Bit index="4" name="*" />
      <Bit index="3" name="*" />
      <Bit index="2" name="*" />
      <Bit index="1" name="*" />
      <Bit index="0" name="*" />
      <Description></Description>
    </Register>
    <Register address="4E" name="***** RESERVED *******" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="*" />
      <Bit index="6" name="*" />
      <Bit index="5" name="*" />
      <Bit index="4" name="*" />
      <Bit index="3" name="*" />
      <Bit index="2" name="*" />
      <Bit index="1" name="*" />
      <Bit index="0" name="*" />
      <Description></Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description>ADC8 Control bits = Default value is all zeros.</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>atb[4:0] = Analog Test Bus.  The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
Internal analog signals available on the Analog Test Bus:
atb[4:0]
GPIOx
GPIOx
1
MixIp
MixIn
2
MixQp
MixQn
3
PGA_Ip
PGA_In
4
PGA_QP
PGA_Qn
5
ADC_vcm
ADC_vcmb
6
ADC_ipoly10u
ADC_ref
7
ADC_Refdac_p
ADC_Refdac_n
8
ADC_ipoly10
ADC_ipoly10
9
ADC_Res1Ip
ADC_Res1In
10
ADC_Res1Qp
ADC_Res1Qn
11
spare
spare
12
spare
spare
13
spare
spare
14
spare
spare
15
spare
spare
16
spare
spare
17
spare
spare
18
ICP_Test
PLL_IBG_05
19
PLL_VBG
VSS_VCO
20
Vctrl_Test
PLL_IPTAT_05
21
PA_vbias
spare
22
DIGBG
DIGVFB
23
IFBG
IFVFB
24
PLLBG
PLLVReg
25
IBias10u
IBias5u
26
32KRC_Ucap
32KRC_Ures
27
ADC8_VIN
ADC8_VDAC
28
LBDcomp
LBDcompref
29
TSBG
TSVtemp
30
RFBG
RFVREG
31
VCOBG
VCOVREG</Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>ensctest = Scan Test Enable. When set to '1' then GPIO0 will be the ScanEn input.
dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
Internal digital signals available on the Digital Test Bus:
dtb[4:0]
GPIO0
Signal
GPIO1
Signal
GPIO2
Signal
0
wkup_clk_32k
wake-up 32kHz clock
rbase_en
first divided clock
clk_base
timebase clock
1
wkup_clk_32k
wake-up 32kHz clock
wake_up
wake-up event
tm1sec
1 sec timebase
2
ts_adc_en
aux. ADC enable
adc_rdy_n
aux. ADC conversion ready
adc_done
aux. ADC measurement done
3
cont_lbd
low battery continouos mode
lbd_on
low battery ON signal
lbd
unfiltered output of LBD
4
div_clk_g
gated divided clock
uc_clk
microcontroller clock
ckout_rcsel
slow clock selected
5
en_div_sync
clock divider enable (sync'ed)
en_ckout
clock out enable
en_ckout_s
clock out enable (sync'ed)
6
osc30_en
oscillator enable
osc30_bias2x
oscillator bias control
xok
chip ready
7
xok
chip ready
zero_cap
cap. load zero
osc30_buff_en
buffer enable
8
tsadc_needed
aux. ADC enable
ext_retran
ext. retransmission request
tx_mod_gpio
TX modulation inpit
9
gpio_0_oen_n
GPIO0 output enable
gpio_0_aen
GPIO0 analog selection
gpio_0_aden
GPIO0 ADC input line enable
10
int_ack1
interrupt acknowledge 1
int_ack2
interrupt acknowledge 2
int_store
interrupt latch closed
11
ext_int2
ext. interrupt from GPIO2
irq_bit8
combined external status
msk_bit8
combined masked ext. int.
12
sdo_aux_sel
SDO aux. function select
sdo_aux
SDO aux. signal
nirq_aux_sel
nIRQ aux. function select
13
trdata_on_sdi
TX/RX data on SDI
tx_mod
TX modulation input
tx_clk_out
TX clock output
14
start_full_sync
RC osc. full calibration start
start_fine_sync
RC osc. fine calibration start
xtal_req
crystal req. for RC osc. cal.
15
coarse_rdy
RC osc. coarse cal. ready
fine_rdy
RC osc. fine cal. ready
xtal_req_sync
sync'ed crystal request
16
vco_cal_rst_s_n
VCO calibration reset
vco_cal
VCO calibration is running
vco_cal_done
VCO calibration done
17
vco_cal_en
VCO calibration enable
en_ref_cnt
reference counter enable
en_freq_cnt_s
frequency counter enable
18
vco_cal_en
VCO calibration enable
pos_diff
positive difference to goal
en_freq_cnt_s
frequency counter enable
19
dsm_clk_mux
DSM multiplexed clock
pll_fb_clk_tst
PLL feedback clock
pll_ref_clk_tst
PLL reference clock
20
dsm[0]
delta-sigma output
dsm[1]
delta-sigma output
dsm[2]
delta-sigma output
21
dsm[3]
delta-sigma output
pll_fbdiv15
dsm_rst_s_n
delta-sigma reset
22
pll_en
PLL enable: TUNE state
pllt0_ok
PLL initial settling OK
pllts_ok
PLL soft settling OK
23
ch_freq_req
frequency change request
pllts_ok
PLL soft settling OK
vco_cal_done
VCO calibration done
24
vco_cal_en
VCO calibration enable
pll_vbias_shunt_en
VCO bias shunt enable
prog_req
frequency recalculation req.
25
bandgap_en
bandgap enable
frac_div_en
fractional divider enable
buff3_en
buffer3 enable
26
pll_pfd_up
PFD up signal
pll_pfd_down
PFD down signal
pfd_up_down
PFD output change (XOR'ed)
27
pll_lock_detect
PLL lock detect
pll_en
PLL enable: TUNE state
pllt0_ok
PLL initial settling OK
28
pll_en
PLL enable: TUNE state
pll_lock_detect
PLL lock detect
pllts_ok
PLL soft settling OK
29
pwst[0]
internal power state
pwst[1]
internal power state
pwst[2]
internal power state
Internal digital signals available on the Digital Test Bus (continued from the previous page):
dtb[4:0]
GPIO0
Signal
GPIO1
Signal
GPIO2
Signal
30
xok
chip ready: READY state
pll_en
PLL enable: TUNE state
tx_en
TX enable: TX state
31
ts_en
temperature sensor enable
auto_tx_on
automatic TX ON
tx_off
TX OFF
32
ch_freq_req
frequency change request
return_tx
return from TX
pk_sent
packet sent
33
retran_req
retransmission request
tx_ffpt_store
TX FIFO pointer store
tx_ffpt_restore
TX FIFO pointer restore
34
pa_on_trig
PA ON trigger
dly_5us_ok
5 us delay expired
mod_dly_ok
modulator delay expired
35
tx_shdwn
TX shutdown
ramp_start
modulator ramp down start
ramp_done
modulator ramp down ended
36
pk_sent_dly
delayed packet sent
tx_shdwn_done
TX shutdown done
pa_ramp_en
PA ramp enable
37
tx_en
TX enable: TX state
ldo_rf_precharge
RF LDO precharge
pa_ramp_en
PA ramp enable
38
pa_on_trig
TX enable: TX state
dp_tx_en
packet handler (TX) enable
mod_en
modulator enable
39
reg_wr_en
register write enable
reg_rd_en
register rdead enable
addr_inc
register address increment
40
dp_tx_en
packet handler (TX) enable
data_start
start of TX data
pk_sent
packet has been sent
41
data_start
start of TX data
tx_out
packet handler TX data out
pk_sent
packet has been sent
42
ramp_done
ramp is done
data_start
start of TX data
pk_tx
packet is being transmitted
43
tx_ffaf
TX FIFO almost full
tx_fifo_wr_en
TX FIFO write enable
tx_ffem_tst
internal TX FIFO empty
44
clk_mod
modulator gated 10MHz clock
tx_clk
TX clock from NCO
rd_clk_x8
read clock = tx_clk / 10
45
mod_en
modulator enable
ramp_start
start modulator ramping down
ramp_done
modulator ramp done
46
data_start
data input start from PH
ook_en
OOK modulation enable
ook (also internal PN9)
OOK modulation
47
prog_req
freq. channel update request
freq_err
wrong freq. indication
dsm_rst_s_n
dsm sync. reset
48
mod_en
modulator enable
tx_rdy
TX ready
tx_clk
TX clock from NCO
49
dp_rx_en
packet handler (RX) enable
prea_valid
valid preamble
pk_srch
packet is being searched
50
pk_srch
packet is being searched
sync_ok
sync. word has been detected
rx_data
packet handler RX data input
51
pk_rx
packet is being received
sync_ok
sync. word has been detected
pk_valid
valid packet received
52
sync_ok
sync. word has been detected
crc_error
CRC error has been detected
hdch_error
header error detected
53
direct_mode
direct mode
rx_ffaf
RX FIFO almost full
rx_fifo_rd_en
RX FIFO read enable
54
bit_clk
bit clock
prea_valid
valid preamble
rx_data
demodulator RX data output
55
prea_valid
valid preamble
prea_inval
invalid preamble
ant_div_sw
antenna switch (algorythm)
56
sync_ok
sync. word has been detected
bit_clk
bit clock
rx_data
demodulator RX data output
57
prea_valid
Valid preamble
Rx_dout
demodulator data out
ook_rawd
Demodulator ook raw data out
58
prea_valid
valid preamble
bcr_error
BCR error found
PM_rst
Preamble detector reset
59
agc_smp_clk
AGC sample clock
win_h_tp
window comparator high
win_l_tp
window comparator low dly'd
60
agc_smp_clk
AGC sample clock
win_h_dly_tp
window comparator high
win_l_dly_tp
window comparator low dly'd
61
ldc_on
active low duty cycle
pll_en
PLL enable: TUNE state
rx_en
RX enable: RX state
62
ldc_on
active low duty cycle
no_sync_det
no sync word detected
prea_valid
valid preamble
63
adc_en
ADC enable
adc_refdac_en
ADC reference DAC enable
adc_rst_n</Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="2F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="txmodly[2]" />
      <Bit index="5" name="txmodly[1]" />
      <Bit index="4" name="txmodly[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>txmoddly[2:0] = TX Modulation ON/OFF Delay. The time delay between PA enable and the start of the TX modulation to allow for PA ramp-up, and also the time between Pa shut down to the end of the transmission to allow for PA ramp-down.  It can be set from 0 us to 28 us in 4 us steps.  During transmission start, writing 0 or 1 will yield 4 us (same setting).
ldoramp[1:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
00 -	5 us
01 -	10 us
10 -	15 us
11 -	20 us
txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up. 
00 - 	5 us
01 - 	10 us
10 - 	15 us
11 - 	20 us</Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 us and 310 us, in 10 us intervals. The default plltime  corresponds to 100 us. See formula above.
pllt0 = PLL Settling Time (TO). This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0 us and 70 us, in 10 us steps. The default pllt0 corresponds to 20 us. See fomula above.</Description>
    </Register>
    <Register address="54" name="PA Boost" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="--" />
      <Bit index="5" name="Inv_pre_th [3]" />
      <Bit index="4" name="Inv_pre_th [2]" />
      <Bit index="3" name="Inv_pre_th [1]" />
      <Bit index="2" name="Inv_pre_th [0]" />
      <Bit index="1" name="ldo_pa_boost" />
      <Bit index="0" name="pa_vbias_boost" />
      <Description>Reserved
Invalid_preamble_Threshold[3:0]
LDO_PA_BOOST
PA_VBIAS_BOOST</Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>xtalstarthalf = If set, the Xtal wake time period is halved.
adccaldone = Delta-sigma ADC Calibration Done. Reading this bit gives '1' if the calibration process has been finished.
enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to '1' then the RC oscillator performs fine calibration in every app. 30 s.
rccal = RC Calibration Force. If setting rccal='1' will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a '0' to '1' will initiate the calibration. This bit is cleared automatically.
vcocaldp = VCO Calibration Double Precision enable. When this bit is set to '1' then the VCO calibration measures longer thus calibrates more precisely.
vcocal = VCO Calibration Force.  If in Idle Mode and pllon='1', setting vcocal='1' will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
skipvco = Skip VCO Calibration. Setting skipvco='1' will skip the VCO calibration when going from the Idle state to the TX or RX state.</Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="oscdeten" />
      <Bit index="3" name="ookth" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>bcrfbyp = If set, BCR phase compensation will be bypassed. 
slicfbyp = If set,slicer phase compensation will be bypassed.
dttype = Dithering Type: If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add +1/-1.
oscdeten  = If low, the ADC Oscillation Detection mechanism is allowed to work. If set, we disable the function.
ookth  = If set, in OOK mode, the slicer threshold will be estimated by 8 bits of preamble. By default, this bit is low and the demod estimate the threshold after 4 bits.
refclksel = Delta-sigma Reference 10 MHz Clock Source Selection (1: PLL Ref clock, 0: FeedBack divider clock)
refclkinv = Delta-sigma Reference Clock Inversion enable 
distogg = If reset, the discriminator toggling is disabled.</Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdctristate" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>pfdrst = Direct control to analog.
fbdiv_rst = Direct control to analog
cpforceup = Charge Pump Force Up
cpforcedn = Charge Pump Force Down
cdctristate = Charge Pump DC 
cdcurr[2:0] = Charge Pump DC Current selection</Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
cpcorrov = Charge Pump Correction Override enable
cpcorr[4:0] = Charge Pump Correction value</Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Txcor boosten" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>txcorboosten = If this is set, then vcocorr (reg 5A[5:2]) = 1111 during TX mode and VCO CAL followed by TX.
fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
d3trim[1:0] = Divider 3 Current Trim value
d2trim[1:0] = Divider 2 Current Trim value
d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value</Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Txcur boosten" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>txcurboosten = If this is set, then vcocur = 11 during TX mode and VCO CAL followed by TX.
vcocorrov = VCO Current Correction override
vcocorr[3:0] = VCO Current Correction value
vcocur[1:0] = VCO Current Trim value</Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov='0' the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov='1' the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives '1' if the calibration process has been finished.
vcocal[6:0] = VCO Calibration Results</Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="vcotype" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>dsmdt = Enable DSM ditherting. If low, dithering is disabled.
vcotype = VCO Type.
0 - basic, constant K	1 - single varactor, changing K
enoloop = Open Loop Mode enable
dsmod = Delta-Sigma Modulus
0 - 64000	1 - 63997
dsorder[1:0] = Delta-Sigma Order
00 - 	0 order
01 - 	1st order
10 - 	2nd order
11 - 	Mash 111
dsrstmode = Delta-Sigma Reset Mode
dsrst = Delta-Sigma Reset</Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>enmix = Mixer enable override
enlna = LNA enable override
enpga = PGA enable override
enpa = Power Amplifier enable override
enbf5 = Buffer 5 enable override
endv32 = Divider 3_2 enable override
enbf12 = Buffer 1_2 enable override
enmx2 = Multiplexer 2 enable override</Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="enldet" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>ends = Delta-Sigma enable override
enldet = Lock Detect enable (direct control, does not need override!)
enmx3 = Mutiplexer 3 enable override
enbf4 = Buffer 4 enable override
enbf3 = Buffer 3 enable override
enbf11 = Buffer 1_1 enable override
enbf2 = Buffer 2 enable override
pllreset = PLL reset enable override</Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>enfrdv = Fractional Divider enable override
endv31 = Divider 3_1 enable override
endv2 = Divider 2 enable override
endv1p5 = Divider 1.5 (div-by-1.5) enable override
dvbshunt = VCO Bias Shunt enable override mode.
envco = VCO enable override
encp = Charge Pump enable override
enbg = Bandgap enable override</Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>chfiladd[3:0] = Channel Filter Coefficient Look-up Table Address. The address for channel filter coefficients used in the RX path.  </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>chfilval[5:0] = Filter Coefficient Value in the look-up table addressed by the chfiladd[3:0]</Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>pwst[2:0] = Internal Power States of the chip
000 -	low power (stand-by / sleep / sensor)
001 -	ready
011 -	tune
010 -	TX 
111 -	RX 
clkhyst = Clock Hysteresis Setting
enbias2x = 2 times higher bias current enable
enamp2x = 2 times higher amplification enable
bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
0 - output buffer is controlled by the state machine
1 - output buffer is controlled by the enbuf bit 
enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.</Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>rccov = RC Oscillator Coarse Calibration Override. When rccov='0' the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov='1' the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>rcfov = RC Oscillator Fine Calibration Override. When rcfov='0' the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov='1' the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results</Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>enspor = Smart POR enable
enbias = Bias enable
envcoldo = VCO LDO enable
enifldo = IF LDO enable
enrfldo = RF LDO enable
enpllldo = PLL LDO enable
endigldo = Digital LDO enable
endigpwdn = Digital Power Domain Powerdown enable in Idle mode</Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="0" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>enovr = Enable Overrides (If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks).
enxtal = Xtal override enable value.
ents = temperature sensor enable.
enrc32 = 32K oscillator enable.

diglvl = digital LDO level setting</Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>adcrst = delta-sigma ADC reset
enrefdac = delta-sigma ADC reference DAC enable override
enadc = delta-sigma ADC enable override
adctuneovr = resonator RC calibration value override enable
adctune[3:0] = resonator RC calibration value</Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>envcm = delta-sigma ADC VCM enable override
adcoloop = delta-sigma ADC open loop enable
adcref[2:0] = delta-sigma ADC reference voltage
000 -	0.5 V
001 -	0.6 V
010 -	0.7 V
111 -	1.2 V</Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>agcen = Automatic Gain Control enable When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
lnagain = LNA Gain select
0 - min. gain = 5 dB	1 -max. gain = 25 dB
pga[3:0] = PGA Gain Override value
000 -	0 dB
001 -	3 dB
010 -	6 dB 
101 -	24 dB max.</Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="agcovpm" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>agcovpm  = If set, AGC will ignore the preamble detection.
agcslow = AGC Slow Gain Increase enable. When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
lnacomp[3:0] = LNA Gain Compensation, used for smoothing RSSI value when LNA gain is switched.
pgath[1:0] = window comparator reference voltage adjust in the PGA</Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.   
000 - 	i_coe0 (Default =d1)
001 - 	i_coe1 (Default =d3)
010 - 	i_coe2 (Default =d6)
011 - 	i_coe3 (Default =d10)
100 - 	i_coe4 (Default =d15)
101 - 	i_coe5 (Default =d19)
110 - 	i_coe6 (Default =d20)</Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="lna_sw" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>lna_sw = LNA switch controller.  If set, lna_sw control from the digital will go high during TX modes, and low during other times. If reset, the digital control signal is low at ALL times.
txpow[1:0] = TX Output Power.  The output power is configurable from +13dBm to -8dBm in ~3dBm steps.  txpow[2:0]='111' corresponds to +13dBm and '000' to -8dBm.</Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="3D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="txdtrtscale" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>txdtrtscale = This bit should be set for data rates below 30 [kbps].
enphpwdn = If set, the Packet Handler will be powered down when chip is in low power mode.
manppol = Manchester Preamble Polarity (will transmit a series of '1' if set, or series of '0' if reset). This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester mode is enabled.
enmaninv = Manchester Data Inversion is enabled if this bit is set.
enmanch = Manchester Coding is enabled if this bit is set.
enwhite = Data Whitening is enabled if this bit is set.</Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>trclk[1:0] = TX Data Clock Configuration. 
00 -	No TX Data CLK is available (asynchronous mode - Can only work with modulations FSK or OOK)
01 -	TX Data CLK is available via the GPIO (one of the GPIO's should be programmed as well)
10 -	TX Data CLK is available via the SDO pin
11 -	TX Data CLK is available via the nIRQ pin
dtmod[1:0] = Modulation Source
00 - 	Direct Mode using TX_Data function via the GPIO pin (one of the GPIO's should be 	programmed accordingly as well)
01 - 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
10 - 	FIFO Mode
11 - 	PN9 (internally generated)
eninv = Invert TX and RX Data
fd[8]  = See register 72h
modtyp[1:0] = Modulation Type 
00 -	Unmodulated carrier
01 -	OOK
10 -	FSK
11 -	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)</Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>fd[7:0] = Frequency Deviation Setting. See formula above. (please see note below)
Note: It's recommended to use modulation index of 1 or higher (maximum allowable modulation index is 62). The modulation index is defined by </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>fo[7:0] = Frequency Offset Setting. Values written to it will be used during TX, reading from it will result in reading the last AFC correction value.</Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="-" />
      <Bit index="4" name="-" />
      <Bit index="3" name="-" />
      <Bit index="2" name="-" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>fo[9:8] = Upper bits of the Frequency Offset Setting. fo[9] is the sign bit. Values written to it will be used during TX, reading from it will result in reading the last AFC correction value.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>sbsel = Side Band Select.
hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-960MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]='00000' corresponds to the 240-250MHz Band for hbsel='0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0]='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.  </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="78" name="Misc. Settings" size="8" defaultVal="09" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="Alt PA Seq" />
      <Bit index="2" name="rcosc[2]" />
      <Bit index="1" name="rcosc[1]" />
      <Bit index="0" name="rcosc[0]" />
      <Description>Reserved.
Alternative PA sequencing = If set, we will enable the alternative PA sequence. By default, this is NOT enabled.
rcosc_cal[2:0] = fine changes on the RC OSC Calibration target frequency, to help compensate for 'calibration biases'. This register should not be changed by costumers.</Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7B" name="Turn Around and 15.4" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="15.4 Lenght" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="turn_around_en" />
      <Bit index="1" name="Phase[1]" />
      <Bit index="0" name="Phase[0]" />
      <Description>15.4 Packet Length compliance If set, then PK Length definition for both TX and RX will also include the CRC bytes, If reset, then the Length refers ONLY to the DATA payload. For example, writing '9' to this register when it is set, means we are sending/expecting '7' bytes of DATA, and the other '2' should be the CRC (CRC should be enabled separately).
Turn Around Enable Enabling for the turn around functionality.
Turn Around phase The RX to TX and vice-versa change in frequency will happen (if bit [2] is set) at the last byte, and these two registers set the bit position in which the frequency shifts should occur. Make sure it does not happen to early otherwise the last bits will be missed.</Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold</Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="-" />
      <Bit index="6" name="-" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>rxafthr[5:0] = RX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>fifod[7:0] = A write (R/W='1') to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH. A Read (R/W='0') to this address will begin a burst read of the RX FIFO, in the same manner.
</Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="18" type="Si4030" revision="B0" projectID="0" name="Ara 4030-31-32_B0">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        4:0
        dt[4:0]
        Device Type Code.
        EZRadioPRO: 01000.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="05" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>
        4:0
        vc[4:0]
        Version Code.
        Code indicating the version of the chip.
        Rev A0: 00100
        Rev V2: 00011
      </Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>        7
        TX FIFO Overflow Status.
        6
        ffunfl
        TX FIFO Underflow Status.
        5:2
        Reserved
        1:0
        cps[1:0]
        Chip Power State.
        00:	Idle State
        10:	TX State</Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="Reserved" />
      <Bit index="0" name="Reserved" />
      <Description>        7
        FIFO Underflow/Overflow Error.
        When set to 1 the TX FIFO has overflowed or underflowed.
        6
        itxffafull
        TX FIFO Almost Full.
        When set to 1 the TX FIFO has met its almost full threshold and needs to be transmitted.
        5
        itxffaem
        TX FIFO Almost Empty.
        When set to 1 the TX FIFO is almost empty and needs to be filled.
        4
        Reserved
        3
        iext
        External Interrupt.
        When set to 1 an interrupt occurred on one of the GPIO   s if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        2
        ipksent
        Packet Sent Interrupt.
        When set to1 a valid packet has been transmitted.
        1:0
        Reserved
        0
        icrcerror
        CRC Error.
        When set to 1 the cyclic redundancy check is failed.
        When any of the Interrupt/Status 1 bits change state from 0 to 1 the device will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 1 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 1 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.</Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>        7
        Reserved
        6
        Reserved
        5
        Reserved
        4
        Reserved
        3
        iwut
        Wake-Up-Timer.
        On the expiration of programmed wake-up timer this bit will be set to 1.
        2
        ilbd
        Low Battery Detect.
        When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        1
        ichiprdy
        Chip Ready (XTAL).
        When a chip ready event has been detected this bit will be set to 1.
        0
        ipor
        Power-on-Reset (POR).
        When the chip detects a Power on Reset above the desired setting this bit will be set to 1.
        When any of the Interrupt/Status Register 2 bits change state from 0 to 1 the control block will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 2 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 2 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.</Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="Reserved"></Bit>
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="Reserved" />
      <Bit index="0" name="Reserved" />
      <Description>        7
        Enable FIFO Underflow/Overflow.
        When set to 1 the FIFO Underflow/Overflow interrupt will be enabled.
        6
        entxffafull
        Enable TX FIFO Almost Full.
        When set to 1 the TX FIFO Almost Full interrupt will be enabled.
        5
        entxffaem
        Enable TX FIFO Almost Empty.
        When set to 1 the TX FIFO Almost Empty interrupt will be enabled.
        4
        Reserved
        3
        enext
        Enable External Interrupt.
        When set to 1 the External Interrupt will be enabled.
        2
        enpksent
        Enable Packet Sent.
        When ipksent =1 the Packet Sense Interrupt will be enabled.
        1:0
        Reserved
        </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        7:4
        Reserved
        3
        enwut
        Enable Wake-Up Timer.
        When set to 1 the Wake-Up Timer interrupt will be enabled.
        2
        enlbd
        Enable Low Battery Detect.
        When set to 1 the Low Battery Detect interrupt will be enabled.
        1
        enchiprdy
        Enable Chip Ready (XTAL).
        When set to 1 the Chip Ready interrupt will be enabled.
        0
        enpor
        Enable POR.
        When set to 1 the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        Software Register Reset Bit.
        This bit may be used to reset all registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register. The RESET is accomplished by setting swres = 1. This bit will be automatically cleared.
        6
        enlbd
        Enable Low Battery Detect.
        When this bit is set to 1 the Low Battery Detector circuit and threshold comparison will be enabled.
        5
        enwt
        Enable Wake-Up-Timer.
        Enabled when enwt = 1. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        4
        x32ksel
        32,768 kHz Crystal Oscillator Select.
        0:	RC oscillator
        1:	32kHz crystal
        3
        txon
        TX on in Manual Transmit Mode.
        Automatically cleared in FIFO mode once the packet is sent. Transmission can be aborted during packet transmission, however, when no data has been sent yet, transmission can only be aborted after the device is programmed to    unmodulated carrier    ("Register 71h. Modulation Mode Control 2").
        2
        Reserved
        1
        pllon
        TUNE Mode (PLL is ON).
        When pllon = 1 the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        0
        xton
        READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="Reserved" />
      <Bit index="0" name="ffclrtx" />
      <Description>        7:4
        Reserved
        3
        autotx
        Automatic Transmission.
        When autotx = 1 the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.
        2:1
        Reserved
        0
        ffclrtx
        TX FIFO Reset/Clear.
        This has to be a two writes operation: Setting ffclrtx=1 followed by ffclrtx= 0 will clear the contents of the TX FIFO.
</Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>
        Additional capacitance to course shift the frequency if xlc[6:0] is not sufficient. Not binary with xlc[6:0].
        6:0
        xlc[6:0]
        Tuning Capacitance for the 30MHz XTAL.
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        5:4
        clkt[1:0]
        Clock Tail.
        If enlfc = 0 then it can be useful to provide a few extra cycles for the microcontroller to complete its operation. Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00: 	0 cycle
        01: 	128 cycles
        10: 	256 cycles
        11: 	512 cycles
        3
        enlfc
        Enable Low Frequency Clock.
        When enlfc = 1 and the chip is in Sleep mode then the 32.768kHz clock will be provided to the microcontroller no matter what the selection of mclk[2:0] is. For example if mclk[2:0] =    000   , 30MHz will be available through the GPIO to output to the microcontroller in all Idle or TX states. When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        2:0
        mclk[2:0]
        Microcontroller Clock.
        Different clock frequencies may be selected for configurable GPIO clock output. All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator. The mclk[2:0] setting is only valid when xton = 1 except the 111.
        000: 	30 MHz
        001: 	15 MHz
        010: 	10 MHz
        011: 	4 MHz
        100: 	3 MHz
        101: 	2 MHz
        110: 	1 MHz
        111:	32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>        7:6
        GPIO Driving Capability Setting.
        5
        pup0
        Pullup Resistor Enable on GPIO0.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio0[4:0]
        GPIO0 pin Function Select.
        00000: 	Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>        7:6
        GPIO Driving Capability Setting.
        5
        pup1
        Pullup Resistor Enable on GPIO1.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio1[4:0]
        GPIO1 pin Function Select.
        00000: 	Inverted Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>        7:6
        GPIO Driving Capability Setting.
        5
        pup2
        Pullup Resistor Enable on GPIO2.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio2[4:0]
        GPIO2 pin Function Select.
        00000: 	Microcontroller Clock
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        6
        extitst[2]
        External Interrupt Status.
        If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        5
        extitst[1]
        External Interrupt Status.
        If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        4
        extitst[0]
        External Interrupt Status.
        If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        3
        itsdo
        Interrupt Request Output on the SDO Pin.
        nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        2
        dio2
        Direct I/O for GPIO2.
        If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        1
        dio1
        Direct I/O for GPIO1.
        If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        0
        dio0
        Direct I/O for GPIO0.
        If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart/adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>        7
        ADC Measurement Start Bit.
        Reading this bit gives 1 if the ADC measurement cycle has been finished.
        6:4
        adcsel[2:0]
        ADC Input Source Selection.
        The internal 8-bit ADC input source can be selected as follows:
        000:	Internal Temperature Sensor
        001:	GPIO0, single-ended
        010:	GPIO1, single-ended
        011: 	GPIO2, single-ended
        100:	GPIO0(+)     GPIO1(   ), differential
        101:	GPIO1(+)     GPIO2(   ), differential
        110:	GPIO0(+)     GPIO2(   ), differential
        111:	GND
        3:2
        adcref[1:0]
        ADC Reference Voltage Selection.
        The reference voltage of the internal 8-bit ADC can be selected as follows:
        0X:	bandgap voltage (1.2V)
        10:	VDD / 3
        11: 	VDD / 2
        1:0
        adcgain[1:0]
        ADC Sensor Amplifier Gain Selection.
        The full scale range of the internal 8-bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0:	adcref[0] = 1:
        FS = 0.014 x (adcgain[1:0] + 1) x VDD 	FS = 0.021 x (adcgain[1:0] + 1) x VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>
        3:0
        adcoffs[3:0]
        ADC Sensor Amplifier Offset*.
        *Note:	 The offset can be calculated as Offset = adcoffs[2:0] x VDD / 1000; MSB = adcoffs[3] = Sign bit.
      </Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>        7:6
        Temperature Sensor Range Selection.
        (FS range is 0..1024mV)
        00:	   40uoC .. 64uoC (full operating range), with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        01:	   40uoC .. 85uoC, with 1uoC resolution (1 LSB in the 8-bit ADC)
        11:	   0uoC .. 85uoC, with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        10:	   40uoF .. 216uoF, with 1uoF resolution (1 LSB in the 8-bit ADC)
        5
        entsoffs
        Temperature Sensor Offset to Convert from K to   C.
        4
        entstrim
        Temperature Sensor Trim Enable.
        3:0
        tstrim[3:0]
        Temperature Sensor Trim Value.
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>
        Temperature Value Offset.
        This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)
        Note:	If a new configuration is needed (e.g., for the WUT or the LDC), proper functionality is required. The function must first be disabled, then the settings changed, then enabled back on.
      </Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description>
        4:0
        wtr[4:0]
        Wake Up Timer Exponent (R) Value*.
        Maximum value for R is decimal 20. A value greater than 20 will yield a result as if 20 were written. R Value = 0 can be written here.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms. R=0 is allowed, and the maximum value for R is decimal 20. A value greater than 20 will result in the same as if 20 was written.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        M[7:0] = 0 is not valid here. Write at least decimal 1.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description></Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>
        4:0
        lbdt[4:0]
        Low Battery Detector Threshold.
        This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2.7V.*
        *Note:	 The threshold can be calculated as Vthreshold = 1.7+lbdtx50mV.
      </Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        4:0
        vbat[4:0]
        Battery Voltage Level.
        The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continuously.
      </Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        6
        lsbfrst
        LSB First Enable.
        The LSB of the data will be transmitted first if this bit is set.
        5
        crcdonly
        CRC Data Only Enable.
        When this bit is set to 1 the CRC is calculated on the packet data fields only.
        4
        Reserved
        3
        enpactx
        Enable Packet TX Handling.
        If FIFO Mode (dtmod=10) is being used automatic packet handling may be enabled. Setting enpactx=1 will enable automatic packet handling in the TX path. Register 30   4D allow for various configurations of the packet structure. Setting enpactx=0 will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
        2
        encrc
        CRC Enable.
        Cyclic Redundancy Check generation is enabled if this bit is set.
        1:0
        crc[1:0]
        CRC Polynomial Selection.
        00:	CCITT
        01:	CRC-16 (IBM)
        10:	IEC-16
        11:	Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>
        7:2
        Reserved
        1:0
        Reserved
        1
        pktx
        Packet Transmitting.
        When pktx = 1 the radio is currently transmitting a packet.
        0
        pksent
        Packet Sent.
        A pksent = 1 a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcen[3]" />
      <Bit index="6" name="bcen[2]" />
      <Bit index="5" name="bcen[1]" />
      <Bit index="4" name="bcen[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description></Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        6:4
        hdlen[2:0]
        Header Length.
        Length of header used if packet handler is enabled for TX (enpactx). Headers are transmitted in descending order.
        000:	No TX header
        001: 	Header 3
        010: 	Header 3 and 2
        011: 	Header 3 and 2 and 1
        100: 	Header 3 and 2 and 1 and 0
        3
        fixpklen
        Fix Packet Length.
        When fixpklen = 1 the packet length (pklen[7:0]) is not included in the header. When fixpklen = 0 the packet length is included in the header.
        2:1
        synclen[1:0]
        Synchronization Word Length.
        The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00: 	Synchronization Word 3
        01: 	Synchronization Word 3 and 2
        10: 	Synchronization Word 3 and 2 and 1
        11: 	Synchronization Word 3 and 2 and 1 and 0
        0
        prealen[8]
        MSB of Preamble Length.
        See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>
        Preamble Length.
        The value in the prealen[8:0] register corresponds to the number of nibbles (4 bits) in the packet. For example prealen[8:0] =    000001000    corresponds to a preamble length of 32 bits (8x4bits) or 4 bytes. The maximum preamble length is prealen[8:0] = 111111111 which corresponds to a 255 bytes Preamble. Writing 0 will have the same result as if writing 1, which corresponds to one single nibble of preamble.
      </Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description></Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>
        Synchronization Word 3.
        4th byte of the synchronization word.
      </Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>
        Synchronization Word 2.
        3rd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>
        Synchronization Word 1.
        2nd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>
        Synchronization Word 0.
        1st byte of the synchronization word.
      </Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>
        Transmit Header 3.
        4th byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>
        Transmit Header 2.
        3rd byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>
        Transmit Header 1.
        2nd byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>
        Transmit Header 0.
        1st byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>
        Packet Length.
        The value in the pklen[7:0] register corresponds directly to the number of bytes in the Packet. For example pklen[7:0] =    00001000    corresponds to a packet length of 8 bytes. The maximum packet length is pklen[7:0] =    11111111   , a 255 byte packet. Writing 0 is possible, in this case we do not send any data in the packet.
        </Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description></Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description></Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description></Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description></Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description></Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description></Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description></Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="DF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldorampen" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>        7
        PA LDO Ramp Enable.
        When this bit is set, the PA LDO ramp will ramp in conjunction with the ramp of the PA bias. Ramping the LDO will increase modulation depth for OOK. Spectral improvements will occur when not ramping the LDO.
        6:4
        txmod[2:0]
        TX Modulation Delay.
        The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up. It can be set from 0  s to 28   s in 4   s steps. This also works during PA ramp down.
        3:2
        ldoramp[1:0]
        TX LDO Ramp Time.
        The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00:	5   s
        01:	10   s
        10:	15   s
        11:	20   s
        1:0
        txramp[1:0]
        TX Ramp Time.
        The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00: 	5   s
        01: 	10   s
        10: 	15   s
        11: 	20   s
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>        7:3
        PLL Soft Settling Time (TS).
        This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0   s and 310  s, in 10   s intervals. The default plltime corresponds to 100  s. See formula above.
        2:0
        pllt0
        PLL Settling Time (TO).
        This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0   s and 70  s, in 10  s steps. The default pllt0 corresponds to 20  s. See formula above.
      </Description>
    </Register>
    <Register address="54" name="Invalid Preamble Threshold and PA Misc" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="pa_duty[1]" />
      <Bit index="4" name="pa_duty[0]" />
      <Bit index="3" name="ldoramplv[1]" />
      <Bit index="2" name="ldoramplv[0]" />
      <Bit index="1" name="Ido_pa_boost" />
      <Bit index="0" name="pabias_boost" />
      <Description>
        5:4
        pa_duty[1:0]
        PA Duty Cycle Control.
        Shifting the duty cycle of the PA will effect PA efficiency and harmonics.
        3:2
        ldoramplv[1:0]
        PA LDO Ramp Level.
        The starting ramp level of the PA LDO. The ramp level will effect modulation depth and spectral splatter.
        1
        ldo_pa_boost
        LDO PA Boost.
        0
        pa_vbias_boost
        PA VBIAS Boost.
      </Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        6
        xtalstarthalf
        If Set, the Xtal Wake Time Period is Halved.
        5
        Reserved
        4
        enrcfcal
        RC Oscillator Fine Calibration Enable.
        If this bit is set to 1 then the RC oscillator performs fine calibration in every app. 30 s.
        3
        rccal
        RC Calibration Force.
        If setting rccal=1 will automatically perform a forced calibration of the 32kHz RC Oscillator. The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a 0 to 1 will initiate the calibration. This bit is cleared automatically.
        2
        vcocaldp
        VCO Calibration Double Precision Enable.
        When this bit is set to 1 then the VCO calibration measures longer thus calibrates more precisely.
        1
        vcocal
        VCO Calibration Force.
        If in Idle Mode and pllon=1, setting vcocal=1 will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        0
        skipvco
        Skip VCO Calibration.
        Setting skipvco=1 will skip the VCO calibration when going from the Idle state to the TX state.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="oscdeten" />
      <Bit index="3" name="rssimasel" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>        7
        If set, BCR phase compensation will be bypassed.
        6
        slicfbyp
        If set, slicer phase compensation will be bypassed.
        5
        dttype
        Dithering Type.
        If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add   1.
        4
        oscdeten
        If low, the ADC Oscillation Detection mechanism is allowed to work. If set, we disable the function.
        3
        rssimasel
        RSSI Moving Average Select.
        If 1 then the RSSI moving average read back is 8 bits. If 0 then the moving average is set to 4 bits.
        2
        refclksel
        Delta-Sigma Reference Clock Source Selection
        1:	10MHz
        0:	 PLL
        1
        refclkinv
        Delta-Sigma Reference Clock Inversion Enable.
        0
        distogg
        If reset, the discriminator toggling is disabled.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>        7
        Direct Control to Analog.
        6
        fbdiv_rst
        Direct Control to Analog.
        5
        cpforceup
        Charge Pump Force Up.
        4
        cpforcedn
        Charge Pump Force Down.
        3
        cdconly
        Charge Pump DC Offset Only.
        2:0
        cdcurr[2:0]
        Charge Pump DC Current Selection.
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming/Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>        7:6
        Charge Pump Current (Gain Setting).
        Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        5
        cpcorrov
        Charge Pump Correction Override Enable.
        4:0
        cpcorr[4:0]
        Charge Pump Correction Value.
        During read, you read what the Charge Pump sees. If cpcorrov = 1, then the value you write will go to the Charge Pump, and will also be the value you read. By default, cpcorr[4:0] wakes up as all Zeros.
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcorboosten" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>        7
        If this is Set, then vcocorr (reg 5A[5:2]) = 1111 during TX Mode and VCO CAL followed by TX.
        6
        fbdivhc
        Feedback (fractional) Divider High Current Enable (+5  A).
        5:4
        d3trim[1:0]
        Divider 3 Current Trim Value.
        3:2
        d2trim[1:0]
        Divider 2 Current Trim Value.
        1:0
        d1p5trim[1:0]
        Divider 1.5 (div-by-1.5) Current Trim Value.
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcurboosten" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>        7
        If this is Set, then vcocur = 11 during TX Mode and VCO CAL followed by TX.
        6
        vcocorrov
        VCO Current Correction Override.
        5:2
        vcocorr[3:0]
        VCO Current Correction Value.
        1:0
        vcocur[1:0]
        VCO Current Trim Value.
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov/vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>        7
        VCO Calibration Override/Done.
        When vcocalov=0 the internal VCO calibration results may be viewed by reading the vcocal register. When vcocalov=1 the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives 1 if the calibration process has been finished.
        6:0
        vcocal[6:0]
        VCO Calibration Results.
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="0" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>        7
        Enable DSM Dithering.
        If low, dithering is disabled.
        6
        Reserved
        Will read 0.
        5
        enoloop
        Open Loop Mode Enable.
        4
        dsmod
        Delta-Sigma Modulus.
        0: 64 000
        1: 65 536
        3:2
        dsorder[1:0]
        Delta-Sigma Order.
        00: 	0 order
        01: 	1st order
        10: 	2nd order
        11: 	Mash 111
        1
        dsrstmode
        Delta-Sigma Reset Mode.
        0
        dsrst
        Delta-Sigma Reset.
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>        7
        Mixer Enable Override.
        6
        enlna
        LNA Enable Override.
        5
        enpga
        PGA Enable Override.
        4
        enpa
        Power Amplifier Enable Override.
        3
        enbf5
        Buffer 5 Enable Override.
        2
        endv32
        Divider 3_2 Enable Override.
        1
        enbf12
        Buffer 1_2 Enable Override.
        0
        enmx2
        Multiplexer 2 Enable Override.
      </Description>
    </Register>
    <Register address="5E" name=" Block Enable Override 2" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>        7
        Delta-Sigma Enable Override.
        6
        Reserved
        5
        enmx3
        Multiplexer 3 Enable Override.
        4
        enbf4
        Buffer 4 Enable Override.
        3
        enbf3
        Buffer 3 Enable Override.
        2
        enbf11
        Buffer 1_1 Enable Override.
        1
        enbf2
        Buffer 2 Enable Override.
        0
        pllreset
        PLL Reset Enable Override.
      </Description>
    </Register>
    <Register address="5F" name=" Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>        7
        Fractional Divider Enable Override.
        6
        endv31
        Divider 3_1 Enable Override.
        5
        endv2
        Divider 2 Enable Override.
        4
        endv1p5
        Divider 1.5 (div-by-1.5) Enable Override.
        3
        dvbshunt
        VCO Bias Shunt Enable Override Mode.
        2
        envco
        VCO Enable Override.
        1
        encp
        Charge Pump Enable Override.
        0
        enbg
        Bandgap Enable Override.
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="50" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description></Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description></Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>        7:5
        Internal Power States of the Chip.
        LP:	000
        RDY:	001
        Tune:	011
        TX:	010
        4
        clkhyst
        Clock Hysteresis Setting.
        3
        enbias2x
        2 Times Higher Bias Current Enable.
        2
        enamp2x
        2 Times Higher Amplification Enable.
        1
        bufovr
        Output Buffer Enable Override.
        If set to 1 then the enbuf bit controls the output buffer.
        0: output buffer is controlled by the state machine.
        1: output buffer is controlled by the enbuf bit.
        0
        enbuf
        Output Buffer Enable.
        This bit is active only if the bufovr bit is set to 1.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>        7
        RC Oscillator Coarse Calibration Override.
        When rccov=0 the internal Coarse Calibration results may be viewed by reading the rcccal register. When rccov=1 the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        6:0
        rcc[6:0]
        RC Oscillator Coarse Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>        7
        RC Oscillator Fine Calibration Override.
        When rcfov=0 the internal Fine Calibration results may be viewed by reading the rcfcal register. When rcfov=1 the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        6:0
        rcf[6:0]
        RC Oscillator Fine Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>        7
        Smart POR Enable.
        6
        enbias
        Bias Enable.
        5
        envcoldo
        VCO LDO Enable.
        4
        enifldo
        IF LDO Enable.
        3
        enrfldo
        RF LDO Enable.
        2
        enpllldo
        PLL LDO Enable.
        1
        endigldo
        Digital LDO Enable.
        0
        endigpwdn
        Digital Power Domain Powerdown Enable in Idle Mode.
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>        7
        Enable Overrides.
        If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks.
        6
        enxtal
        Xtal Override Enable Value.
        5
        ents
        Temperature Sensor Enable.
        4
        enrc32
        32K Oscillator Enable.
        3
        Reserved
        2:0
        diglvl
        Digital LDO Level Setting.
      </Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        2:0
        firadd[2:0]
        GFSK FIR Filter Coefficient Look-up Table Address.
        The address for Gaussian filter coefficients used in the TX path. The default GFSK setting is for BT=0.5. It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000: 	i_coe0 (Default =d1)
        001: 	i_coe1 (Default =d3)
        010: 	i_coe2 (Default =d6)
        011: 	i_coe3 (Default =d10)
        100: 	i_coe4 (Default =d15)
        101: 	i_coe5 (Default =d19)
        110: 	i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>
        5:0
        firval[5:0]
        FIR Coefficient Value in the lOok-up Table Addressed by the firadd[2:0].
        The default coefficient can be read or modified.
      </Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="papeakval" />
      <Bit index="6" name="papeaken" />
      <Bit index="5" name="papeaklvl[1]" />
      <Bit index="4" name="papeaklvl[0]" />
      <Bit index="3" name="Ina_sw" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>
        6
        papeaken
        PA Peak Detector Value Read Register.
        Reading a 1 in this register when the papeaken=1 then the PA drain voltage is too high and the match network needs adjusting for optimal efficiency.
        5
        papeaklvl[1]
        PA Peak Detector Enable.
        4
        papeaklvl[0]
        PA Peak Detect Level (direct from register).
        00=6.5
        01=7
        10=7.5
        11=8
        00 = default
        3
        lna_sw
        LNA Switch Controller.
        If set, lna_sw control from the digital will go high during TX modes, and low during other times. If reset, the digital control signal is low at all times.
        2:0
        txpow[2:0]
        TX Output Power.
        The output power is configurable from    8dBm to +13dBm in ~3dBm steps. txpow[2:0]=111 corresponds to +13dBm and 000 to    8dBm.
      </Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>
        Data Rate Upper Byte.
        The data rate can be calculated as: TX_DR=103xtxdr[15:0] / 216 [kbps] (if address 70[5]=0) or
      </Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="3D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>
        Data Rate Lower Byte.
        See formula above. Defaults = 40kbps.
      </Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txdtrtscale" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        5
        txdtrtscale
        This bit should be set for Data Rates below 30kbps.
        4
        enphpwdn
        If set, the Packet Handler will be powered down when chip is in low power mode.
        3
        manppol
        Manchester Preamble Polarity (will transmit a series of 1 if set, or series of 0 if reset).
        This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester Mode is enabled.
        2
        enmaninv
        Manchester Data Inversion is Enabled if this bit is set.
        1
        enmanch
        Manchester Coding is Enabled if this bit is set.
        0
        enwhite
        Data Whitening is Enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        TX Data Clock Configuration.
        00:	No TX Data CLK is available (asynchronous mode     Can only work with modulations FSK or OOK).
        01:	TX Data CLK is available via the GPIO (one of the GPIO   s should be programmed as well).
        10:	TX Data CLK is available via the SDO pin.
        11:	TX Data CLK is available via the nIRQ pin.
        5:4
        dtmod[1:0]
        Modulation Source.
        00: 	Direct Mode using TX_Data function via the GPIO pin 	(one of the GPIO   s should be programmed accordingly as well)
        01: 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10: 	FIFO Mode
        11: 	PN9 (internally generated)
        3
        eninv
        TX Data.
        2
        fd[8]
        MSB of Frequency Deviation Setting, see"Register 72h. Frequency Deviation".
        1:0
        modtyp[1:0]
        Modulation Type.
        00:	Unmodulated carrier
        01:	OOK
        10:	FSK
        11:	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>
        Frequency Deviation Setting.

      </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>
        Frequency Offset Setting.
        The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value.
      </Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>
        1:0
        fo[9:8]
        Upper Bits of the Frequency Offset Setting.
        fo[9] is the sign bit. The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value.
      </Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        6
        sbsel
        Side Band Select.
        5
        hbsel
        High Band Select.
        Setting hbsel = 1 will choose the frequency range from 480   960MHz (high bands). Setting hbsel = 0 will choose the frequency range from 240   479.9MHz (low bands).
        4:0
        fb[4:0]
        Frequency Band Select.
        Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands. Setting fb[4:0]=00000 corresponds to the 240   250MHz Band for hbsel=0 and the 480   500MHz Band for hbsel=1. Setting fb[4:0]=00001 corresponds to the 250   260MHz Band for hbsel=0 and the 500   520MHz Band for hbsel=1.
        The RF carrier frequency can be calculated as follows:
        fcarrier = (fb+24+(fc+fo) / 64000)x10000x(hbsel+1) + (fhchxfhsx10) [kHz],
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>
        Nominal Carrier Frequency Setting.
       </Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>
        Nominal Carrier Frequency Setting.
        </Description>
    </Register>
    <Register address="78" name="Miscellaneous Settings" size="8" defaultVal="19" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="ifsw_en" />
      <Bit index="3" name="Alt_PA_Seq" />
      <Bit index="2" name="rcosc[2]" />
      <Bit index="1" name="rcosc[1]" />
      <Bit index="0" name="rcosc[0]" />
      <Description>
        4
        ifsw_en
        Enable for IF SW between PA and IF.
        3
        alt_pa_seq
        Alternative PA sequencing.
        If set, we will enable the alternative PA sequence. By default, this is not enabled.
        2:0
        rcosc_cal[2:0]
        rcosc_cal[2:0].
        Fine changes on the RC OSC Calibration target frequency, to help compensate for    calibration biases.    This register should not be changed by costumers.
      </Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>Frequency Hopping Channel Number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>
        Frequency Hopping Step Size in 10kHz Increments.
        See formula for the nominal carrier frequency at"Register 76h. Nominal Carrier Frequency".
      </Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>
        5:0
        txafthr[5:0]
        TX FIFO Almost Full Threshold.
      </Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>
        5:0
        txfaethr[5:0]
        TX FIFO Almost Empty Threshold.
      </Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        FIFO Data.
        A Write (R/W=1) to this Address will begin a Burst Write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented. To conclude the TX FIFO Write the SEL pin should be brought HIGH, in the same manner.
      </Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="26" type="Si4313" revision="B1" projectID="0" name="Ara 4313_B1">
    <TxPufferSize>0</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>0</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        [4:0] dt[4:0]  = Device Type Code.  This internally hardwired code identifies the type or family of chip.
        EZRadioPRO devices = 01000 = 08h.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="06" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>[4:0] vc[4:0]  = Version Code.  This internally hardwired code identifies the chip revision. For EZRadioPRO devices, V2 revision = 00010 = 02h, A0 revision = 00100 = 04h,  B1 revision = 00110 = 06h.</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>
        [7] ffovfl = RX FIFO Overflow status.
        [6] ffunfl = RX FIFO Underflow status.
        [5] rxffem = RX FIFO Empty status.
        [1:0] cps[1:0]  = Chip Power State:
        00 - Idle State
        01 - RX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="reserved" />
      <Bit index="0" name="reserved" />
      <Description>
        When any of the following bits change state from '0' to '1' the control block will notify the micro-controller by setting the nIRQ pin LOW = '0' if it is enabled in the Interrupt Enable 1 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 1 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.

        [7] ifferr = FIFO Underflow/Overflow Error.  When set to '1' the RX FIFO has overflowed or underflowed.
        [6:5] RESERVED
        [4] irxffafull = RX FIFO Almost Full.  When set to '1' the RX FIFO has met its almost full threshold and needs to be read by the microcontroller
        [3] iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        [2:0] RESERVED
        When does the individual Status bits get Set/Cleared, if not enabled as an Interrupt?
        [7] Set if there is a RX FIFO Overflow or Underflow.  It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
        [6:5] RESERVED
        [4] Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we read enough data from RX FIFO so that the number of data bytes not yet read is below the Almost Full threshold.
        [3] External interrupt source
        [2:0] RESERVED
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        When any of the following bits change state from '0' to '1' the control block will notify the micro-controller by setting the nIRQ pin LOW = '0' if it is enabled in the Interrupt Enable 2 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 2 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.

        [7] iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
        [6] ipreaval = Valid Preamble Detected. When a preamble is detected this bit will be set to 1.
        [5] ipreainval = Invalid Preamble Detected. When the preamble is not found within a period of time after the RX is enabled, this bit will be set to 1.
        [4] irssi = RSSI. When RSSI level exceeds the programmed thershold this bit will be set to 1.
        [3] iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.
        [2] ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        [1] ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
        [0] ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.

        When does the individual Status bits get Set/Cleared, if not enabled as an Interrupt?
        [7] Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        [6] Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        [5] Self cleaning, user should use this as an interrupt source rather than a status.
        [4] Should remain high as long as the RSSI value is above programmed threshold level
        [3] Wake time timer interrupt. Use as an interrupt, not as a status.
        [2] Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        [1] Chip ready goes high once we enable the xtal, RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        [0] Power on status.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="reserved" />
      <Bit index="0" name="reserved" />
      <Description>
        [7] enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
        [6:5] RESERVED
        [4] enrxffafull = Enable RX FIFO Almost Full. When set to '1' the RX FIFO Almost Full interrupt will be enabled.
        [3] enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
        [2:0] RESERVED
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        [7] enswdet = Enable Sync Word Detected. When '1' the Sync Word Detected Interrupt will be enabled.
        [6] enpreaval = Enable Valid Preamble Detected. When '1' the Valid Preamble Detected Interrupt will be enabled.
        [5] enpreainval = Enable Invalid Preamble Detected. When '1' the Invalid Preamble Detected Interrupt will be enabled.
        [4] enrssi = Enable RSSI. When set to '1' the RSSI Interrupt will be  enabled.
        [3] enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
        [2] enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
        [1] enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
        [0] enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating and; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        [7] swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.
        [6] enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.
        [5] enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        [4] x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
        [3] RESERVED
        [2] rxon = RX on in manual receiver mode. It is automatically cleared if Multiple Packets config. is disabled and a valid packet received.
        [1] pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        [0] xton = READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating and; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="reserved" />
      <Description>
        [7:5] antdiv[2:0]  = Enable Antenna Diversity. The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
        RX state non RX state
        GPIO Ant1 GPIO Ant2 GPIO Ant1 GPIO Ant2
        000 - 1 0 0 0
        001 - 0 1 0 0
        010 - 1 0 1 1
        011 - 0 1 1 1
        100 - antenna diversity algorythm 0 0
        101 - antenna diversity algorythm 1 1
        110 - ant. div. algorythm in beacon mode 0 0
        111 - ant. div. algorythm in beacon mode   1 1
        [4:2] RESERVED
        [1] ffclrrx = RX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrrx='1' followed by ffclrrx= '0' will clear the contents of the RX FIFO.
        [0] RESERVED
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>
        [7] xtalshft = Direct control to Analog
        [6:0] xlc[6:0]  = Tuning Capacitance for the 30MHz XTAL
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        [7:6] RESERVED
        [5:4] clkt[1:0]  = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0]  register will provide the addition cycles of the clock before it shuts off.
        00 - 0 cycle
        01 - 128 cycles
        10 - 256 cycles
        11 - 512 cycles
        [3] enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0]  is.  For example if mclk[2:0]  = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        [2:0] mclk[2:0]  = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0]  setting is only valid when xton = '1' except the '111'.
        000 - 30 MHz
        001 - 15 MHz
        010 - 10 MHz
        011 - 4 MHz
        100 - 3 MHz
        101 - 2 MHz
        110 - 1 MHz
        111 - 32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        [7:6] gpiodrv0[1:0]  - Gpio driving capability setting
        [5] pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        [4:0] gpio0[4:0]  = GPIO0pin function select:

        00000 - Power-On-Reset (output)
        00001 - Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - Direct Digital Input
        00100 - External Interrupt, falling edge (input)
        00101 - External Interrupt, rising edge (input)
        00110 - External Interrupt, state change (input)
        00111 - ADC Analog Input
        01000 - Reserved
        01001 - Reserved
        01010 - Direct Digital Output
        01011 - Reserved
        01100 - Reserved
        01101 - Reserved
        01110 - Reference Voltage (output)
        01111 - RX Data CLK output to be used in conjunction with RX Data pin (output)
        10000 - Reserved
        10001 - Reserved
        10010 - Reserved
        10011 - Reserved
        10100 - RX Data (output)
        10101 - RX State (output)
        10110 - RX FIFO Almost Full  (output)
        10111 - Antenna 1 Switch used for antenna diversity  (output)
        11000 - Antenna 2 Switch used for antenna diversity  (output)
        11001 - Valid Preamble Detected  (output)
        11010 - Invalid Preamble Detected  (output)
        11011 - Sync Word Detected  (output)
        11100 - Clear Channel Assessement  (output)
        11101 - VDD
        else  - GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        [7:6] gpiodrv1[1:0]  - Gpio driving capability setting
        [5] pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        [4:0] gpio1[4:0]  = GPIO1 pin function select:

        00000 - Power-On-Reset Inverted (output)
        00001 - Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - Direct Digital Input
        00100 - External Interrupt, falling edge (input)
        00101 - External Interrupt, rising edge (input)
        00110 - External Interrupt, state change (input)
        00111 - ADC Analog Input
        01000 - Reserved
        01001 - Reserved
        01010 - Direct Digital Output
        01011 - Reserved
        01100 - Reserved
        01101 - Reserved
        01110 - Reference Voltage (output)
        01111 - RX Data CLK output to be used in conjunction with RX Data pin (output)
        10000 - Reserved
        10001 - Reserved
        10010 - Reserved
        10011 - Reserved
        10100 - RX Data (output)
        10101 - RX State (output)
        10110 - RX FIFO Almost Full  (output)
        10111 - Antenna 1 Switch used for antenna diversity  (output)
        11000 - Antenna 2 Switch used for antenna diversity  (output)
        11001 - Valid Preamble Detected  (output)
        11010 - Invalid Preamble Detected  (output)
        11011 - Sync Word Detected  (output)
        11100 - Clear Channel Assessement  (output)
        11101 - VDD
        else  - GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        [7:6] gpiodrv2[1:0]  - Gpio driving capability setting
        [5] pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        [4:0] gpio2[4:0]  = GPIO2 pin function select:

        00000 - Microcontroller Clock (output)
        00001 - Wake-Up Timer: '1' when WUT has expired  (output)
        00010 - Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 - Direct Digital Input
        00100 - External Interrupt, falling edge (input)
        00101 - External Interrupt, rising edge (input)
        00110 - External Interrupt, state change (input)
        00111 - ADC Analog Input
        01000 - Reserved
        01001 - Reserved
        01010 - Direct Digital Output
        01011 - Reserved
        01100 - Reserved
        01101 - Reserved
        01110 - Reference Voltage (output)
        01111 - RX Data CLK output to be used in conjunction with RX Data pin (output)
        10000 - Reserved
        10001 - Reserved
        10010 - Reserved
        10011 - Reserved
        10100 - RX Data (output)
        10101 - RX State (output)
        10110 - RX FIFO Almost Full  (output)
        10111 - Antenna 1 Switch used for antenna diversity  (output)
        11000 - Antenna 2 Switch used for antenna diversity  (output)
        11001 - Valid Preamble Detected  (output)
        11010 - Invalid Preamble Detected  (output)
        11011 - Sync Word Detected  (output)
        11100 - Clear Channel Assessement  (output)
        11101 - VDD
        else  - GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        [7] RESERVED
        [6] extitst[2]  = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        [5] extitst[1]  = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        [4] extitst[0]  = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        [3] itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        [2] dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        [1] dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        [0] dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart / adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        [7] adcstart / adcdone = Set this bit = 1 starts the ADC measurement process.  This bit self-clears during the measurement cycle, and returns high when the measurement is complete.  The conversion process is fast; reading this bit may always appear to return a 1.
        [6:4] adcsel[2:0]  = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
        000 - Internal Temperature Sensor
        001 - GPIO0, single-ended
        010 - GPIO1, single-ended
        011 - GPIO2, single-ended
        100 - GPIO0(+) - GPIO1(-), differential
        101 - GPIO1(+) - GPIO2(-), differential
        110 - GPIO0(+) - GPIO2(-), differential
        111 - GND, ADC is disabled
        [3:2] adcref[1:0]  = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
        0X - bandgap voltage (1.2V)
        10 - VDD / 3
        11 - VDD / 2
        [1:0] adcgain[1:0]  = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0]  = 0: adcref[0]  = 1:
        FS = 0.014 * (adcgain[1:0]  + 1) * VDD  FS = 0.021 * (adcgain[1:0]  + 1) * VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>
        The offset can be calculated as Offset = adcoffs[2:0]  * VDD / 1000; MSB = adcoffs[3]  = Sign bit

        [7:4] RESERVED
        [3:0] adcoffs[3:0]  = ADC Sensor Amplifier Offset. See formula above.
      </Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>[7:0] adc[7:0]  = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>
        [7:6] tsrange[1:0]  = Temperature Sensor Range selection (FS range is 0..1024mV)
        00 - -40C .. 64C (full operating range), with 0.5C resolution (1 LSB in the 8 bit ADC)
        01 - -40C .. 85C, with 1C resolution (1 LSB in the 8 bit ADC)
        11 -   0C .. 85C, with 0.5C resolution (1 LSB in the 8 bit ADC)
        10 - -40F .. 216F, with 1F resolution (1 LSB in the 8 bit ADC)
        [5] entsoffs = Temperature Sensor Offset to convert from K to C.
        [4] entstrim = Temperature Sensor Trim enable
        [3:0] tstrim[3:0]  = Temperature Sensor Trim value
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>[7:0] tvoffs[7:0]  = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8] : sign bit)</Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description>
        The period of the wake-up timer can be calculated as TWUT = (4 * M * 2R) / 32.768 [ms]
        [7:5] RESERVED
        [4:0] wtr[4:0]  = Wake Up Timer Exponent (R) value.  See formula above.

        Maximum value for R is decimal 20.   A value greater than 20 will yield a result as if 20 were written.
        R Value = 0 is allowed  to be written here.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>[7:0] wtm[15:8]  = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        [7:0] wtm[7:0]  = Wake Up Timer Mantissa (M) value.  See formula above.
        M[7:0] = 0 is not valid here. Write at least decimal 1.
      </Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>[7:0] wtv[15:8]  = Wake Up Timer counter Current Mantissa (M) value. (Read only)</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>[7:0] wtv[7:0]  = Wake Up Timer counter Current  Mantissa (M) value.  (Read only)</Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>
        The threshold can be calculated as Vthreshold = ( 1.675 + LBDT * 50 mV ) +- 25 mV

        [7:5] RESERVED
        [4:0] lbdt[4:0]  = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.
      </Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        [7:5] RESERVED
        [4:0] vbat[4:0]  = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC if the LBD bit D6 of Reg 07h is also set.  In Sleep Mode the register is updated in every 1 s.  In other states it measures continuously.
        The measured voltage is calculated by the following formula:
        Vbat_meas = 1.7[V]  + vbat[4:0]  x 50 mV.
      </Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>
        [7] dwn3_bypass = Bypass decimator by 3 (if set).
        [6:4] ndec_exp[2:0]  = IF Filter decimation rates
        [3:0] filset[3:0]  = IF Filter coefficient sets ; defauts are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz

        When the required bandwidth (BW) is calculated then the three filter parameters, ndec_exp, dwn3_bypass and filset, can be found from the table below. When the calculated bandwidth value is not exactly available then select the higher available bandwidth closest to the calculated bandwidth.
      </Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afcbd" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="1p5 bypass" />
      <Bit index="1" name="matap" />
      <Bit index="0" name="ph0size" />
      <Description>
        [7] Afcbd = AFC wide band enable (active high).  If set, the IF filter bandwidth is reduced after preamble detection in order to optimize RX sensitivity.
        The alternate IF filter coefficients must be specified in SPI Reg 60h and 61h; contact Silicon Labs Application Support for details.
        [6] enafc = AFC enable
        [5:3] afcgearh[2:0]  = AFC High Gear Setting. Feedback loop gain during AFC settling process is proportional to 2^(-afcgearh[2:0] ).
        [2] 1p5bypass = If high (1) select 0dB bias for the second phase antenna selection, if  low (0), select 1.5 dB. The default is (1), selecting 0 dB.
        [1] matap = Number of taps for moving average filter during Antenna Diversity RSSI evaluation.  Allows for reduced noise variation on measured RSSI value but with slower update rate.  If high (1), filter tap length = 8*Tb. If low (0 = default), filter tap length = 8*Tb prior to first PREAMBLE_VALID, and 4*Tb thereafter.
        [0] ph0size = If low, we will reset the Preamble detector if there are 5 consecutive zero phases. If high, the reset will happen after 3 consecutive zero phases.
      </Description>
    </Register>
    <Register address="1E" name="AFC/ AntDiv Timing Control" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swant_timer[1]" />
      <Bit index="6" name="swant_timer[0]" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="anwait[2]" />
      <Bit index="1" name="anwait[1]" />
      <Bit index="0" name="anwait[0]" />
      <Description>
        [7:6] swant_timer  = additional number of bit periods to wait for RSSI value to stabilize during Antenna Diversity 2nd phase antenna evaluation.  If matap=0, total wait time = 8*Tb+swant_timer[1:0] .  If matap=1,total wait time = 12*Tb+swant_timer[1:0] . Effective only during Antenna Diversity.
        [5:3] shwait[2:0]  = short wait periods after AFC correction used before preamble is detected.  Short wait = (RegValue+1)*2Tb.  If set to '0' then no AFC correction will occur before preamble detect, i.e. AFC will be disabled.
        [2:0] anwait[2:0]  = antenna switching wait time. Number of bit periods between toggling selection of antennas = ( anwait[2:0]  + 2 ) * 4.
        Default value = 3'b010 = 16 bit periods.
      </Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>
        [7] RESERVED
        [6] RESERVED
        [5:3] crfast[2:0]  = Clock Recovery Fast Gearshift value
        [2:0] crslow[2:0]  = Clock Recovery Slow Gearshift value
      </Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>
        [7:0] rxosr[7:0]  = Oversampling Rate, 3 LSBs are the fraction
        default = 0110 0100 = 12.5 clock cycles per data bit
      </Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="skip2phth" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>
        [7:5] rxosr[10:8]  = Oversampling Rate, upper bits
        [4] skip2phth  = threshold for skipping the 2nd phase of RSSI detection during antenna diversity algorithm. 0 = 16 dB (default), 1 = 11 dB.
        NOT RECOMMENDED FOR USER CONFIGURATION.
        [3:0] ncoff[19:16]  = NCO offset. See formula above.
      </Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>[7:0] ncoff[15:8]  = NCO offset. See formula above.</Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>[7:0] ncoff[7:0]  = NCO offset. See formula above.</Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="rxncocomp" />
      <Bit index="3" name="cgainx2" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>
        [7:5] RESERVED
        [4] rxncocomp = Receive compensation enable for high data rate offset.
        [3] cgainx2 = multiplying the CR gain by two.
        [2:0] crgain[10:8]  = Clock Recovery Timing Loop Gain
      </Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>[7:0] crgain[7:0]  = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>[7:0] rssi[7:0]  = Received Signal Strength Indicator value</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="1E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>[7:0] rssith[7:0]  = RSSI Threshold. Interrupt is set if the RSSI value is above this threshold.</Description>
    </Register>
    <Register address="28" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>[7:0] adrssi1[7:0]  = Measured RSSI value on antenna 1</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description>[7:0] adrssi2[7:0]  = Measured RSSI value on antenna 2</Description>
    </Register>
    <Register address="2A" name="AFC Limiter" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afclim[7]" />
      <Bit index="6" name="afclim[6]" />
      <Bit index="5" name="aAfclim[5]" />
      <Bit index="4" name="afclim[4]" />
      <Bit index="3" name="afclim[3]" />
      <Bit index="2" name="afclim[2]" />
      <Bit index="1" name="afclim[1]" />
      <Bit index="0" name="afclim[0]" />
      <Description>[7:0] AFC Limiter[7:0]  = AFC limiter value.</Description>
    </Register>
    <Register address="2B" name="AFC Correction Read" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[8]" />
      <Bit index="5" name="afc_corr[7]" />
      <Bit index="4" name="afc_corr[6]" />
      <Bit index="3" name="afc_corr[5]" />
      <Bit index="2" name="afc_corr[4]" />
      <Bit index="1" name="afc_corr[3]" />
      <Bit index="0" name="afc_corr[2]" />
      <Description>[7:0] AFC Correction Values = AFC loop correction values [9:2]   (MSB's only). Values are updated once, after sync word is found during receiving. See also address 2Ch.</Description>
    </Register>
    <Register address="2C" name="OOK Counter Value 1" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[1]" />
      <Bit index="6" name="afc_corr[0]" />
      <Bit index="5" name="ookfrzen" />
      <Bit index="4" name="peakdeten" />
      <Bit index="3" name="madeten" />
      <Bit index="2" name="ookcnt[10]" />
      <Bit index="1" name="ookcnt[9]" />
      <Bit index="0" name="ookcnt[8]" />
      <Description>
        [7:6] AFC Correction Values = AFC loop correction values [1:0]  (LSB's). Values are updated once, after sync word is found during receiving. See also address 2Bh.
        [5] ookfrzen = when '0' (default), AGC and OOK Moving Average Detector threshold operate continuously. When '1', AGC and OOK MA Detector threshold operate until PREAMBLE_VALID signal is detected; values are frozen thereafter.  Recommended for use with non-Manchestered payload data.
        [4] peakdeten = when '1' (default), Peak Detector for OOK Modem is enabled.  Provides improved performance in presence of co-channel interferers, at slight reduction of sensitivity. Peak Detector output is logically AND'ed with Moving Average Detector output.
        [3] madeten = when '1' (default), Moving Average Detector for OOK Modem is enabled.  Provides best sensitivity, but requires DC-balanced data (e.g. Manchester data) and is more sensitive to co-channel interference.  Peak Detector output is logically AND'ed with Moving Average Detector output.
        [2:0] OOK Counter [10:8]  = OOK counter Value MSBs. This counter value will affect the OOK AGC's decay time.
      </Description>
    </Register>
    <Register address="2D" name="OOK Counter Value 2" size="8" defaultVal="BC" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ookcnt[7]" />
      <Bit index="6" name="ookcnt[6]" />
      <Bit index="5" name="ookcnt[5]" />
      <Bit index="4" name="ookcnt[4]" />
      <Bit index="3" name="ookcnt[3]" />
      <Bit index="2" name="ookcnt[2]" />
      <Bit index="1" name="ookcnt[1]" />
      <Bit index="0" name="ookcnt[0]" />
      <Description>[7:0] OOK Counter [7:0]  = OOK counter Value LSBs. This counter value will affect the OOK AGC's decay time.</Description>
    </Register>
    <Register address="2E" name="Slicer Peak Hold" size="8" defaultVal="26" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserv." />
      <Bit index="6" name="attack[2]" />
      <Bit index="5" name="attack[1]" />
      <Bit index="4" name="attack[0]" />
      <Bit index="3" name="decay[3]" />
      <Bit index="2" name="decay[2]" />
      <Bit index="1" name="decay[1]" />
      <Bit index="0" name="decay[0]" />
      <Description>
        [7] Reserved
        [6:4] attack[2:0]  = OOK Peak Detector attack time.  Peak detector value charges up at rate proportional to 2^(-attack[2:0] ).  OOK slicing threshold is set 6 dB below peak detector value.  Effective only when OOK Peak Detector is enabled.
        [3:0] decay [3:0]  = OOK Peak Detector decay time.  Peak detector value discharges at rate proportional to 2^(-decay[3:0] ). OOK slicing threshold is set 6 dB below peak detector value.  Effective only when OOK Peak Detector is enabled.
      </Description>
    </Register>
    <Register address="30" name="FIFO config" size="8" defaultVal="8D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fiforx" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="reserved" />
      <Bit index="0" name="reserved" />
      <Description>
        [7] FIFO_RX = Must set to 0 to allow correct operation of the FIFO.  Default is 1.
        [6:0] RESERVED
      </Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description>
        [7:3] preath[4:0]  = Number of nibbles processed during detection.
        [2:0] rssi_offset[2:0]  = Value added as offset to RSSI calculation. Every increment in this register results in an increment of +4dB in the RSSI.
      </Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>[7:0] sync[31:24]  = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>[7:0] sync[23:16]  = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>[7:0] sync[15:8]  = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>[7:0] sync[7:0]  = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description>
        [7:6] RESERVED
        [5:0] ADC8 Control bits =
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="A0" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Inv_pre_th [3]" />
      <Bit index="6" name="Inv_pre_th [2]" />
      <Bit index="5" name="Inv_pre_th [1]" />
      <Bit index="4" name="Inv_pre_th [0]" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>
        [7:4] Invalid_preamble_threshold[3:0]  = This configures (in nibbles) for how long we will search for preamble. If during this time, the preamble is not detected, we will send a signal (which can be configured as interrupt) and restart looking for the preamble again.
        The interval between each interrupt is given by the formula below.
        [3:0] chfiladd[3:0]  = Channel Filter Coefficient Look-up Table Address. The address for channel filter coefficients used in the RX path.

        Invalid preamble will be evaluated during this period:  (invalid_preamble_Threshold *4 ) * Bit Rate period.
      </Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        [7:5] pwst[2:0]  = Internal Power States of the chip
        000 - low power (stand-by / sleep / sensor)
        001 - ready
        011 - tune
        111 - RX
        [4] clkhyst = Clock Hysteresis Setting
        [3] enbias2x = 2 times higher bias current enable
        [2] enamp2x = 2 times higher amplification enable
        [1] bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
        0 - output buffer is controlled by the state machine
        1 - output buffer is controlled by the enbuf bit
        [0] enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.
      </Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="sgin" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>
        [7] RESERVED
        [6] sgin = AGC stop increasing gain override bit (active low).  When '0' (default), AGC gain increases during signal reductions are prevented.  When '1', AGC gain increases during signal reductions are allowed.  Only effective during Preamble, prior to detection of PREAMBLE_VALID signal.
        [5] agcen = Automatic Gain Control enable When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0] .
        [4] lnagain = LNA Gain select
        0 - min. gain = 5 dB 1 -max. gain = 25 dB
        [3:0] pga[3:0]  = PGA Gain Override value
        000 - 0 dB
        001 - 3 dB
        010 - 6 dB
        ...
        101 - 24 dB max.
      </Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="reserved" />
      <Description>
        [7:6] RESERVED
        [5:4] RESERVED
        [3] manppol = Manchester Preamble Polarity (will transmit a series of '1' if set, or series of '0' if reset). This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester mode is enabled.
        [2] enmaninv = Manchester Data Inversion is enabled if this bit is set.
        [1] enmanch = Manchester Coding is enabled if this bit is set.
        [0] enwhite = Data Whitening is enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxrclk[1]" />
      <Bit index="6" name="rxclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        [7:6] rxclk[1:0]  = RX Data Clock Configuration.
        00 - NA
        01 - NA
        10 - RX Data CLK is available via the SDO pin
        11 - RX Data CLK is available via the nIRQ pin
        [5:4] dtmod[1:0]  = Data Source
        00 - Direct Mode using Data function via the GPIO pin (one of the GPIO's should be  programmed accordingly as well)
        01 - Direct Mode using Data function via the SDI pin (only when nSEL is high)
        10 - FIFO Mode
        11 - PN9 (internally generated)
        [3] eninv = Invert RX Data
        [2] fd[8] = See register 72h
        [1:0] modtyp[1:0]  = Modulation Type
        00 - Unmodulated carrier
        01 - OOK
        10 - FSK
        11 - GFSK
      </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>
        The frequency offset can be calculated: Offset = 156.25 Hz * (hbsel + 1) * fo[7:0]  . fo[9:0]  is a 2's complement value. In EZRadioPRO, reading from this register will give the AFC correction last results, not this register value.

        [7:0] fo[7:0]  = Frequency Offset Setting. Values written will only be used during RX if AFC is disabled.
      </Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>
        In EZRadioPRO, reading from this register will give the AFC correction last results, not this register value.

        [7:2] RESERVED
        [1:0] fo[9:8]  = Upper bits of the Frequency Offset Setting. fo[9]  is the sign bit. Values written will only be used during RX if AFC is disabled.
      </Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        [7] RESERVED
        [6] sbsel = Side Band Select.
        [5] hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-960MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
        [4:0] fb[4:0]  = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0] ='00000' corresponds to the 240-250MHz Band for hbsel=CC0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0] ='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>
        The RF carrier frequency can be calculated as:
        fcarrier = (fb+24+(fc+fo) / 64000) * 10000 * (hbsel+1) + (fhch * fhs * 10)  [kHz],
        where parameters fc, fo, fb and hb_sel come from registers 73h-77h. Parameters fhch and fhs come from register 79h and 7Ah.

        [7:0] fc[15:8]  = Nominal Carrier Frequency Setting. See formula above.
      </Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>[7:0] fc[7:0]  = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>[7:0] fhch[7:0]  = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>[7:0] fhs[7:0]  Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>
        [7:6] RESERVED
        [5:0] rxafthr[5:0]  = RX FIFO Almost Full Threshold
      </Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>[7:0] fifod[7:0]  = A Read (R/W='0') to this address will begin a burst read of the RX FIFO.</Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="19" type="Si4330" revision="B0" projectID="0" name="Ara 4330_B0">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="8" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        4:0
        dt[4:0]
        Device Type Code.
        EZRadioPRO: 01000.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="05" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>
        4:0
        vc[4:0]
        Version Code.
        Code indicating the version of the chip.
      </Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>        7
        RX FIFO Overflow Status.
        6
        ffunfl
        RX FIFO Underflow Status.
        5
        rxffem
        RX FIFO Empty Status.
        4
        headerr
        Header Error Status.
        Indicates if the received packet has a header check error.
        3:2
        Reserved
        1:0
        cps[1:0]
        Chip Power State.
        00:	Idle State
        01:	RX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>        7
        FIFO Underflow/Overflow Error.
        When set to 1 the RX FIFO has overflowed or underflowed.
        6:5
        Reserved
        5
        itxffaem
        TX FIFO Almost Empty.
        When set to 1 the TX FIFO is almost empty and needs to be filled.
        4
        irxffafull
        RX FIFO Almost Full.When set to 1 the RX FIFO has met its almost full threshold and needs to be read by the microcontroller.
        3
        iext
        External Interrupt.
        When set to 1 an interrupt occurred on one of the GPIO   s if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        2
        Reserved
        1
        ipkvalid
        Valid Packet Received.When set to 1 a valid packet has been received.
        0
        icrcerror
        CRC Error.
        When set to 1 the cyclic redundancy check is failed.
        When any of the Interrupt/Status 1 bits change state from 0 to 1 the device will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 1 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 1 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
        Table 26. Interrupt or Status 1 Bit Set/Clear Description
        Bit
        Status Name
        Set/Clear Conditions
        7
        ifferr
        Set if there is a FIFO overflow or underflow. Cleared by applying FIFO reset.
        6:5
        Reserved
        5
        itxffaem
        Set when the number of bytes in the TX FIFO is less than or equal to the Almost Empty threshold. Automatically cleared when the number of data bytes in the TX FIFO is above the Almost Empty threshold.
        4
        irxffafull
        Set when the number of bytes in the RX FIFO is greater than the Almost Full threshold. Cleared when the number of bytes in the RX FIFO is below the Almost Full threshold.
        3
        iext
        External interrupt source.
        2
        Reserved
        1
        ipkvalid
        Set up the successful reception of a packet (no RX abort). Cleared upon receiving and acknowledging the Sync Word for the next packet.
        0
        icrcerror
        Set if the CRC computed from the RX packet differs from the CRC in the TX packet. Cleared at the start of reception for the next packet.
        Table 27. When are Individual Status Bits Set/Cleared if not Enabled as Interruptsu
        Bit
        Status Name
        Set/Clear Conditions
        7
        ifferr
        Set if there is a FIFO Overflow or Underflow. It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
        6:5
        Reserved
        5
        itxffaem
        Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
        4
        irxffafull
        Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we read enough data from RX FIFO so that the number of data bytes not yet read is below the Almost Full threshold.
        3
        iext
        External interrupt source
        2
        Reserved
        1
        ipkvalid
        Goes high once a packet is fully received (no RX abort). It is automatically cleaned once we receive and acknowledge the Sync Word for the next packet.
        0
        icrcerror
        Goes High once the CRC computed during RX differs from the CRC sent in the packet by the TX. It is cleaned once we start receiving new data in the next packet.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>        7
        Sync Word Detected.
        When a sync word is detected this bit will be set to 1.
        6
        ipreaval
        Valid Preamble Detected.
        When a preamble is detected this bit will be set to 1.
        5
        ipreainval
        Invalid Preamble Detected.
        When the preamble is not found within a period of time set by the invalid preamble detection threshold in Register 54h, this bit will be set to 1.
        4
        irssi
        RSSI.
        When RSSI level exceeds the programmed threshold this bit will be set to 1.
        3
        iwut
        Wake-Up-Timer.
        On the expiration of programmed wake-up timer this bit will be set to 1.
        2
        ilbd
        Low Battery Detect.
        When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        1
        ichiprdy
        Chip Ready (XTAL).
        When a chip ready event has been detected this bit will be set to 1.
        0
        ipor
        Power-on-Reset (POR).
        When the chip detects a Power on Reset above the desired setting this bit will be set to 1.
        When any of the Interrupt/Status Register 2 bits change state from 0 to 1 the control block will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 2 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 2 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
        Table 28.  Interrupt or Status 2 Bit Set/Clear Description
        Bit
        Status Name
        Set/Clear Conditions
        7
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        6
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        5
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        4
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        3
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        2
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        1
        ichiprdy
        Chip ready goes high once we enable the xtal, RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        0
        ipor
        Power on status.
        Table 29. Detailed Description of Status Registers when not Enabled as Interrupts
        Bit
        Status Name
        Set/Clear Conditions
        7
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        6
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        5
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        4
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        3
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        2
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        1
        ichiprdy
        Chip ready goes high once we enable the xtal, RX, and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        0
        ipor
        Power on status.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>        7
        Enable FIFO Underflow/Overflow.
        When set to 1 the FIFO Underflow/Overflow interrupt will be enabled.
        6:5
        Reserved
        4
        enrxffafull
        Enable RX FIFO Almost Full.
        When set to 1 the RX FIFO Almost Full interrupt will be enabled.
        3
        enext
        Enable External Interrupt.
        When set to 1 the External Interrupt will be enabled.
        2
        Reserved
        1
        enpkvalid
        Enable Valid Packet Received.
        When ipkvalid = 1 the Valid Packet Received Interrupt will be enabled.
        0
        encrcerror
        Enable CRC Error.
        When set to 1 the CRC Error interrupt will be enabled.
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>        7
        Enable Sync Word Detected.
        When mpreadet =1 the Preamble Detected Interrupt will be enabled.
        6
        enpreaval
        Enable Valid Preamble Detected.
        When mpreadet =1 the Valid Preamble Detected Interrupt will be enabled.
        5
        enpreainval
        Enable Invalid Preamble Detected.
        When mpreadet =1 the Invalid Preamble Detected Interrupt will be enabled.
        4
        enrssi
        Enable RSSI.
        When set to 1 the RSSI Interrupt will be enabled.
        3
        enwut
        Enable Wake-Up Timer.
        When set to 1 the Wake-Up Timer interrupt will be enabled.
        2
        enlbd
        Enable Low Battery Detect.
        When set to 1 the Low Battery Detect interrupt will be enabled.
        1
        enchiprdy
        Enable Chip Ready (XTAL).
        When set to 1 the Chip Ready interrupt will be enabled.
        0
        enpor
        Enable POR.
        When set to 1 the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>        7
        Software Register Reset Bit.
        This bit may be used to reset all registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register. The RESET is accomplished by setting swres = 1. This bit will be automatically cleared.
        6
        enlbd
        Enable Low Battery Detect.
        When this bit is set to 1 the Low Battery Detector circuit and threshold comparison will be enabled.
        5
        enwt
        Enable Wake-Up-Timer.
        Enabled when enwt = 1. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        4
        x32ksel
        32,768 kHz Crystal Oscillator Select.
        0:	RC oscillator
        1:	32kHz crystal
        3
        Reserved
        2
        rxon
        RX on in Manual Receiver Mode.
        Automatically cleared if Multiple Packets config. is disabled and a valid packet received.
        1
        pllon
        TUNE Mode (PLL is ON).
        When pllon = 1 the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        0
        xton
        READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="Reserved" />
      <Description>        7
        Enable Antenna Diversity.
        The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
        RX state	non RX state
        GPIO Ant1	GPIO Ant2	GPIO Ant1	GPIO Ant2
        000: 	0	1	0	0
        001:	1	0	0	0
        010: 	0	1	1	1
        011:	1	0	1	1
        100:	antenna diversity algorithm	0	0
        101: 	antenna diversity algorithm	1	1
        110:	ant. div. algorithm in beacon mode	0	0
        111: 	ant. div. algorithm in beacon mode 	1	1
        4
        rxmpk
        RX Multi Packet.
        When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the receiver will automatically leave the RX State after the first valid packet has been received.
        3
        Reserved
        2
        enldm
        Enable Low Duty Cycle Mode.
        If this bit is set to 1 then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
        1
        ffclrrx
        RX FIFO Reset/Clear.
        This has to be a two writes operation: Setting ffclrrx=1 followed by ffclrrx= 0 will clear the contents of the RX FIFO.
        0
        Reserved
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>        7
        Additional capacitance to course shift the frequency if xlc[6:0] is not sufficient. Not binary with xlc[6:0].
        6:0
        xlc[6:0]
        Tuning Capacitance for the 30MHz XTAL.
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        5:4
        clkt[1:0]
        Clock Tail.
        If enlfc = 0 then it can be useful to provide a few extra cycles for the microcontroller to complete its operation. Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00: 	0 cycle
        01: 	128 cycles
        10: 	256 cycles
        11: 	512 cycles
        3
        enlfc
        Enable Low Frequency Clock.
        When enlfc = 1 and the chip is in Sleep mode then the 32.768kHz clock will be provided to the microcontroller no matter what the selection of mclk[2:0] is. For example if mclk[2:0] =    000   , 30MHz will be available through the GPIO to output to the microcontroller in all Idle or RX states. When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        2:0
        mclk[2:0]
        Microcontroller Clock.
        Different clock frequencies may be selected for configurable GPIO clock output. All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator. The mclk[2:0] setting is only valid when xton = 1 except the 111.
        000: 	30 MHz
        001: 	15 MHz
        010: 	10 MHz
        011: 	4 MHz
        100: 	3 MHz
        101: 	2 MHz
        110: 	1 MHz
        111:	32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>        7:6
        GPIO Driving Capability Setting.
        5
        pup0
        Pullup Resistor Enable on GPIO0.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio0[4:0]
        GPIO0 pin Function Select.
        00000: 	Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	RX Data CLK output to be used in conjunction with RX Data pin (output)
        10000:	Reserved
        10001:	External Retransmission Request (input)
        10010:	Reserved
        10011:	Reserved
        10100:	RX Data (output)
        10101:	RX State (output)
        10110:	RX FIFO Almost Full (output)
        10111:	Antenna 1 Switch used for antenna diversity (output)
        11000:	Antenna 2 Switch used for antenna diversity (output)
        11001:	Valid Preamble Detected (output)
        11010:	Invalid Preamble Detected (output)
        11011:	Sync Word Detected (output)
        11100:	Clear Channel Assessment (output)
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>        7:6
        GPIO Driving Capability Setting.
        5
        pup1
        Pullup Resistor Enable on GPIO1.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio1[4:0]
        GPIO1 pin Function Select.
        00000: 	Inverted Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	Reserved
        10000:	Reserved
        10001:	External Retransmission Request (input)
        10010:	Reserved
        10011:	Reserved
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>        7:6
        GPIO Driving Capability Setting.
        5
        pup2
        Pullup Resistor Enable on GPIO2.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio2[4:0]
        GPIO2 pin Function Select.
        00000: 	Microcontroller Clock
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	RX Data CLK output to be used in conjunction with RX Data pin (output)
        10000:	Reserved
        10001:	External Retransmission Request (input)
        10010:	Reserved
        10011:	Reserved
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        6
        extitst[2]
        External Interrupt Status.
        If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        5
        extitst[1]
        External Interrupt Status.
        If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        4
        extitst[0]
        External Interrupt Status.
        If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        3
        itsdo
        Interrupt Request Output on the SDO Pin.
        nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        2
        dio2
        Direct I/O for GPIO2.
        If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        1
        dio1
        Direct I/O for GPIO1.
        If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        0
        dio0
        Direct I/O for GPIO0.
        If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart/adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>        7
        ADC Measurement Start Bit.
        Reading this bit gives 1 if the ADC measurement cycle has been finished.
        6:4
        adcsel[2:0]
        ADC Input Source Selection.
        The internal 8-bit ADC input source can be selected as follows:
        000:	Internal Temperature Sensor
        001:	GPIO0, single-ended
        010:	GPIO1, single-ended
        011: 	GPIO2, single-ended
        100:	GPIO0(+)     GPIO1(   ), differential
        101:	GPIO1(+)     GPIO2(   ), differential
        110:	GPIO0(+)     GPIO2(   ), differential
        111:	GND
        3:2
        adcref[1:0]
        ADC Reference Voltage Selection.
        The reference voltage of the internal 8-bit ADC can be selected as follows:
        0X:	bandgap voltage (1.2V)
        10:	VDD / 3
        11: 	VDD / 2
        1:0
        adcgain[1:0]
        ADC Sensor Amplifier Gain Selection.
        The full scale range of the internal 8-bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0:	adcref[0] = 1:
        FS = 0.014 x (adcgain[1:0] + 1) x VDD 	FS = 0.021 x (adcgain[1:0] + 1) x VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>
        3:0
        adcoffs[3:0]
        ADC Sensor Amplifier Offset*.
        *Note:	 The offset can be calculated as Offset = adcoffs[2:0] x VDD / 1000; MSB = adcoffs[3] = Sign bit.
      </Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>        7:6
        Temperature Sensor Range Selection.
        (FS range is 0..1024mV)
        00:	   40uoC .. 64uoC (full operating range), with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        01:	   40uoC .. 85uoC, with 1uoC resolution (1 LSB in the 8-bit ADC)
        11:	   0uoC .. 85uoC, with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        10:	   40uoF .. 216uoF, with 1uoF resolution (1 LSB in the 8-bit ADC)
        5
        entsoffs
        Temperature Sensor Offset to Convert from K to   C.
        4
        entstrim
        Temperature Sensor Trim Enable.
        3:0
        tstrim[3:0]
        Temperature Sensor Trim Value.
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>
        Temperature Value Offset.
        This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)
      </Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description>
        4:0
        wtr[4:0]
        Wake Up Timer Exponent (R) Value*.
        Maximum value for R is decimal 20. A value greater than 20 will yield a result as if 20 were written. R Value = 0 can be written here.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms. R=0 is allowed, and the maximum value for R is decimal 20. A value greater than 20 will result in the same as if 20 was written.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        M[7:0] = 0 is not valid here. Write at least decimal 1.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>
        Low-Duty Cycle Mode Duration (LDC)*.
        If enabled, the LDC will start together when the WUT is supposed to start, and the duration of the LDC is specified by the address 19h and the equation that goes with it. In order for the LDC to work, the LDC value has to be smaller than the M value specified in registers 15h and 16h.
        LDC = 0 is not allowed here. Write at least decimal 1.
        *Note:	 The period of the low-duty cycle ON time can be calculated as TLDC_ON = (4 x LDC x 2R) / 32.768 ms. R is the same as in the wake-up timer setting in"Register 14h. Wake-Up Timer Period 1". The LDC works in conjunction with the WUT. The LDC period must be specified to be smaller than the WUT period. (i.e., the LDC register must be smaller than the M register). The LDC may not be programmed to 0.
      </Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>
        4:0
        lbdt[4:0]
        Low Battery Detector Threshold.
        This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2.7V.*
        *Note:	 The threshold can be calculated as Vthreshold = 1.7+lbdtx50mV.
      </Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        4:0
        vbat[4:0]
        Battery Voltage Level.
        The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continuously.
      </Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>        7
        Bypass Decimator by 3 (if set).
        6:4
        ndec_exp[2:0]
        IF Filter Decimation Rates.
        3:0
        filset[3:0]
        IF Filter Coefficient Sets.
        Defaults are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz.
      </Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afcbd" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="afcgearl[2]" />
      <Bit index="1" name="afcgearl[1]" />
      <Bit index="0" name="afcgearl[0]" />
      <Description>        7
        If set, the tolerated AFC frequency error will be halved.
        6
        enafc
        AFC Enable.
        5:3
        afcgearh[2:0]
        AFC High Gear Setting.
        2:0
        afcgearl[2:0]
        AFC Low Gear Setting.
      </Description>
    </Register>
    <Register address="1E" name="AFC Timing Control" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swait_timer[1]" />
      <Bit index="6" name="swait_timer[0]" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="anwait[2]" />
      <Bit index="1" name="anwait[1]" />
      <Bit index="0" name="anwait[0]" />
      <Description>        7:6
        Short Wait RSSI Timer.
        The second phase RSSI waiting timer offset.
        5:3
        shwait[2:0]
        Short Wait Periods after AFC Correction.
        Used before preamble is detected. Short wait = (RegValue + 1)x2Tb. If set to 0 then no AFC correction will occur before preamble detect, i.e. AFC will be disabled.
        2:0
        anwait[2:0]
        Antenna Switching Wait Time.
        Value corresponds to number of bits.
      </Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>
        5:3
        crfast[2:0]
        Clock Recovery Fast Gearshift Value.
        2:0
        crslow[2:0]
        Clock Recovery Slow Gearshift Value.
        The gear-shift register controls BCR loop gain. Before the preamble is detected, BCR loop gain is as follows:
        Once the preamble is detected, internal state machine automatically shift BCR loop gain to the following:
        crfast = 3   b000 and crslow = 3   b101 are recommended for most applications. The value of    crslow    should be greater than    crfast   .
      </Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>
        Oversampling Rate.
        3 LSBs are the fraction, default = 0110 0100 = 12.5 clock cycles per data bit
        The oversampling rate can be calculated as rxosr = 500kHz/(2ndec_expxRX_DR). The ndec_exp and the dwn3_bypass values found at Address: 1Ch     IF Filter Bandwidth register together with the receive data rate (Rb) are the parameters needed to calculate rxosr:
        The Rb unit used in this equation is in kbps. The enmanch is the Manchester Coding parameter (see Reg. 70h, enmach is 1 when Manchester coding is enabled, enmanch is 0 when disabled). The number found in the equation should be rounded to an integer. The integer can be translated to a hexadecimal.
      </Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="stallctrl" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>        7:5
        Oversampling Rate.
        Upper bits.
        4
        stallctrl
        Used for BCR Purposes.
        3:0
        ncoff[19:16]
        NCO Offset.
        See formula above.
        The offset can be calculated as follows:
      </Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>
        NCO Offset.
        See formula above
      </Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>
        NCO Offset.
        See formula above
      </Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="rxncocomp" />
      <Bit index="3" name="crgain2x" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>
        4
        rxncocomp
        Receive Compensation Enable for High Data Rate Offset.
        3
        cgainx2
        Multiplying the CR Gain by 2.
        2:0
        crgain[10:8]
        Clock Recovery Timing Loop Gain.
        The loop gain can be calculated as follows:
      </Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>Clock Recovery Timing Loop Gain.</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>Received Signal Strength Indicator Value.</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="1E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>
        RSSI Threshold.
        Interrupt is set if the RSSI value is above this threshold.
      </Description>
    </Register>
    <Register address="2A" name="AFC Limiter" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Afclim[7]" />
      <Bit index="6" name="Afclim[6]" />
      <Bit index="5" name="Afclim[5]" />
      <Bit index="4" name="Afclim[4]" />
      <Bit index="3" name="Afclim[3]" />
      <Bit index="2" name="Afclim[2]" />
      <Bit index="1" name="Afclim[1]" />
      <Bit index="0" name="Afclim[0]" />
      <Description>
        AFC Limiter.
        AFC limiter value.
        For the following registers (addresses 2Bh and 2Ch), use the following equation:
        where Rb's unit is in kHz and    enmanch    is the Manchester Enable bit (found at address 71h bit [1]).
      </Description>
    </Register>
    <Register address="2B" name="AFC Correction Read" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[8]" />
      <Bit index="5" name="afc_corr[7]" />
      <Bit index="4" name="afc_corr[6]" />
      <Bit index="3" name="afc_corr[5]" />
      <Bit index="2" name="afc_corr[4]" />
      <Bit index="1" name="afc_corr[3]" />
      <Bit index="0" name="afc_corr[2]" />
      <Description>
        AFC Correction Values.
        AFC loop correction values [9:2] (MSBs only). Values are updated once, after sync word is found during receiving. See also address 2Ch.
      </Description>
    </Register>
    <Register address="2C" name="OOK Counter Value 1" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[9]" />
      <Bit index="5" name="ookfrzen" />
      <Bit index="4" name="peakdeten" />
      <Bit index="3" name="madeten" />
      <Bit index="2" name="ookcnt[10]" />
      <Bit index="1" name="ookcnt[9]" />
      <Bit index="0" name="ookcnt[8]" />
      <Description>        7:6
        AFC Correction Values.
        AFC loop correction values [1:0] (LSBs). Values are updated once, after sync word is found during receiving. See also address 2Bh.
        5
        ookfrzen
        OOK Freeze.
        OOK AGC freeze if this bit is set.
        4
        peakdeten
        Peak Detector Enable.
        Peak detector enable if high.
        3
        madeten
        MA_Enable.
        MA block enable if high.
        2:0
        ookcnt[2:0]
        OOK Counter [10:8].
        OOK counter value MSBs.
      </Description>
    </Register>
    <Register address="2D" name="OOK Counter Value 2" size="8" defaultVal="BC" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ookcnt[7]" />
      <Bit index="6" name="ookcnt[6]" />
      <Bit index="5" name="ookcnt[5]" />
      <Bit index="4" name="ookcnt[4]" />
      <Bit index="3" name="ookcnt[3]" />
      <Bit index="2" name="ookcnt[2]" />
      <Bit index="1" name="ookcnt[1]" />
      <Bit index="0" name="ookcnt[0]" />
      <Description>
        OOK Counter [7:0].
        OOK counter value LSBs.
      </Description>
    </Register>
    <Register address="2E" name="Slicer Peak Hold" size="8" defaultVal="26" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="attack[2]" />
      <Bit index="5" name="attack[1]" />
      <Bit index="4" name="attack[0]" />
      <Bit index="3" name="decay[3]" />
      <Bit index="2" name="decay[2]" />
      <Bit index="1" name="decay[1]" />
      <Bit index="0" name="decay[0]" />
      <Description>
        6:4
        attack[2:0]
        Attack.
        3:0
        decay[3:0]
        Decay.
      </Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="skip2ph" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>        7
        Enable Packet RX Handling.
        If FIFO Mode (dtmod=10) is being used automatic packet handling may be enabled. Setting enpacrx=1 will enable automatic packet handling in the RX path. Register 30   4D allow for various configurations of the packet structure. Setting enpacrx=0 will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
        6
        lsbfrst
        LSB First Enable.
        The LSB of the data will be received first if this bit is set.
        5
        crcdonly
        CRC Data Only Enable.
        When this bit is set to 1 the CRC is checked against the packet data fields only.
        4
        skip2ph
        Skip 2nd Phase of Preamble Detection.
        If set, we skip the second phase of the preamble detection (under certain conditions) if antenna diversity is enabled.
        3
        Reserved
        2
        encrc
        CRC Enable.
        Cyclic Redundancy Check generation is enabled if this bit is set.
        1:0
        crc[1:0]
        CRC Polynomial Selection.
        00:	CCITT
        01:	CRC-16 (IBM)
        10:	IEC-16
        11:	Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="rxcrc1" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="Reserved" />
      <Bit index="0" name="Reserved" />
      <Description>
        6
        rxcrc1
        If high, it indicates the last CRC received is all one   s.
        May indicated Transmitter underflow in case of CRC error.
        5
        pksrch
        Packet Searching.
        When pksrch = 1 the radio is searching for a valid packet.
        4
        pkrx
        Packet Receiving.
        When pkrx = 1 the radio is currently receiving a valid packet.
        3
        pkvalid
        Valid Packet Received.
        When a pkvalid = 1 a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
        2
        crcerror
        CRC Error.
        When crcerror = 1 a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
        1:0
        Reserved
        1
        pktx
        Packet Transmitting.
        When pktx = 1 the radio is currently transmitting a packet.
        0
        pksent
        Packet Sent.
        A pksent = 1 a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcen[3]" />
      <Bit index="6" name="bcen[2]" />
      <Bit index="5" name="bcen[1]" />
      <Bit index="4" name="bcen[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>        7:4
        Broadcast Address (FFh) Check Enable.
        If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
        0000:	No broadcast address enable.
        0001:	Broadcast address enable for header byte 0.
        0010:	Broadcast address enable for header byte 1.
        0011:	Broadcast address enable for header bytes 0 &amp; 1.
        0100:
        3:0
        hdch[3:0]
        Received Header Bytes to be Checked Against the Check Header Bytes.
        One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.
        0000:	No Received Header check
        0001:	Received Header check for byte 0.
        0010:	Received Header check for bytes 1.
        0011:	Received header check for bytes 0 &amp; 1.
        0100:
      </Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        6:4
        hdlen[2:0]
        Header Length.
        Length of header used if packet handler is enabled for RX (enpacrx). Headers are received in descending order.
        000:	NoRX header
        001: 	Header 3
        010: 	Header 3 and 2
        011: 	Header 3 and 2 and 1
        100: 	Header 3 and 2 and 1 and 0
        3
        fixpklen
        Fix Packet Length.
        When fixpklen = 1 the packet length (pklen[7:0]) is not included in the header. When fixpklen = 0 the packet length is included in the header.
        2:1
        synclen[1:0]
        Synchronization Word Length.
        The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00: 	Synchronization Word 3
        01: 	Synchronization Word 3 and 2
        10: 	Synchronization Word 3 and 2 and 1
        11: 	Synchronization Word 3 and 2 and 1 and 0
        0
        prealen[8]
        MSB of Preamble Length.
        See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>
        Preamble Length.
        The value in the prealen[8:0] register corresponds to the number of nibbles (4 bits) in the packet. For example prealen[8:0] =    000001000    corresponds to a preamble length of 32 bits (8x4bits) or 4 bytes. The maximum preamble length is prealen[8:0] = 111111111 which corresponds to a 255 bytes Preamble. Writing 0 will have the same result as if writing 1, which corresponds to one single nibble of preamble.
      </Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description>        7:3
        Number of nibbles processed during detection.
        2:0
        rssi_offset[2:0]
        rssi_offset[2:0]
        Value added as offset to RSSI calculation. Every increment in this register results in an increment of +4dB in the RSSI.
      </Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>
        Synchronization Word 3.
        4th byte of the synchronization word.
      </Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>
        Synchronization Word 2.
        3rd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>
        Synchronization Word 1.
        2nd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>
        Synchronization Word 0.
        1st byte of the synchronization word.
      </Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>
        Check Header 3.
        4th byte of the check header.
      </Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>
        Check Header 2.
        3rd byte of the check header.
      </Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>
        Check Header 1.
        2nd byte of the check header.
      </Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>
        Check Header 0.
        1st byte of the check header.
      </Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>
        Header Enable 3.
        4th byte of the check header.
      </Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>
        Header Enable 2.
        3rd byte of the check header.
      </Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>
        Header Enable 1.
        2nd byte of the check header.
      </Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>
        Header Enable 0.
        1st byte of the check header.
      </Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>
        Received Header 3.
        4th byte of the received header.
      </Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>
        Received Header 2.
        3rd byte of the received header.
      </Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>
        Received Header 1.
        2nd byte of the received header.
      </Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>
        Received Header 0.
        1st byte of the received header.
      </Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>
        Length Byte of the Received Packet during fixpklen = 0.
        (Specifies the number of Data bytes in the last received packet) This will be relevant ONLY if fixpklen (address 33h, bit[3]) is low during the receive time. If fixpklen is high, then the number of received Data Bytes can be read from the pklen register (address h3E).
      </Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description>
        5:0
        adc8[5:0]
        ADC8 Control Bits.
      </Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>
        4:0
        atb[4:0]
        Analog Test Bus.
        The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
        Table 30. Internal Analog Signals Available on the Analog Test Bus
        Addr
        hex
        ATBp
        ATBn
        0
        0
        1
        1
        MixIp
        MixIn
        2
        2
        MixQp
        MixQn
        3
        3
        PGA_Ip
        PGA_In
        4
        4
        PGA_Qp
        PGA_Qn
        5
        5
        vcmout
        vbn
        6
        6
        refmid
        vbiasp
        7
        7
        ADC_vcm
        ADC_vcmb
        8
        8
        ADC_ipoly10
        ADC_ref
        9
        9
        RefADC_p
        RefADC_m
        10
        A
        ADC_Res1Ip
        ADC_Res1In
        11
        B
        ADC_Res1Qp
        ADC_Res1Qn
        12
        C
        ADC_Res2Ip
        ADC_Res2In
        13
        D
        ADC_Res2Qp
        ADC_Res2Qn
        14
        E
        ADC_Res3Ip
        ADC_Res3In
        15
        F
        ADC_Res3Qp
        ADC_Res3Qn
        16
        10
        NC
        NC
        17
        11
        ADC_Cal_Ucap
        ADC_Cal_Ures
        18
        12
        I_CP_test
        PLL_IBG_05
        19
        13
        PLL_VBG
        VSS_VCO
        20
        14
        Vctrl_Test
        PLL_IPTAT_05
        21
        15
        PA_Vbias
        NC
        22
        16
        DIGBG
        DIGVFB
        23
        17
        IFBG
        IFVFB
        24
        18
        PLLBG
        PLLVREG
        25
        19
        IBias_10u
        IBias_5u
        26
        1A
        CLK_65K_Out
        AVSS
        27
        1B
        ADC8_VIN
        ADC8_VDAC
        28
        1C
        LBDcomp
        LBDcompref
        29
        1D
        TSBG
        TSVtemp
        30
        1E
        RFBG
        RFVREG
        31
        1F
        VCOBG
        VCOVREG
      </Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description></Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>        7:3
        PLL Soft Settling Time (TS).
        This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0   s and 310  s, in 10   s intervals. The default plltime corresponds to 100  s. See formula above.
        2:0
        pllt0
        PLL Settling Time (TO).
        This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0   s and 70  s, in 10  s steps. The default pllt0 corresponds to 20  s. See formula above.
      </Description>
    </Register>
    <Register address="54" name="Invalid Preamble Threshold and PA Misc" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="pa_duty[1]" />
      <Bit index="4" name="pa_duty[0]" />
      <Bit index="3" name="ldoramplv[1]" />
      <Bit index="2" name="ldoramplv[0]" />
      <Bit index="1" name="Ido_pa_boost" />
      <Bit index="0" name="pabias_boost" />
      <Description>
        5:4
        pa_duty[1:0]
        PA Duty Cycle Control.
        Shifting the duty cycle of the PA will effect PA efficiency and harmonics.
        3:2
        ldoramplv[1:0]
        PA LDO Ramp Level.
        The starting ramp level of the PA LDO. The ramp level will effect modulation depth and spectral splatter.
        1
        ldo_pa_boost
        LDO PA Boost.
        0
        pa_vbias_boost
        PA VBIAS Boost.
      </Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        6
        xtalstarthalf
        If Set, the Xtal Wake Time Period is Halved.
        5
        adccaldone
        Delta-sigma ADC Calibration Done.Reading this bit gives 1 if the calibration process has been finished.
        4
        enrcfcal
        RC Oscillator Fine Calibration Enable.
        If this bit is set to 1 then the RC oscillator performs fine calibration in every app. 30 s.
        3
        rccal
        RC Calibration Force.
        If setting rccal=1 will automatically perform a forced calibration of the 32kHz RC Oscillator. The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a 0 to 1 will initiate the calibration. This bit is cleared automatically.
        2
        vcocaldp
        VCO Calibration Double Precision Enable.
        When this bit is set to 1 then the VCO calibration measures longer thus calibrates more precisely.
        1
        vcocal
        VCO Calibration Force.
        If in Idle Mode and pllon=1, setting vcocal=1 will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        0
        skipvco
        Skip VCO Calibration.
        Setting skipvco=1 will skip the VCO calibration when going from the Idle state to the RX state.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="oscdeten" />
      <Bit index="3" name="rssimasel" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>        7
        If set, BCR phase compensation will be bypassed.
        6
        slicfbyp
        If set, slicer phase compensation will be bypassed.
        5
        dttype
        Dithering Type.
        If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add   1.
        4
        oscdeten
        If low, the ADC Oscillation Detection mechanism is allowed to work. If set, we disable the function.
        3
        rssimasel
        RSSI Moving Average Select.
        If 1 then the RSSI moving average read back is 8 bits. If 0 then the moving average is set to 4 bits.
        2
        refclksel
        Delta-Sigma Reference Clock Source Selection
        1:	10MHz
        0:	 PLL
        1
        refclkinv
        Delta-Sigma Reference Clock Inversion Enable.
        0
        distogg
        If reset, the discriminator toggling is disabled.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>        7
        Direct Control to Analog.
        6
        fbdiv_rst
        Direct Control to Analog.
        5
        cpforceup
        Charge Pump Force Up.
        4
        cpforcedn
        Charge Pump Force Down.
        3
        cdconly
        Charge Pump DC Offset Only.
        2:0
        cdcurr[2:0]
        Charge Pump DC Current Selection.
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming/Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>        7:6
        Charge Pump Current (Gain Setting).
        Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        5
        cpcorrov
        Charge Pump Correction Override Enable.
        4:0
        cpcorr[4:0]
        Charge Pump Correction Value.
        During read, you read what the Charge Pump sees. If cpcorrov = 1, then the value you write will go to the Charge Pump, and will also be the value you read. By default, cpcorr[4:0] wakes up as all Zeros.
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        6
        fbdivhc
        Feedback (fractional) Divider High Current Enable (+5  A).
        5:4
        d3trim[1:0]
        Divider 3 Current Trim Value.
        3:2
        d2trim[1:0]
        Divider 2 Current Trim Value.
        1:0
        d1p5trim[1:0]
        Divider 1.5 (div-by-1.5) Current Trim Value.
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        6
        vcocorrov
        VCO Current Correction Override.
        5:2
        vcocorr[3:0]
        VCO Current Correction Value.
        1:0
        vcocur[1:0]
        VCO Current Trim Value.
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov/vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>        7
        VCO Calibration Override/Done.
        When vcocalov=0 the internal VCO calibration results may be viewed by reading the vcocal register. When vcocalov=1 the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives 1 if the calibration process has been finished.
        6:0
        vcocal[6:0]
        VCO Calibration Results.
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="0" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>        7
        Enable DSM Dithering.
        If low, dithering is disabled.
        6
        Reserved
        Will read 0.
        5
        enoloop
        Open Loop Mode Enable.
        4
        dsmod
        Delta-Sigma Modulus.
        0: 64000
        1: 65 536
        3:2
        dsorder[1:0]
        Delta-Sigma Order.
        00: 	0 order
        01: 	1st order
        10: 	2nd order
        11: 	Mash 111
        1
        dsrstmode
        Delta-Sigma Reset Mode.
        0
        dsrst
        Delta-Sigma Reset.
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>        7
        Mixer Enable Override.
        6
        enlna
        LNA Enable Override.
        5
        enpga
        PGA Enable Override.
        4
        Reserved
        3
        enbf5
        Buffer 5 Enable Override.
        2
        endv32
        Divider 3_2 Enable Override.
        1
        enbf12
        Buffer 1_2 Enable Override.
        0
        enmx2
        Multiplexer 2 Enable Override.
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>        7
        Delta-Sigma Enable Override.
        6
        Reserved
        5
        enmx3
        Multiplexer 3 Enable Override.
        4
        enbf4
        Buffer 4 Enable Override.
        3
        enbf3
        Buffer 3 Enable Override.
        2
        enbf11
        Buffer 1_1 Enable Override.
        1
        enbf2
        Buffer 2 Enable Override.
        0
        pllreset
        PLL Reset Enable Override.
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>        7
        Fractional Divider Enable Override.
        6
        endv31
        Divider 3_1 Enable Override.
        5
        endv2
        Divider 2 Enable Override.
        4
        endv1p5
        Divider 1.5 (div-by-1.5) Enable Override.
        3
        dvbshunt
        VCO Bias Shunt Enable Override Mode.
        2
        envco
        VCO Enable Override.
        1
        encp
        Charge Pump Enable Override.
        0
        enbg
        Bandgap Enable Override.
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="50" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>
        3:0
        chfiladd[3:0]
        Channel Filter Coefficient Look-up Table Address.
        The address for channel filter coefficients used in the RX path.
      </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>
        5:0
        chfilval[5:0]
        Filter Coefficient Value in the Look-up Table Addressed by the chfiladd[3:0].
      </Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>        7:5
        Internal Power States of the Chip.
        LP:	000
        RDY:	001
        Tune:	011
        RX:	111
        4
        clkhyst
        Clock Hysteresis Setting.
        3
        enbias2x
        2 Times Higher Bias Current Enable.
        2
        enamp2x
        2 Times Higher Amplification Enable.
        1
        bufovr
        Output Buffer Enable Override.
        If set to 1 then the enbuf bit controls the output buffer.
        0: output buffer is controlled by the state machine.
        1: output buffer is controlled by the enbuf bit.
        0
        enbuf
        Output Buffer Enable.
        This bit is active only if the bufovr bit is set to 1.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>        7
        RC Oscillator Coarse Calibration Override.
        When rccov=0 the internal Coarse Calibration results may be viewed by reading the rcccal register. When rccov=1 the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        6:0
        rcc[6:0]
        RC Oscillator Coarse Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>        7
        RC Oscillator Fine Calibration Override.
        When rcfov=0 the internal Fine Calibration results may be viewed by reading the rcfcal register. When rcfov=1 the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        6:0
        rcf[6:0]
        RC Oscillator Fine Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>        7
        Smart POR Enable.
        6
        enbias
        Bias Enable.
        5
        envcoldo
        VCO LDO Enable.
        4
        enifldo
        IF LDO Enable.
        3
        enrfldo
        RF LDO Enable.
        2
        enpllldo
        PLL LDO Enable.
        1
        endigldo
        Digital LDO Enable.
        0
        endigpwdn
        Digital Power Domain Powerdown Enable in Idle Mode.
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>        7
        Enable Overrides.
        If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks.
        6
        enxtal
        Xtal Override Enable Value.
        5
        ents
        Temperature Sensor Enable.
        4
        enrc32
        32K Oscillator Enable.
        3
        Reserved
        2:0
        diglvl
        Digital LDO Level Setting.
      </Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="1F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>        7
        Delta-Sigma ADC Reset.
        Active low.
        6
        enrefdac
        Delta-Sigma ADC Reference DAC Enable Override.
        5
        enadc
        Delta-Sigma ADC Enable Override.
        4
        adctuneovr
        Resonator RC Calibration Value Override Enable.
        3:0
        adctune[3:0]
        Resonator RC Calibration Value.
      </Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>
        4
        envcm
        Delta-Sigma ADC VCM Enable Override.
        3
        adcoloop
        Delta-Sigma ADC Open Loop Enable.
        2:0
        adcref[2:0]
        Delta-Sigma ADC Reference Voltage.
        000:	0.5 V
        001:	0.6 V
        010:	0.7 V

        111:	1.2 V
      </Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sgi" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>
        6
        SGI
        Stop Increasing Gain for AGC Loop.
        Default = 0.
        5
        agcen
        Automatic Gain Control Enable.
        When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
        4
        lnagain
        LNA Gain Select.
        0     min. gain = 5 dB	1    max. gain = 25 dB
        3:0
        pga[3:0]
        PGA Gain Override Value.
        000:	0 dB
        001:	3 dB
        010:	6 dB
        ...
        101:	24 dB max.
      </Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="agcovpm" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>        7
        If set, AGC will ignore the Preamble Detection.
        6
        agcslow
        AGC Slow Gain Increase Enable.
        When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
        5:2
        lnacomp[3:0]
        LNA Gain Compensation.
        This bit is used for smoothing RSSI value when LNA gain is switched.
        1:0
        pgath[1:0]
        Window Comparator Reference Voltage Adjust in the PGA.
      </Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        5
        Reserved
        4
        enphpwdn
        If set, the Packet Handler will be powered down when chip is in low power mode.
        3
        manppol
        Manchester Preamble Polarity (will transmit a series of 1 if set, or series of 0 if reset).
        This is valid ONLY if Manchester Mode is enabled.
        2
        enmaninv
        Manchester Data Inversion is Enabled if this bit is set.
        1
        enmanch
        Manchester Coding is Enabled if this bit is set.
        0
        enwhite
        Data Whitening is Enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        5:4
        dtmod[1:0]
        Modulation Source.
        00: 	Direct Mode using TX_Data function via the GPIO pin 	(one of the GPIO   s should be programmed accordingly as well)
        01: 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10: 	FIFO Mode
        11: 	PN9 (internally generated)
        3
        eninv
        RX Data.
        2
        fd[8]
        MSB of Frequency Deviation Setting, see"Register 72h. Frequency Deviation".
        1:0
        Reserved
      </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>
        Frequency Offset Setting.
        The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value. Reading from this register will give the AFC correction last results, not this register value.
      </Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>
        1:0
        fo[9:8]
        Upper Bits of the Frequency Offset Setting.
        fo[9] is the sign bit.The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value. Reading from this register will give the AFC correction last results, not this register value.
      </Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        6
        sbsel
        Side Band Select.
        5
        hbsel
        High Band Select.
        Setting hbsel = 1 will choose the frequency range from 480   960MHz (high bands). Setting hbsel = 0 will choose the frequency range from 240   479.9MHz (low bands).
        4:0
        fb[4:0]
        Frequency Band Select.
        Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands. Setting fb[4:0]=00000 corresponds to the 240   250MHz Band for hbsel=0 and the 480   500MHz Band for hbsel=1. Setting fb[4:0]=00001 corresponds to the 250   260MHz Band for hbsel=0 and the 500   520MHz Band for hbsel=1.
        The RF carrier frequency can be calculated as follows:
        fcarrier = (fb+24+(fc+fo) / 64000)x10000x(hbsel+1) + (fhchxfhsx10) [kHz],
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>
        Nominal Carrier Frequency Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>
        Nominal Carrier Frequency Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="78" name="Miscellaneous Settings" size="8" defaultVal="19" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="ifsw_en" />
      <Bit index="3" name="Alt_PA_Seq" />
      <Bit index="2" name="rcosc[2]" />
      <Bit index="1" name="rcosc[1]" />
      <Bit index="0" name="rcosc[0]" />
      <Description>
        4
        ifsw_en
        Enable for IF SW between PA and IF.
        3
        alt_pa_seq
        Alternative PA sequencing.
        If set, we will enable the alternative PA sequence. By default, this is not enabled.
        2:0
        rcosc_cal[2:0]
        rcosc_cal[2:0].
        Fine changes on the RC OSC Calibration target frequency, to help compensate for    calibration biases.    This register should not be changed by costumers.
      </Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>Frequency Hopping Channel Number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>
        Frequency Hopping Step Size in 10kHz Increments.
        See formula for the nominal carrier frequency at"Register 76h. Nominal Carrier Frequency".
      </Description>
    </Register>
    <Register address="7B" name="Turn Around and 15.4 Length Compliance" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="15.4 Length" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="turn_around_en" />
      <Bit index="1" name="Phase[1]" />
      <Bit index="0" name="Phase[0]" />
      <Description>
        15.4 Packet Length Compliance.
        If set, then PK Length definition for both TX and RX will also include the CRC bytes, If reset, then the Length refers ONLY to the DATA payload. For example, writing    9    to this register when it is set, means we are sending/expecting    7    bytes of DATA, and the other    2    should be the CRC (CRC should be enabled separately).
        6:3
        Reserved[6:3]
        2
        turn_around_en
        Turn Around Enable.
        Enabling for the turn around functionality.
        1:0
        phase[1:0]
        Turn Around Phase.
        The RX to TX and vice-versa change in frequency will happen (if bit [2] is set) at the last byte, and these two registers set the bit position in which the frequency shifts should occur. Make sure it does not happen to early otherwise the last bits will be missed.
      </Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>
        5:0
        rxafthr[5:0]
        RX FIFO Almost Full Threshold.
      </Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        FIFO Data.
        A Read (R/W=0) to this address will begin a burst read of the RX FIFO.
      </Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="20" type="Si4432" revision="B0" projectID="0" name="Ara 4430-31-32_B0">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        dt[4:0]
        Device Type Code.
        EZRadioPRO: 01000.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="05" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>
        4:0
        vc[4:0]
        Version Code.
        Code indicating the version of the chip.

      </Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="8" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>        7
        RX/TX FIFO Overflow Status.
        6
        ffunfl
        RX/TX FIFO Underflow Status.
        5
        rxffem
        RX FIFO Empty Status.
        4
        headerr
        Header Error Status.
        Indicates if the received packet has a header check error.
        3:2
        Reserved
        1:0
        cps[1:0]
        Chip Power State.
        00:	Idle State
        01:	RX State10:	TX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>        7
        FIFO Underflow/Overflow Error.
        When set to 1 the TX or RX FIFO has overflowed or underflowed.
        6
        itxffafull
        TX FIFO Almost Full.
        When set to 1 the TX FIFO has met its almost full threshold and needs to be transmitted.
        5
        itxffaem
        TX FIFO Almost Empty.
        When set to 1 the TX FIFO is almost empty and needs to be filled.
        4
        irxffafull
        RX FIFO Almost Full.When set to 1 the RX FIFO has met its almost full threshold and needs to be read by the microcontroller.
        3
        iext
        External Interrupt.
        When set to 1 an interrupt occurred on one of the GPIO   s if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        2
        ipksent
        Packet Sent Interrupt.
        When set to1 a valid packet has been transmitted.
        1
        ipkvalid
        Valid Packet Received.When set to 1 a valid packet has been received.
        0
        icrcerror
        CRC Error.
        When set to 1 the cyclic redundancy check is failed.
        When any of the Interrupt/Status 1 bits change state from 0 to 1 the device will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 1 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 1 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
        Table 27. Interrupt or Status 1 Bit Set/Clear Description
        Bit
        Status Name
        Set/Clear Conditions
        7
        ifferr
        Set if there is a FIFO overflow or underflow. Cleared by applying FIFO reset.
        6
        itxffafull
        Set when the number of bytes written to TX FIFO is greater than the Almost Full threshold. Automatically cleared at the start of transmission when the number of bytes in the FIFO is less than or equal to the threshold.
        5
        itxffaem
        Set when the number of bytes in the TX FIFO is less than or equal to the Almost Empty threshold. Automatically cleared when the number of data bytes in the TX FIFO is above the Almost Empty threshold.
        4
        irxffafull
        Set when the number of bytes in the RX FIFO is greater than the Almost Full threshold. Cleared when the number of bytes in the RX FIFO is below the Almost Full threshold.
        3
        iext
        External interrupt source.
        2
        ipksent
        Set once a packet is successfully sent (no TX abort). Cleared upon leaving FIFO mode or at the start of a new transmission.
        1
        ipkvalid
        Set up the successful reception of a packet (no RX abort). Cleared upon receiving and acknowledging the Sync Word for the next packet.
        0
        icrcerror
        Set if the CRC computed from the RX packet differs from the CRC in the TX packet. Cleared at the start of reception for the next packet.
        Table 28. When are Individual Status Bits Set/Cleared if not Enabled as Interruptsu
        Bit
        Status Name
        Set/Clear Conditions
        7
        ifferr
        Set if there is a FIFO Overflow or Underflow. It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
        6
        itxffafull
        Will be set when the number of bytes written to TX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we start transmitting and the FIFO data is read out and the number of bytes left in the FIFO is smaller or equal to the threshold).
        5
        itxffaem
        Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
        4
        irxffafull
        Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we read enough data from RX FIFO so that the number of data bytes not yet read is below the Almost Full threshold.
        3
        iext
        External interrupt source
        2
        ipksent
        Will go high once a packet is sent all the way through (no TX abort). This status will be cleaned if 1) We leave FIFO mode or 2) In FIFO mode we start a new transmission.
        1
        ipkvalid
        Goes high once a packet is fully received (no RX abort). It is automatically cleaned once we receive and acknowledge the Sync Word for the next packet.
        0
        icrcerror
        Goes High once the CRC computed during RX differs from the CRC sent in the packet by the TX. It is cleaned once we start receiving new data in the next packet.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>        7
        Sync Word Detected.
        When a sync word is detected this bit will be set to 1.
        6
        ipreaval
        Valid Preamble Detected.
        When a preamble is detected this bit will be set to 1.
        5
        ipreainval
        Invalid Preamble Detected.
        When the preamble is not found within a period of time set by the invalid preamble detection threshold in Register 54h, this bit will be set to 1.
        4
        irssi
        RSSI.
        When RSSI level exceeds the programmed threshold this bit will be set to 1.
        3
        iwut
        Wake-Up-Timer.
        On the expiration of programmed wake-up timer this bit will be set to 1.
        2
        ilbd
        Low Battery Detect.
        When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        1
        ichiprdy
        Chip Ready (XTAL).
        When a chip ready event has been detected this bit will be set to 1.
        0
        ipor
        Power-on-Reset (POR).
        When the chip detects a Power on Reset above the desired setting this bit will be set to 1.
        When any of the Interrupt/Status Register 2 bits change state from 0 to 1 the control block will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 2 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 2 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
        Table 29.  Interrupt or Status 2 Bit Set/Clear Description
        Bit
        Status Name
        Set/Clear Conditions
        7
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        6
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        5
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        4
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        3
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        2
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        1
        ichiprdy
        Chip ready goes high once we enable the xtal, TX or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        0
        ipor
        Power on status.
        Table 30. Detailed Description of Status Registers when not Enabled as Interrupts
        Bit
        Status Name
        Set/Clear Conditions
        7
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        6
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        5
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        4
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        3
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        2
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        1
        ichiprdy
        Chip ready goes high once we enable the xtal, TX or RX, and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        0
        ipor
        Power on status.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>        7
        Enable FIFO Underflow/Overflow.
        When set to 1 the FIFO Underflow/Overflow interrupt will be enabled.
        6
        entxffafull
        Enable TX FIFO Almost Full.
        When set to 1 the TX FIFO Almost Full interrupt will be enabled.
        5
        entxffaem
        Enable TX FIFO Almost Empty.
        When set to 1 the TX FIFO Almost Empty interrupt will be enabled.
        4
        enrxffafull
        Enable RX FIFO Almost Full.
        When set to 1 the RX FIFO Almost Full interrupt will be enabled.
        3
        enext
        Enable External Interrupt.
        When set to 1 the External Interrupt will be enabled.
        2
        enpksent
        Enable Packet Sent.
        When ipksent =1 the Packet Sense Interrupt will be enabled.
        1
        enpkvalid
        Enable Valid Packet Received.
        When ipkvalid = 1 the Valid Packet Received Interrupt will be enabled.
        0
        encrcerror
        Enable CRC Error.
        When set to 1 the CRC Error interrupt will be enabled.
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>        7
        Enable Sync Word Detected.
        When mpreadet =1 the Preamble Detected Interrupt will be enabled.
        6
        enpreaval
        Enable Valid Preamble Detected.
        When mpreadet =1 the Valid Preamble Detected Interrupt will be enabled.
        5
        enpreainval
        Enable Invalid Preamble Detected.
        When mpreadet =1 the Invalid Preamble Detected Interrupt will be enabled.
        4
        enrssi
        Enable RSSI.
        When set to 1 the RSSI Interrupt will be enabled.
        3
        enwut
        Enable Wake-Up Timer.
        When set to 1 the Wake-Up Timer interrupt will be enabled.
        2
        enlbd
        Enable Low Battery Detect.
        When set to 1 the Low Battery Detect interrupt will be enabled.
        1
        enchiprdy
        Enable Chip Ready (XTAL).
        When set to 1 the Chip Ready interrupt will be enabled.
        0
        enpor
        Enable POR.
        When set to 1 the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>        7
        Software Register Reset Bit.
        This bit may be used to reset all registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register. The RESET is accomplished by setting swres = 1. This bit will be automatically cleared.
        6
        enlbd
        Enable Low Battery Detect.
        When this bit is set to 1 the Low Battery Detector circuit and threshold comparison will be enabled.
        5
        enwt
        Enable Wake-Up-Timer.
        Enabled when enwt = 1. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        4
        x32ksel
        32,768 kHz Crystal Oscillator Select.
        0:	RC oscillator
        1:	32kHz crystal
        3
        txon
        TX on in Manual Transmit Mode.
        Automatically cleared in FIFO mode once the packet is sent. Transmission can be aborted during packet transmission, however, when no data has been sent yet, transmission can only be aborted after the device is programmed to    unmodulated carrier    ("Register 71h. Modulation Mode Control 2").
        2
        rxon
        RX on in Manual Receiver Mode.
        Automatically cleared if Multiple Packets config. is disabled and a valid packet received.
        1
        pllon
        TUNE Mode (PLL is ON).
        When pllon = 1 the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        0
        xton
        READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="ffclrtx" />
      <Description>        7:5
        Enable Antenna Diversity.
        The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
        RX/TX state	non RX/TX state
        GPIO Ant1	GPIO Ant2	GPIO Ant1	GPIO Ant2
        000: 	0	1	0	0
        001:	1	0	0	0
        010: 	0	1	1	1
        011:	1	0	1	1
        100:	antenna diversity algorithm	0	0
        101: 	antenna diversity algorithm	1	1
        110:	ant. div. algorithm in beacon mode	0	0
        111: 	ant. div. algorithm in beacon mode 	1	1
        4
        rxmpk
        RX Multi Packet.
        When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the transceiver will automatically leave the RX State after the first valid packet has been received.
        3
        autotx
        Automatic Transmission.
        When autotx = 1 the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.
        2
        enldm
        Enable Low Duty Cycle Mode.
        If this bit is set to 1 then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
        1
        ffclrrx
        RX FIFO Reset/Clear.
        This has to be a two writes operation: Setting ffclrrx=1 followed by ffclrrx= 0 will clear the contents of the RX FIFO.
        0
        ffclrtx
        TX FIFO Reset/Clear.
        This has to be a two writes operation: Setting ffclrtx=1 followed by ffclrtx= 0 will clear the contents of the TX FIFO.
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>        7
        Additional capacitance to course shift the frequency if xlc[6:0] is not sufficient. Not binary with xlc[6:0].
        6:0
        xlc[6:0]
        Tuning Capacitance for the 30MHz XTAL.
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        5:4
        clkt[1:0]
        Clock Tail.
        If enlfc = 0 then it can be useful to provide a few extra cycles for the microcontroller to complete its operation. Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00: 	0 cycle
        01: 	128 cycles
        10: 	256 cycles
        11: 	512 cycles
        3
        enlfc
        Enable Low Frequency Clock.
        When enlfc = 1 and the chip is in Sleep mode then the 32.768kHz clock will be provided to the microcontroller no matter what the selection of mclk[2:0] is. For example if mclk[2:0] =    000   , 30MHz will be available through the GPIO to output to the microcontroller in all Idle, TX, or RX states. When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        2:0
        mclk[2:0]
        Microcontroller Clock.
        Different clock frequencies may be selected for configurable GPIO clock output. All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator. The mclk[2:0] setting is only valid when xton = 1 except the 111.
        000: 	30 MHz
        001: 	15 MHz
        010: 	10 MHz
        011: 	4 MHz
        100: 	3 MHz
        101: 	2 MHz
        110: 	1 MHz
        111:	32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>        7:6
        GPIO Driving Capability Setting.
        5
        pup0
        Pullup Resistor Enable on GPIO0.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio0[4:0]
        GPIO0 pin Function Select.
        00000: 	Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	RX Data (output)
        10101:	RX State (output)
        10110:	RX FIFO Almost Full (output)
        10111:	Antenna 1 Switch used for antenna diversity (output)
        11000:	Antenna 2 Switch used for antenna diversity (output)
        11001:	Valid Preamble Detected (output)
        11010:	Invalid Preamble Detected (output)
        11011:	Sync Word Detected (output)
        11100:	Clear Channel Assessment (output)
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>        7:6
        GPIO Driving Capability Setting.
        5
        pup1
        Pullup Resistor Enable on GPIO1.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio1[4:0]
        GPIO1 pin Function Select.
        00000: 	Inverted Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	RX Data (output)
        10101:	RX State (output)
        10110:	RX FIFO Almost Full (output)
        10111:	Antenna 1 Switch used for antenna diversity (output)
        11000:	Antenna 2 Switch used for antenna diversity (output)
        11001:	Valid Preamble Detected (output)
        11010:	Invalid Preamble Detected (output)
        11011:	Sync Word Detected (output)
        11100:	Clear Channel Assessment (output)
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>        7:6
        GPIO Driving Capability Setting.
        5
        pup2
        Pullup Resistor Enable on GPIO2.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio2[4:0]
        GPIO2 pin Function Select.
        00000: 	Microcontroller Clock
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	RX Data (output)
        10101:	RX State (output)
        10110:	RX FIFO Almost Full (output)
        10111:	Antenna 1 Switch used for antenna diversity (output)
        11000:	Antenna 2 Switch used for antenna diversity (output)
        11001:	Valid Preamble Detected (output)
        11010:	Invalid Preamble Detected (output)
        11011:	Sync Word Detected (output)
        11100:	Clear Channel Assessment (output)
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        6
        extitst[2]
        External Interrupt Status.
        If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        5
        extitst[1]
        External Interrupt Status.
        If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        4
        extitst[0]
        External Interrupt Status.
        If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        3
        itsdo
        Interrupt Request Output on the SDO Pin.
        nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        2
        dio2
        Direct I/O for GPIO2.
        If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        1
        dio1
        Direct I/O for GPIO1.
        If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        0
        dio0
        Direct I/O for GPIO0.
        If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart/adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>        7
        ADC Measurement Start Bit.
        Reading this bit gives 1 if the ADC measurement cycle has been finished.
        6:4
        adcsel[2:0]
        ADC Input Source Selection.
        The internal 8-bit ADC input source can be selected as follows:
        000:	Internal Temperature Sensor
        001:	GPIO0, single-ended
        010:	GPIO1, single-ended
        011: 	GPIO2, single-ended
        100:	GPIO0(+)     GPIO1(   ), differential
        101:	GPIO1(+)     GPIO2(   ), differential
        110:	GPIO0(+)     GPIO2(   ), differential
        111:	GND
        3:2
        adcref[1:0]
        ADC Reference Voltage Selection.
        The reference voltage of the internal 8-bit ADC can be selected as follows:
        0X:	bandgap voltage (1.2V)
        10:	VDD / 3
        11: 	VDD / 2
        1:0
        adcgain[1:0]
        ADC Sensor Amplifier Gain Selection.
        The full scale range of the internal 8-bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0:	adcref[0] = 1:
        FS = 0.014 x (adcgain[1:0] + 1) x VDD 	FS = 0.021 x (adcgain[1:0] + 1) x VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>
        3:0
        adcoffs[3:0]
        ADC Sensor Amplifier Offset*.
        *Note:	 The offset can be calculated as Offset = adcoffs[2:0] x VDD / 1000; MSB = adcoffs[3] = Sign bit.
      </Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>        7:6
        Temperature Sensor Range Selection.
        (FS range is 0..1024mV)
        00:	   40uoC .. 64uoC (full operating range), with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        01:	   40uoC .. 85uoC, with 1uoC resolution (1 LSB in the 8-bit ADC)
        11:	   0uoC .. 85uoC, with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        10:	   40uoF .. 216uoF, with 1uoF resolution (1 LSB in the 8-bit ADC)
        5
        entsoffs
        Temperature Sensor Offset to Convert from K to   C.
        4
        entstrim
        Temperature Sensor Trim Enable.
        3:0
        tstrim[3:0]
        Temperature Sensor Trim Value.
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>
        Temperature Value Offset.
        This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)
        Note:	If a new configuration is needed (e.g., for the WUT or the LDC), proper functionality is required. The function must first be disabled, then the settings changed, then enabled back on.
        Bit
        Name
        Function
        7:5
        Reserved
        4:0
        wtr[4:0]
        Wake Up Timer Exponent (R) Value*.
        Maximum value for R is decimal 20. A value greater than 20 will yield a result as if 20 were written. R Value = 0 can be written here.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms. R=0 is allowed, and the maximum value for R is decimal 20. A value greater than 20 will result in the same as if 20 was written.
      </Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description></Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        M[7:0] = 0 is not valid here. Write at least decimal 1.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>
        Low-Duty Cycle Mode Duration (LDC)*.
        If enabled, the LDC will start together when the WUT is supposed to start, and the duration of the LDC is specified by the address 19h and the equation that goes with it. In order for the LDC to work, the LDC value has to be smaller than the M value specified in registers 15h and 16h.
        LDC = 0 is not allowed here. Write at least decimal 1.
        *Note:	 The period of the low-duty cycle ON time can be calculated as TLDC_ON = (4 x LDC x 2R) / 32.768 ms. R is the same as in the wake-up timer setting in"Register 14h. Wake-Up Timer Period 1". The LDC works in conjunction with the WUT. The LDC period must be specified to be smaller than the WUT period. (i.e., the LDC register must be smaller than the M register). The LDC may not be programmed to 0.
      </Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>
        4:0
        lbdt[4:0]
        Low Battery Detector Threshold.
        This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2.7V.*
        *Note:	 The threshold can be calculated as Vthreshold = 1.7+lbdtx50mV.
      </Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        4:0
        vbat[4:0]
        Battery Voltage Level.
        The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continuously.
      </Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>        7
        Bypass Decimator by 3 (if set).
        6:4
        ndec_exp[2:0]
        IF Filter Decimation Rates.
        3:0
        filset[3:0]
        IF Filter Coefficient Sets.
        Defaults are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz.
      </Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afcbd" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="afcgearl[2]" />
      <Bit index="1" name="afcgearl[1]" />
      <Bit index="0" name="afcgearl[0]" />
      <Description>        7
        If set, the tolerated AFC frequency error will be halved.
        6
        enafc
        AFC Enable.
        5:3
        afcgearh[2:0]
        AFC High Gear Setting.
        2:0
        afcgearl[2:0]
        AFC Low Gear Setting.
      </Description>
    </Register>
    <Register address="1E" name="AFC Timing Control" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swait_timer[1]" />
      <Bit index="6" name="swait_timer[0]" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="anwait[2]" />
      <Bit index="1" name="anwait[1]" />
      <Bit index="0" name="anwait[0]" />
      <Description>        7:6
        Short Wait RSSI Timer.
        The second phase RSSI waiting timer offset.
        5:3
        shwait[2:0]
        Short Wait Periods after AFC Correction.
        Used before preamble is detected. Short wait = (RegValue + 1)x2Tb. If set to 0 then no AFC correction will occur before preamble detect, i.e. AFC will be disabled.
        2:0
        anwait[2:0]
        Antenna Switching Wait Time.
        Value corresponds to number of bits.
      </Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>
        5:3
        crfast[2:0]
        Clock Recovery Fast Gearshift Value.
        2:0
        crslow[2:0]
        Clock Recovery Slow Gearshift Value.
        The gear-shift register controls BCR loop gain. Before the preamble is detected, BCR loop gain is as follows:
        Once the preamble is detected, internal state machine automatically shift BCR loop gain to the following:
        crfast = 3   b000 and crslow = 3   b101 are recommended for most applications. The value of    crslow    should be greater than    crfast   .
      </Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>
        Oversampling Rate.
        3 LSBs are the fraction, default = 0110 0100 = 12.5 clock cycles per data bit
        The oversampling rate can be calculated as rxosr = 500kHz/(2ndec_expxRX_DR). The ndec_exp and the dwn3_bypass values found at Address: 1Ch     IF Filter Bandwidth register together with the receive data rate (Rb) are the parameters needed to calculate rxosr:
        The Rb unit used in this equation is in kbps. The enmanch is the Manchester Coding parameter (see Reg. 70h, enmach is 1 when Manchester coding is enabled, enmanch is 0 when disabled). The number found in the equation should be rounded to an integer. The integer can be translated to a hexadecimal.
      </Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="stallctrl" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>
        Oversampling Rate.
        Upper bits.
        4
        stallctrl
        Used for BCR Purposes.
        3:0
        ncoff[19:16]
        NCO Offset.
        See formula above.
        The offset can be calculated as follows:
      </Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>
        NCO Offset.
        See formula above
      </Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>
        NCO Offset.
        See formula above
      </Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="rxncocomp" />
      <Bit index="3" name="crgain2x" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>
        4
        rxncocomp
        Receive Compensation Enable for High Data Rate Offset.
        3
        cgainx2
        Multiplying the CR Gain by 2.
        2:0
        crgain[10:8]
        Clock Recovery Timing Loop Gain.
        The loop gain can be calculated as follows:
      </Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>Clock Recovery Timing Loop Gain.</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>Received Signal Strength Indicator Value.</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="1E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>
        RSSI Threshold.
        Interrupt is set if the RSSI value is above this threshold.
      </Description>
    </Register>
    <Register address="28" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>Measured RSSI Value on Antenna 1.</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description>Measured RSSI Value on Antenna 2.</Description>
    </Register>
    <Register address="2A" name="AFC Limiter" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Afclim[7]" />
      <Bit index="6" name="Afclim[6]" />
      <Bit index="5" name="Afclim[5]" />
      <Bit index="4" name="Afclim[4]" />
      <Bit index="3" name="Afclim[3]" />
      <Bit index="2" name="Afclim[2]" />
      <Bit index="1" name="Afclim[1]" />
      <Bit index="0" name="Afclim[0]" />
      <Description>
        AFC Limiter.
        AFC limiter value.
        For the following registers (addresses 2Bh and 2Ch), use the following equation:
        where Rb's unit is in kHz and    enmanch    is the Manchester Enable bit (found at address 71h bit [1]).
      </Description>
    </Register>
    <Register address="2B" name="AFC Correction Read" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[8]" />
      <Bit index="5" name="afc_corr[7]" />
      <Bit index="4" name="afc_corr[6]" />
      <Bit index="3" name="afc_corr[5]" />
      <Bit index="2" name="afc_corr[4]" />
      <Bit index="1" name="afc_corr[3]" />
      <Bit index="0" name="afc_corr[2]" />
      <Description>
        AFC Correction Values.
        AFC loop correction values [9:2] (MSBs only). Values are updated once, after sync word is found during receiving. See also address 2Ch.
      </Description>
    </Register>
    <Register address="2C" name="OOK Counter Value 1" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[9]" />
      <Bit index="5" name="ookfrzen" />
      <Bit index="4" name="peakdeten" />
      <Bit index="3" name="madeten" />
      <Bit index="2" name="ookcnt[10]" />
      <Bit index="1" name="ookcnt[9]" />
      <Bit index="0" name="ookcnt[8]" />
      <Description>        7:6
        AFC Correction Values.
        AFC loop correction values [1:0] (LSBs). Values are updated once, after sync word is found during receiving. See also address 2Bh.
        5
        ookfrzen
        OOK Freeze.
        OOK AGC freeze if this bit is set.
        4
        peakdeten
        Peak Detector Enable.
        Peak detector enable if high.
        3
        madeten
        MA_Enable.
        MA block enable if high.
        2:0
        ookcnt[2:0]
        OOK Counter [10:8].
        OOK counter value MSBs.
      </Description>
    </Register>
    <Register address="2D" name="OOK Counter Value 2" size="8" defaultVal="BC" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ookcnt[7]" />
      <Bit index="6" name="ookcnt[6]" />
      <Bit index="5" name="ookcnt[5]" />
      <Bit index="4" name="ookcnt[4]" />
      <Bit index="3" name="ookcnt[3]" />
      <Bit index="2" name="ookcnt[2]" />
      <Bit index="1" name="ookcnt[1]" />
      <Bit index="0" name="ookcnt[0]" />
      <Description>
        OOK Counter [7:0].
        OOK counter value LSBs.
      </Description>
    </Register>
    <Register address="2E" name="Slicer Peak Hold" size="8" defaultVal="26" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="attack[2]" />
      <Bit index="5" name="attack[1]" />
      <Bit index="4" name="attack[0]" />
      <Bit index="3" name="decay[3]" />
      <Bit index="2" name="decay[2]" />
      <Bit index="1" name="decay[1]" />
      <Bit index="0" name="decay[0]" />
      <Description>
        6:4
        attack[2:0]
        Attack.
        3:0
        decay[3:0]
        Decay.
      </Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="skip2ph" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>        7
        Enable Packet RX Handling.
        If FIFO Mode (dtmod=10) is being used automatic packet handling may be enabled. Setting enpacrx=1 will enable automatic packet handling in the RX path. Register 30   4D allow for various configurations of the packet structure. Setting enpacrx=0 will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
        6
        lsbfrst
        LSB First Enable.
        The LSB of the data will be transmitted/received first if this bit is set.
        5
        crcdonly
        CRC Data Only Enable.
        When this bit is set to 1 the CRC is calculated on and checked against the packet data fields only.
        4
        skip2ph
        Skip 2nd Phase of Preamble Detection.
        If set, we skip the second phase of the preamble detection (under certain conditions) if antenna diversity is enabled.
        3
        enpactx
        Enable Packet TX Handling.
        If FIFO Mode (dtmod=10) is being used automatic packet handling may be enabled. Setting enpactx=1 will enable automatic packet handling in the TX path. Register 30   4D allow for various configurations of the packet structure. Setting enpactx=0 will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
        2
        encrc
        CRC Enable.
        Cyclic Redundancy Check generation is enabled if this bit is set.
        1:0
        crc[1:0]
        CRC Polynomial Selection.
        00:	CCITT
        01:	CRC-16 (IBM)
        10:	IEC-16
        11:	Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="rxcrc1" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>
        6
        rxcrc1
        If high, it indicates the last CRC received is all one   s.
        May indicated Transmitter underflow in case of CRC error.
        5
        pksrch
        Packet Searching.
        When pksrch = 1 the radio is searching for a valid packet.
        4
        pkrx
        Packet Receiving.
        When pkrx = 1 the radio is currently receiving a valid packet.
        3
        pkvalid
        Valid Packet Received.
        When a pkvalid = 1 a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
        2
        crcerror
        CRC Error.
        When crcerror = 1 a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
        1:0
        Reserved
        1
        pktx
        Packet Transmitting.
        When pktx = 1 the radio is currently transmitting a packet.
        0
        pksent
        Packet Sent.
        A pksent = 1 a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcen[3]" />
      <Bit index="6" name="bcen[2]" />
      <Bit index="5" name="bcen[1]" />
      <Bit index="4" name="bcen[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>        7:4
        Broadcast Address (FFh) Check Enable.
        If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
        0000:	No broadcast address enable.
        0001:	Broadcast address enable for header byte 0.
        0010:	Broadcast address enable for header byte 1.
        0011:	Broadcast address enable for header bytes 0 &amp; 1.
        0100:
        3:0
        hdch[3:0]
        Received Header Bytes to be Checked Against the Check Header Bytes.
        One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.
        0000:	No Received Header check
        0001:	Received Header check for byte 0.
        0010:	Received Header check for bytes 1.
        0011:	Received header check for bytes 0 &amp; 1.
        0100:
      </Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        6:4
        hdlen[2:0]
        Header Length.
        Length of header used if packet handler is enabled for TX/RX (enpactx/rx). Headers are transmitted/received in descending order.
        000:	NoTX/RX header
        001: 	Header 3
        010: 	Header 3 and 2
        011: 	Header 3 and 2 and 1
        100: 	Header 3 and 2 and 1 and 0
        3
        fixpklen
        Fix Packet Length.
        When fixpklen = 1 the packet length (pklen[7:0]) is not included in the header. When fixpklen = 0 the packet length is included in the header.
        2:1
        synclen[1:0]
        Synchronization Word Length.
        The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00: 	Synchronization Word 3
        01: 	Synchronization Word 3 and 2
        10: 	Synchronization Word 3 and 2 and 1
        11: 	Synchronization Word 3 and 2 and 1 and 0
        0
        prealen[8]
        MSB of Preamble Length.
        See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>
        Preamble Length.
        The value in the prealen[8:0] register corresponds to the number of nibbles (4 bits) in the packet. For example prealen[8:0] =    000001000    corresponds to a preamble length of 32 bits (8x4bits) or 4 bytes. The maximum preamble length is prealen[8:0] = 111111111 which corresponds to a 255 bytes Preamble. Writing 0 will have the same result as if writing 1, which corresponds to one single nibble of preamble.
      </Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description>        7:3
        Number of nibbles processed during detection.
        2:0
        rssi_offset[2:0]
        rssi_offset[2:0]
        Value added as offset to RSSI calculation. Every increment in this register results in an increment of +4dB in the RSSI.
      </Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>
        Synchronization Word 3.
        4th byte of the synchronization word.
      </Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>
        Synchronization Word 2.
        3rd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>
        Synchronization Word 1.
        2nd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>
        Synchronization Word 0.
        1st byte of the synchronization word.
      </Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>
        Transmit Header 3.
        4th byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>
        Transmit Header 2.
        3rd byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>
        Transmit Header 1.
        2nd byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>
        Transmit Header 0.
        1st byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>
        Packet Length.
        The value in the pklen[7:0] register corresponds directly to the number of bytes in the Packet. For example pklen[7:0] =    00001000    corresponds to a packet length of 8 bytes. The maximum packet length is pklen[7:0] =    11111111   , a 255 byte packet. Writing 0 is possible, in this case we do not send any data in the packet. During RX, if fixpklen = 1, this will specify also the Packet Length for RX mode.
      </Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>
        Check Header 3.
        4th byte of the check header.
      </Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>
        Check Header 2.
        3rd byte of the check header.
      </Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>
        Check Header 1.
        2nd byte of the check header.
      </Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>
        Check Header 0.
        1st byte of the check header.
      </Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>
        Header Enable 3.
        4th byte of the check header.
      </Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>
        Header Enable 2.
        3rd byte of the check header.
      </Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>
        Header Enable 1.
        2nd byte of the check header.
      </Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>
        Header Enable 0.
        1st byte of the check header.
      </Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>
        Received Header 3.
        4th byte of the received header.
      </Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>
        Received Header 2.
        3rd byte of the received header.
      </Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>
        Received Header 1.
        2nd byte of the received header.
      </Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>
        Received Header 0.
        1st byte of the received header.
      </Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>
        Length Byte of the Received Packet during fixpklen = 0.
        (Specifies the number of Data bytes in the last received packet) This will be relevant ONLY if fixpklen (address 33h, bit[3]) is low during the receive time. If fixpklen is high, then the number of received Data Bytes can be read from the pklen register (address h3E).
      </Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description>
        5:0
        adc8[5:0]
        ADC8 Control Bits.
      </Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>
        4:0
        atb[4:0]
        Analog Test Bus.
        The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
        Table 31. Internal Analog Signals Available on the Analog Test Bus
        Addr
        hex
        ATBp
        ATBn
        0
        0
        1
        1
        MixIp
        MixIn
        2
        2
        MixQp
        MixQn
        3
        3
        PGA_Ip
        PGA_In
        4
        4
        PGA_Qp
        PGA_Qn
        5
        5
        vcmout
        vbn
        6
        6
        refmid
        vbiasp
        7
        7
        ADC_vcm
        ADC_vcmb
        8
        8
        ADC_ipoly10
        ADC_ref
        9
        9
        RefADC_p
        RefADC_m
        10
        A
        ADC_Res1Ip
        ADC_Res1In
        11
        B
        ADC_Res1Qp
        ADC_Res1Qn
        12
        C
        ADC_Res2Ip
        ADC_Res2In
        13
        D
        ADC_Res2Qp
        ADC_Res2Qn
        14
        E
        ADC_Res3Ip
        ADC_Res3In
        15
        F
        ADC_Res3Qp
        ADC_Res3Qn
        16
        10
        NC
        NC
        17
        11
        ADC_Cal_Ucap
        ADC_Cal_Ures
        18
        12
        I_CP_test
        PLL_IBG_05
        19
        13
        PLL_VBG
        VSS_VCO
        20
        14
        Vctrl_Test
        PLL_IPTAT_05
        21
        15
        PA_Vbias
        NC
        22
        16
        DIGBG
        DIGVFB
        23
        17
        IFBG
        IFVFB
        24
        18
        PLLBG
        PLLVREG
        25
        19
        IBias_10u
        IBias_5u
        26
        1A
        CLK_65K_Out
        AVSS
        27
        1B
        ADC8_VIN
        ADC8_VDAC
        28
        1C
        LBDcomp
        LBDcompref
        29
        1D
        TSBG
        TSVtemp
        30
        1E
        RFBG
        RFVREG
        31
        1F
        VCOBG
        VCOVREG
      </Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description></Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="DF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldorampen" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>        7
        PA LDO Ramp Enable.
        When this bit is set, the PA LDO ramp will ramp in conjunction with the ramp of the PA bias.  Ramping the LDO will increase modulation depth for OOK. Spectral improvements will occur when not ramping the LDO.
        6:4
        txmod[2:0]
        TX Modulation Delay.
        The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up. It can be set from 0  s to 28   s in 4   s steps. This also works during PA ramp down.
        3:2
        ldoramp[1:0]
        TX LDO Ramp Time.
        The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00:	5   s
        01:	10   s
        10:	15   s
        11:	20   s
        1:0
        txramp[1:0]
        TX Ramp Time.
        The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00: 	5   s
        01: 	10   s
        10: 	15   s
        11: 	20   s
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>        7:3
        PLL Soft Settling Time (TS).
        This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0   s and 310  s, in 10   s intervals. The default plltime corresponds to 100  s. See formula above.
        2:0
        pllt0
        PLL Settling Time (TO).
        This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0   s and 70  s, in 10  s steps. The default pllt0 corresponds to 20  s. See formula above.
      </Description>
    </Register>
    <Register address="54" name="Invalid Preamble Threshold and PA Misc" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="pa_duty[1]" />
      <Bit index="4" name="pa_duty[0]" />
      <Bit index="3" name="ldoramplv[1]" />
      <Bit index="2" name="ldoramplv[0]" />
      <Bit index="1" name="Ido_pa_boost" />
      <Bit index="0" name="pabias_boost" />
      <Description>
        5:4
        pa_duty[1:0]
        PA Duty Cycle Control.
        Shifting the duty cycle of the PA will effect PA efficiency and harmonics.
        3:2
        ldoramplv[1:0]
        PA LDO Ramp Level.
        The starting ramp level of the PA LDO. The ramp level will effect modulation depth and spectral splatter.
        1
        ldo_pa_boost
        LDO PA Boost.
        0
        pa_vbias_boost
        PA VBIAS Boost.
      </Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        6
        xtalstarthalf
        If Set, the Xtal Wake Time Period is Halved.
        5
        adccaldone
        Delta-sigma ADC Calibration Done.Reading this bit gives 1 if the calibration process has been finished.
        4
        enrcfcal
        RC Oscillator Fine Calibration Enable.
        If this bit is set to 1 then the RC oscillator performs fine calibration in every app. 30 s.
        3
        rccal
        RC Calibration Force.
        If setting rccal=1 will automatically perform a forced calibration of the 32kHz RC Oscillator. The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a 0 to 1 will initiate the calibration. This bit is cleared automatically.
        2
        vcocaldp
        VCO Calibration Double Precision Enable.
        When this bit is set to 1 then the VCO calibration measures longer thus calibrates more precisely.
        1
        vcocal
        VCO Calibration Force.
        If in Idle Mode and pllon=1, setting vcocal=1 will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        0
        skipvco
        Skip VCO Calibration.
        Setting skipvco=1 will skip the VCO calibration when going from the Idle state to the TX or RX state.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="oscdeten" />
      <Bit index="3" name="rssimasel" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>        7
        If set, BCR phase compensation will be bypassed.
        6
        slicfbyp
        If set, slicer phase compensation will be bypassed.
        5
        dttype
        Dithering Type.
        If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add   1.
        4
        oscdeten
        If low, the ADC Oscillation Detection mechanism is allowed to work. If set, we disable the function.
        3
        rssimasel
        RSSI Moving Average Select.
        If 1 then the RSSI moving average read back is 8 bits. If 0 then the moving average is set to 4 bits.
        2
        refclksel
        Delta-Sigma Reference Clock Source Selection
        1:	10MHz
        0:	 PLL
        1
        refclkinv
        Delta-Sigma Reference Clock Inversion Enable.
        0
        distogg
        If reset, the discriminator toggling is disabled.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>        7
        Direct Control to Analog.
        6
        fbdiv_rst
        Direct Control to Analog.
        5
        cpforceup
        Charge Pump Force Up.
        4
        cpforcedn
        Charge Pump Force Down.
        3
        cdconly
        Charge Pump DC Offset Only.
        2:0
        cdcurr[2:0]
        Charge Pump DC Current Selection.
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming/Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>        7:6
        Charge Pump Current (Gain Setting).
        Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        5
        cpcorrov
        Charge Pump Correction Override Enable.
        4:0
        cpcorr[4:0]
        Charge Pump Correction Value.
        During read, you read what the Charge Pump sees. If cpcorrov = 1, then the value you write will go to the Charge Pump, and will also be the value you read. By default, cpcorr[4:0] wakes up as all Zeros.
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcorboosten" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>        7
        If this is Set, then vcocorr (reg 5A[5:2]) = 1111 during TX Mode and VCO CAL followed by TX.
        6
        fbdivhc
        Feedback (fractional) Divider High Current Enable (+5  A).
        5:4
        d3trim[1:0]
        Divider 3 Current Trim Value.
        3:2
        d2trim[1:0]
        Divider 2 Current Trim Value.
        1:0
        d1p5trim[1:0]
        Divider 1.5 (div-by-1.5) Current Trim Value.
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcurboosten" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>        7
        If this is Set, then vcocur = 11 during TX Mode and VCO CAL followed by TX.
        6
        vcocorrov
        VCO Current Correction Override.
        5:2
        vcocorr[3:0]
        VCO Current Correction Value.
        1:0
        vcocur[1:0]
        VCO Current Trim Value.
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov/vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>        7
        VCO Calibration Override/Done.
        When vcocalov=0 the internal VCO calibration results may be viewed by reading the vcocal register. When vcocalov=1 the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives 1 if the calibration process has been finished.
        6:0
        vcocal[6:0]
        VCO Calibration Results.
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="0" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>        7
        Enable DSM Dithering.
        If low, dithering is disabled.
        6
        Reserved
        Will read 0.
        5
        enoloop
        Open Loop Mode Enable.
        4
        dsmod
        Delta-Sigma Modulus.
        0: 64000
        1: 65 536
        3:2
        dsorder[1:0]
        Delta-Sigma Order.
        00: 	0 order
        01: 	1st order
        10: 	2nd order
        11: 	Mash 111
        1
        dsrstmode
        Delta-Sigma Reset Mode.
        0
        dsrst
        Delta-Sigma Reset.
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>        7
        Mixer Enable Override.
        6
        enlna
        LNA Enable Override.
        5
        enpga
        PGA Enable Override.
        4
        enpa
        Power Amplifier Enable Override.
        3
        enbf5
        Buffer 5 Enable Override.
        2
        endv32
        Divider 3_2 Enable Override.
        1
        enbf12
        Buffer 1_2 Enable Override.
        0
        enmx2
        Multiplexer 2 Enable Override.
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="40" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>        7
        Delta-Sigma Enable Override.
        6
        Reserved
        5
        enmx3
        Multiplexer 3 Enable Override.
        4
        enbf4
        Buffer 4 Enable Override.
        3
        enbf3
        Buffer 3 Enable Override.
        2
        enbf11
        Buffer 1_1 Enable Override.
        1
        enbf2
        Buffer 2 Enable Override.
        0
        pllreset
        PLL Reset Enable Override.
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>        7
        Fractional Divider Enable Override.
        6
        endv31
        Divider 3_1 Enable Override.
        5
        endv2
        Divider 2 Enable Override.
        4
        endv1p5
        Divider 1.5 (div-by-1.5) Enable Override.
        3
        dvbshunt
        VCO Bias Shunt Enable Override Mode.
        2
        envco
        VCO Enable Override.
        1
        encp
        Charge Pump Enable Override.
        0
        enbg
        Bandgap Enable Override.
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="50" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>
        3:0
        chfiladd[3:0]
        Channel Filter Coefficient Look-up Table Address.
        The address for channel filter coefficients used in the RX path.
      </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>
        5:0
        chfilval[5:0]
        Filter Coefficient Value in the Look-up Table Addressed by the chfiladd[3:0].
      </Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="24" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>        7:5
        Internal Power States of the Chip.
        LP:	000
        RDY:	001
        Tune:	011
        TX:	010
        RX:	111
        4
        clkhyst
        Clock Hysteresis Setting.
        3
        enbias2x
        2 Times Higher Bias Current Enable.
        2
        enamp2x
        2 Times Higher Amplification Enable.
        1
        bufovr
        Output Buffer Enable Override.
        If set to 1 then the enbuf bit controls the output buffer.
        0: output buffer is controlled by the state machine.
        1: output buffer is controlled by the enbuf bit.
        0
        enbuf
        Output Buffer Enable.
        This bit is active only if the bufovr bit is set to 1.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>        7
        RC Oscillator Coarse Calibration Override.
        When rccov=0 the internal Coarse Calibration results may be viewed by reading the rcccal register. When rccov=1 the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        6:0
        rcc[6:0]
        RC Oscillator Coarse Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>        7
        RC Oscillator Fine Calibration Override.
        When rcfov=0 the internal Fine Calibration results may be viewed by reading the rcfcal register. When rcfov=1 the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        6:0
        rcf[6:0]
        RC Oscillator Fine Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>
        Smart POR Enable.
        6
        enbias
        Bias Enable.
        5
        envcoldo
        VCO LDO Enable.
        4
        enifldo
        IF LDO Enable.
        3
        enrfldo
        RF LDO Enable.
        2
        enpllldo
        PLL LDO Enable.
        1
        endigldo
        Digital LDO Enable.
        0
        endigpwdn
        Digital Power Domain Powerdown Enable in Idle Mode.
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>        7
        Enable Overrides.
        If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks.
        6
        enxtal
        Xtal Override Enable Value.
        5
        ents
        Temperature Sensor Enable.
        4
        enrc32
        32K Oscillator Enable.
        3
        2:0
        diglvl
        Digital LDO Level Setting.
      </Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="1F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>        7
        Delta-Sigma ADC Reset.
        Active low.
        6
        enrefdac
        Delta-Sigma ADC Reference DAC Enable Override.
        5
        enadc
        Delta-Sigma ADC Enable Override.
        4
        adctuneovr
        Resonator RC Calibration Value Override Enable.
        3:0
        adctune[3:0]
        Resonator RC Calibration Value.
      </Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>
        4
        envcm
        Delta-Sigma ADC VCM Enable Override.
        3
        adcoloop
        Delta-Sigma ADC Open Loop Enable.
        2:0
        adcref[2:0]
        Delta-Sigma ADC Reference Voltage.
        000:	0.5 V
        001:	0.6 V
        010:	0.7 V

        111:	1.2 V
      </Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sgi" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>
        6
        SGI
        Stop Increasing Gain for AGC Loop.
        Default = 0.
        5
        agcen
        Automatic Gain Control Enable.
        When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
        4
        lnagain
        LNA Gain Select.
        0     min. gain = 5 dB	1    max. gain = 25 dB
        3:0
        pga[3:0]
        PGA Gain Override Value.
        000:	0 dB
        001:	3 dB
        010:	6 dB
        ...
        101:	24 dB max.
      </Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="1D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="agcovpm" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>        7
        If set, AGC will ignore the Preamble Detection.
        6
        agcslow
        AGC Slow Gain Increase Enable.
        When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
        5:2
        lnacomp[3:0]
        LNA Gain Compensation.
        This bit is used for smoothing RSSI value when LNA gain is switched.
        1:0
        pgath[1:0]
        Window Comparator Reference Voltage Adjust in the PGA.
      </Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        2:0
        firadd[2:0]
        GFSK FIR Filter Coefficient Look-up Table Address.
        The address for Gaussian filter coefficients used in the TX path. The default GFSK setting is for BT=0.5. It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000: 	i_coe0 (Default =d1)
        001: 	i_coe1 (Default =d3)
        010: 	i_coe2 (Default =d6)
        011: 	i_coe3 (Default =d10)
        100: 	i_coe4 (Default =d15)
        101: 	i_coe5 (Default =d19)
        110: 	i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>
        5:0
        firval[5:0]
        FIR Coefficient Value in the lOok-up Table Addressed by the firadd[2:0].
        The default coefficient can be read or modified.
      </Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="papeakval" />
      <Bit index="6" name="papeaken" />
      <Bit index="5" name="papeaklvl[1]" />
      <Bit index="4" name="papeaklvl[0]" />
      <Bit index="3" name="Ina_sw" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>        7
        papeakval
        PA Peak Detector Value, Read only
Reading a 1 in this register when the papeaken=1 then the PA drain voltage is too high and the match network needs adjusting for optimal efficiency.
        6
        papeaken
        PA Peak Detector Enable.
        5:4
        papeaklvl[0]
        PA Peak Detect Level (direct from register).
        00=6.5
        01=7
        10=7.5
        11=8
        00 = default
        3
        lna_sw
        LNA Switch Controller.
        If set, lna_sw control from the digital will go high during TX modes, and low during other times. If reset, the digital control signal is low at all times.
        2:0
        txpow[2:0]
        TX Output Power.
        The output power is configurable from    8dBm to +13dBm in ~3dBm steps. txpow[2:0]=111 corresponds to +13dBm and 000 to    8dBm.
      </Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>
        Data Rate Upper Byte.
        See formula above.
        The data rate can be calculated as: TX_DR=103xtxdr[15:0] / 216 [kbps] (if address 70[5]=0) or
      </Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="3D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>
        Data Rate Lower Byte.
        See formula above. Defaults = 40kbps.
      </Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txdtrtscale" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        5
        txdtrtscale
        This bit should be set for Data Rates below 30kbps.
        4
        enphpwdn
        If set, the Packet Handler will be powered down when chip is in low power mode.
        3
        manppol
        Manchester Preamble Polarity (will transmit a series of 1 if set, or series of 0 if reset).
        This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester Mode is enabled.
        2
        enmaninv
        Manchester Data Inversion is Enabled if this bit is set.
        1
        enmanch
        Manchester Coding is Enabled if this bit is set.
        0
        enwhite
        Data Whitening is Enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>        7:6
        TX Data Clock Configuration.
        00:	No TX Data CLK is available (asynchronous mode     Can only work with modulations FSK or OOK).
        01:	TX Data CLK is available via the GPIO (one of the GPIO   s should be programmed as well).
        10:	TX Data CLK is available via the SDO pin.
        11:	TX Data CLK is available via the nIRQ pin.
        5:4
        dtmod[1:0]
        Modulation Source.
        00: 	Direct Mode using TX_Data function via the GPIO pin 	(one of the GPIO   s should be programmed accordingly as well)
        01: 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10: 	FIFO Mode
        11: 	PN9 (internally generated)
        3
        eninv
        Invert TX and RX Data.
        2
        fd[8]
        MSB of Frequency Deviation Setting, see"Register 72h. Frequency Deviation".
        1:0
        modtyp[1:0]
        Modulation Type.
        00:	Unmodulated carrier
        01:	OOK
        10:	FSK
        11:	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>
        Frequency Deviation Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>
        Frequency Offset Setting.
        The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value. Reading from this register will give the AFC correction last results, not this register value.
      </Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>
        1:0
        fo[9:8]
        Upper Bits of the Frequency Offset Setting.
        fo[9] is the sign bit. The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value. Reading from this register will give the AFC correction last results, not this register value.
      </Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        6
        sbsel
        Side Band Select.
        5
        hbsel
        High Band Select.
        Setting hbsel = 1 will choose the frequency range from 480   960MHz (high bands). Setting hbsel = 0 will choose the frequency range from 240   479.9MHz (low bands).
        4:0
        fb[4:0]
        Frequency Band Select.
        Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands. Setting fb[4:0]=00000 corresponds to the 240   250MHz Band for hbsel=0 and the 480   500MHz Band for hbsel=1. Setting fb[4:0]=00001 corresponds to the 250   260MHz Band for hbsel=0 and the 500   520MHz Band for hbsel=1.
        The RF carrier frequency can be calculated as follows:
        fcarrier = (fb+24+(fc+fo) / 64000)x10000x(hbsel+1) + (fhchxfhsx10) [kHz],
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>
        Nominal Carrier Frequency Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>
        Nominal Carrier Frequency Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="78" name="Miscellaneous Settings" size="8" defaultVal="19" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="ifsw_en" />
      <Bit index="3" name="Alt_PA_Seq" />
      <Bit index="2" name="rcosc[2]" />
      <Bit index="1" name="rcosc[1]" />
      <Bit index="0" name="rcosc[0]" />
      <Description>
        4
        ifsw_en
        Enable for IF SW between PA and IF.
        3
        alt_pa_seq
        Alternative PA sequencing.
        If set, we will enable the alternative PA sequence. By default, this is not enabled.
        2:0
        rcosc_cal[2:0]
        rcosc_cal[2:0].
        Fine changes on the RC OSC Calibration target frequency, to help compensate for    calibration biases.    This register should not be changed by costumers.
      </Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>Frequency Hopping Channel Number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>
        Frequency Hopping Step Size in 10kHz Increments.
        See formula for the nominal carrier frequency at"Register 76h. Nominal Carrier Frequency".
      </Description>
    </Register>
    <Register address="7B" name="Turn Around and 15.4 Length Compliance" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="15.4 Length" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="turn_around_en" />
      <Bit index="1" name="Phase[1]" />
      <Bit index="0" name="Phase[0]" />
      <Description>        7
        15.4 Packet Length Compliance.
        If set, then PK Length definition for both TX and RX will also include the CRC bytes, If reset, then the Length refers ONLY to the DATA payload. For example, writing    9    to this register when it is set, means we are sending/expecting    7    bytes of DATA, and the other    2    should be the CRC (CRC should be enabled separately).
        6:3
        Reserved
        2
        turn_around_en
        Turn Around Enable.
        Enabling for the turn around functionality.
        1:0
        phase[1:0]
        Turn Around Phase.
        The RX to TX and vice-versa change in frequency will happen (if bit [2] is set) at the last byte, and these two registers set the bit position in which the frequency shifts should occur. Make sure it does not happen to early otherwise the last bits will be missed.
      </Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>
        5:0
        txafthr[5:0]
        TX FIFO Almost Full Threshold.
      </Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>
        5:0
        txfaethr[5:0]
        TX FIFO Almost Empty Threshold.
      </Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>
        5:0
        rxafthr[5:0]
        RX FIFO Almost Full Threshold.
      </Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        FIFO Data.
        A Write (R/W=1) to this Address will begin a Burst Write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented. To conclude the TX FIFO Write the SEL pin should be brought HIGH. A Read (R/W=0) to this address will begin a burst read of the RX FIFO, in the same manner.
      </Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="21" type="Si4030" revision="B1" projectID="0" name="Ara 4030-31-32_B1">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        4:0
        dt[4:0]
        Device Type Code.
        EZRadioPRO: 01000.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="06" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>
        4:0
        vc[4:0]
        Version Code.
        Code indicating the version of the chip.
        Rev A0: 00100
        Rev V2: 00011
      </Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>
        7
        TX FIFO Overflow Status.
        6
        ffunfl
        TX FIFO Underflow Status.
        5:2
        Reserved
        1:0
        cps[1:0]
        Chip Power State.
        00:	Idle State
        10:	TX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="Reserved" />
      <Bit index="0" name="Reserved" />
      <Description>
        7
        FIFO Underflow/Overflow Error.
        When set to 1 the TX FIFO has overflowed or underflowed.
        6
        itxffafull
        TX FIFO Almost Full.
        When set to 1 the TX FIFO has met its almost full threshold and needs to be transmitted.
        5
        itxffaem
        TX FIFO Almost Empty.
        When set to 1 the TX FIFO is almost empty and needs to be filled.
        4
        Reserved
        3
        iext
        External Interrupt.
        When set to 1 an interrupt occurred on one of the GPIO   s if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        2
        ipksent
        Packet Sent Interrupt.
        When set to1 a valid packet has been transmitted.
        1:0
        Reserved
        0
        icrcerror
        CRC Error.
        When set to 1 the cyclic redundancy check is failed.
        When any of the Interrupt/Status 1 bits change state from 0 to 1 the device will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 1 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 1 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        7
        Reserved
        6
        Reserved
        5
        Reserved
        4
        Reserved
        3
        iwut
        Wake-Up-Timer.
        On the expiration of programmed wake-up timer this bit will be set to 1.
        2
        ilbd
        Low Battery Detect.
        When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        1
        ichiprdy
        Chip Ready (XTAL).
        When a chip ready event has been detected this bit will be set to 1.
        0
        ipor
        Power-on-Reset (POR).
        When the chip detects a Power on Reset above the desired setting this bit will be set to 1.
        When any of the Interrupt/Status Register 2 bits change state from 0 to 1 the control block will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 2 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 2 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="Reserved"></Bit>
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="Reserved" />
      <Bit index="0" name="Reserved" />
      <Description>
        7
        Enable FIFO Underflow/Overflow.
        When set to 1 the FIFO Underflow/Overflow interrupt will be enabled.
        6
        entxffafull
        Enable TX FIFO Almost Full.
        When set to 1 the TX FIFO Almost Full interrupt will be enabled.
        5
        entxffaem
        Enable TX FIFO Almost Empty.
        When set to 1 the TX FIFO Almost Empty interrupt will be enabled.
        4
        Reserved
        3
        enext
        Enable External Interrupt.
        When set to 1 the External Interrupt will be enabled.
        2
        enpksent
        Enable Packet Sent.
        When ipksent =1 the Packet Sense Interrupt will be enabled.
        1:0
        Reserved
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        7:4
        Reserved
        3
        enwut
        Enable Wake-Up Timer.
        When set to 1 the Wake-Up Timer interrupt will be enabled.
        2
        enlbd
        Enable Low Battery Detect.
        When set to 1 the Low Battery Detect interrupt will be enabled.
        1
        enchiprdy
        Enable Chip Ready (XTAL).
        When set to 1 the Chip Ready interrupt will be enabled.
        0
        enpor
        Enable POR.
        When set to 1 the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        Software Register Reset Bit.
        This bit may be used to reset all registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register. The RESET is accomplished by setting swres = 1. This bit will be automatically cleared.
        6
        enlbd
        Enable Low Battery Detect.
        When this bit is set to 1 the Low Battery Detector circuit and threshold comparison will be enabled.
        5
        enwt
        Enable Wake-Up-Timer.
        Enabled when enwt = 1. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        4
        x32ksel
        32,768 kHz Crystal Oscillator Select.
        0:	RC oscillator
        1:	32kHz crystal
        3
        txon
        TX on in Manual Transmit Mode.
        Automatically cleared in FIFO mode once the packet is sent. Transmission can be aborted during packet transmission, however, when no data has been sent yet, transmission can only be aborted after the device is programmed to    unmodulated carrier    ("Register 71h. Modulation Mode Control 2").
        2
        Reserved
        1
        pllon
        TUNE Mode (PLL is ON).
        When pllon = 1 the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        0
        xton
        READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="Reserved" />
      <Bit index="0" name="ffclrtx" />
      <Description>
        7:4
        Reserved
        3
        autotx
        Automatic Transmission.
        When autotx = 1 the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.
        2:1
        Reserved
        0
        ffclrtx
        TX FIFO Reset/Clear.
        This has to be a two writes operation: Setting ffclrtx=1 followed by ffclrtx= 0 will clear the contents of the TX FIFO.
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>
        Additional capacitance to course shift the frequency if xlc[6:0] is not sufficient. Not binary with xlc[6:0].
        6:0
        xlc[6:0]
        Tuning Capacitance for the 30MHz XTAL.
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        5:4
        clkt[1:0]
        Clock Tail.
        If enlfc = 0 then it can be useful to provide a few extra cycles for the microcontroller to complete its operation. Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00: 	0 cycle
        01: 	128 cycles
        10: 	256 cycles
        11: 	512 cycles
        3
        enlfc
        Enable Low Frequency Clock.
        When enlfc = 1 and the chip is in Sleep mode then the 32.768kHz clock will be provided to the microcontroller no matter what the selection of mclk[2:0] is. For example if mclk[2:0] =    000   , 30MHz will be available through the GPIO to output to the microcontroller in all Idle or TX states. When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        2:0
        mclk[2:0]
        Microcontroller Clock.
        Different clock frequencies may be selected for configurable GPIO clock output. All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator. The mclk[2:0] setting is only valid when xton = 1 except the 111.
        000: 	30 MHz
        001: 	15 MHz
        010: 	10 MHz
        011: 	4 MHz
        100: 	3 MHz
        101: 	2 MHz
        110: 	1 MHz
        111:	32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        7:6
        GPIO Driving Capability Setting.
        5
        pup0
        Pullup Resistor Enable on GPIO0.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio0[4:0]
        GPIO0 pin Function Select.
        00000: 	Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        7:6
        GPIO Driving Capability Setting.
        5
        pup1
        Pullup Resistor Enable on GPIO1.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio1[4:0]
        GPIO1 pin Function Select.
        00000: 	Inverted Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        7:6
        GPIO Driving Capability Setting.
        5
        pup2
        Pullup Resistor Enable on GPIO2.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio2[4:0]
        GPIO2 pin Function Select.
        00000: 	Microcontroller Clock
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX Data CLK output to be used in conjunction with TX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        6
        extitst[2]
        External Interrupt Status.
        If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        5
        extitst[1]
        External Interrupt Status.
        If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        4
        extitst[0]
        External Interrupt Status.
        If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        3
        itsdo
        Interrupt Request Output on the SDO Pin.
        nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        2
        dio2
        Direct I/O for GPIO2.
        If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        1
        dio1
        Direct I/O for GPIO1.
        If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        0
        dio0
        Direct I/O for GPIO0.
        If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart/adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        7
        ADC Measurement Start Bit.
        Reading this bit gives 1 if the ADC measurement cycle has been finished.
        6:4
        adcsel[2:0]
        ADC Input Source Selection.
        The internal 8-bit ADC input source can be selected as follows:
        000:	Internal Temperature Sensor
        001:	GPIO0, single-ended
        010:	GPIO1, single-ended
        011: 	GPIO2, single-ended
        100:	GPIO0(+)     GPIO1(   ), differential
        101:	GPIO1(+)     GPIO2(   ), differential
        110:	GPIO0(+)     GPIO2(   ), differential
        111:	GND
        3:2
        adcref[1:0]
        ADC Reference Voltage Selection.
        The reference voltage of the internal 8-bit ADC can be selected as follows:
        0X:	bandgap voltage (1.2V)
        10:	VDD / 3
        11: 	VDD / 2
        1:0
        adcgain[1:0]
        ADC Sensor Amplifier Gain Selection.
        The full scale range of the internal 8-bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0:	adcref[0] = 1:
        FS = 0.014 x (adcgain[1:0] + 1) x VDD 	FS = 0.021 x (adcgain[1:0] + 1) x VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>
        3:0
        adcoffs[3:0]
        ADC Sensor Amplifier Offset*.
        *Note:	 The offset can be calculated as Offset = adcoffs[2:0] x VDD / 1000; MSB = adcoffs[3] = Sign bit.
      </Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>
        7:6
        Temperature Sensor Range Selection.
        (FS range is 0..1024mV)
        00:	   40uoC .. 64uoC (full operating range), with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        01:	   40uoC .. 85uoC, with 1uoC resolution (1 LSB in the 8-bit ADC)
        11:	   0uoC .. 85uoC, with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        10:	   40uoF .. 216uoF, with 1uoF resolution (1 LSB in the 8-bit ADC)
        5
        entsoffs
        Temperature Sensor Offset to Convert from K to   C.
        4
        entstrim
        Temperature Sensor Trim Enable.
        3:0
        tstrim[3:0]
        Temperature Sensor Trim Value.
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>
        Temperature Value Offset.
        This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)
        Note:	If a new configuration is needed (e.g., for the WUT or the LDC), proper functionality is required. The function must first be disabled, then the settings changed, then enabled back on.
      </Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description>
        4:0
        wtr[4:0]
        Wake Up Timer Exponent (R) Value*.
        Maximum value for R is decimal 20. A value greater than 20 will yield a result as if 20 were written. R Value = 0 can be written here.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms. R=0 is allowed, and the maximum value for R is decimal 20. A value greater than 20 will result in the same as if 20 was written.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        M[7:0] = 0 is not valid here. Write at least decimal 1.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description></Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>
        4:0
        lbdt[4:0]
        Low Battery Detector Threshold.
        This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2.7V.*
        *Note:	 The threshold can be calculated as Vthreshold = 1.7+lbdtx50mV.
      </Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        4:0
        vbat[4:0]
        Battery Voltage Level.
        The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continuously.
      </Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        6
        lsbfrst
        LSB First Enable.
        The LSB of the data will be transmitted first if this bit is set.
        5
        crcdonly
        CRC Data Only Enable.
        When this bit is set to 1 the CRC is calculated on the packet data fields only.
        4
        Reserved
        3
        enpactx
        Enable Packet TX Handling.
        If FIFO Mode (dtmod=10) is being used automatic packet handling may be enabled. Setting enpactx=1 will enable automatic packet handling in the TX path. Register 30   4D allow for various configurations of the packet structure. Setting enpactx=0 will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
        2
        encrc
        CRC Enable.
        Cyclic Redundancy Check generation is enabled if this bit is set.
        1:0
        crc[1:0]
        CRC Polynomial Selection.
        00:	CCITT
        01:	CRC-16 (IBM)
        10:	IEC-16
        11:	Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>
        7:2
        Reserved
        1:0
        Reserved
        1
        pktx
        Packet Transmitting.
        When pktx = 1 the radio is currently transmitting a packet.
        0
        pksent
        Packet Sent.
        A pksent = 1 a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcen[3]" />
      <Bit index="6" name="bcen[2]" />
      <Bit index="5" name="bcen[1]" />
      <Bit index="4" name="bcen[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description></Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        6:4
        hdlen[2:0]
        Header Length.
        Length of header used if packet handler is enabled for TX (enpactx). Headers are transmitted in descending order.
        000:	No TX header
        001: 	Header 3
        010: 	Header 3 and 2
        011: 	Header 3 and 2 and 1
        100: 	Header 3 and 2 and 1 and 0
        3
        fixpklen
        Fix Packet Length.
        When fixpklen = 1 the packet length (pklen[7:0]) is not included in the header. When fixpklen = 0 the packet length is included in the header.
        2:1
        synclen[1:0]
        Synchronization Word Length.
        The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00: 	Synchronization Word 3
        01: 	Synchronization Word 3 and 2
        10: 	Synchronization Word 3 and 2 and 1
        11: 	Synchronization Word 3 and 2 and 1 and 0
        0
        prealen[8]
        MSB of Preamble Length.
        See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>
        Preamble Length.
        The value in the prealen[8:0] register corresponds to the number of nibbles (4 bits) in the packet. For example prealen[8:0] =    000001000    corresponds to a preamble length of 32 bits (8x4bits) or 4 bytes. The maximum preamble length is prealen[8:0] = 111111111 which corresponds to a 255 bytes Preamble. Writing 0 will have the same result as if writing 1, which corresponds to one single nibble of preamble.
      </Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description></Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>
        Synchronization Word 3.
        4th byte of the synchronization word.
      </Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>
        Synchronization Word 2.
        3rd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>
        Synchronization Word 1.
        2nd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>
        Synchronization Word 0.
        1st byte of the synchronization word.
      </Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>
        Transmit Header 3.
        4th byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>
        Transmit Header 2.
        3rd byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>
        Transmit Header 1.
        2nd byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>
        Transmit Header 0.
        1st byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>
        Packet Length.
        The value in the pklen[7:0] register corresponds directly to the number of bytes in the Packet. For example pklen[7:0] =    00001000    corresponds to a packet length of 8 bytes. The maximum packet length is pklen[7:0] =    11111111   , a 255 byte packet. Writing 0 is possible, in this case we do not send any data in the packet.
      </Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description></Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description></Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description></Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description></Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description></Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description></Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description></Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="DF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldorampen" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>
        7
        PA LDO Ramp Enable.
        When this bit is set, the PA LDO ramp will ramp in conjunction with the ramp of the PA bias. Ramping the LDO will increase modulation depth for OOK. Spectral improvements will occur when not ramping the LDO.
        6:4
        txmod[2:0]
        TX Modulation Delay.
        The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up. It can be set from 0  s to 28   s in 4   s steps. This also works during PA ramp down.
        3:2
        ldoramp[1:0]
        TX LDO Ramp Time.
        The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00:	5   s
        01:	10   s
        10:	15   s
        11:	20   s
        1:0
        txramp[1:0]
        TX Ramp Time.
        The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00: 	5   s
        01: 	10   s
        10: 	15   s
        11: 	20   s
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>
        7:3
        PLL Soft Settling Time (TS).
        This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0   s and 310  s, in 10   s intervals. The default plltime corresponds to 100  s. See formula above.
        2:0
        pllt0
        PLL Settling Time (TO).
        This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0   s and 70  s, in 10  s steps. The default pllt0 corresponds to 20  s. See formula above.
      </Description>
    </Register>
    <Register address="54" name="Invalid Preamble Threshold and PA Misc" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="pa_duty[1]" />
      <Bit index="4" name="pa_duty[0]" />
      <Bit index="3" name="ldoramplv[1]" />
      <Bit index="2" name="ldoramplv[0]" />
      <Bit index="1" name="Ido_pa_boost" />
      <Bit index="0" name="pabias_boost" />
      <Description>
        5:4
        pa_duty[1:0]
        PA Duty Cycle Control.
        Shifting the duty cycle of the PA will effect PA efficiency and harmonics.
        3:2
        ldoramplv[1:0]
        PA LDO Ramp Level.
        The starting ramp level of the PA LDO. The ramp level will effect modulation depth and spectral splatter.
        1
        ldo_pa_boost
        LDO PA Boost.
        0
        pa_vbias_boost
        PA VBIAS Boost.
      </Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        6
        xtalstarthalf
        If Set, the Xtal Wake Time Period is Halved.
        5
        Reserved
        4
        enrcfcal
        RC Oscillator Fine Calibration Enable.
        If this bit is set to 1 then the RC oscillator performs fine calibration in every app. 30 s.
        3
        rccal
        RC Calibration Force.
        If setting rccal=1 will automatically perform a forced calibration of the 32kHz RC Oscillator. The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a 0 to 1 will initiate the calibration. This bit is cleared automatically.
        2
        vcocaldp
        VCO Calibration Double Precision Enable.
        When this bit is set to 1 then the VCO calibration measures longer thus calibrates more precisely.
        1
        vcocal
        VCO Calibration Force.
        If in Idle Mode and pllon=1, setting vcocal=1 will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        0
        skipvco
        Skip VCO Calibration.
        Setting skipvco=1 will skip the VCO calibration when going from the Idle state to the TX state.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="oscdeten" />
      <Bit index="3" name="rssimasel" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>
        7
        If set, BCR phase compensation will be bypassed.
        6
        slicfbyp
        If set, slicer phase compensation will be bypassed.
        5
        dttype
        Dithering Type.
        If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add   1.
        4
        oscdeten
        If low, the ADC Oscillation Detection mechanism is allowed to work. If set, we disable the function.
        3
        rssimasel
        RSSI Moving Average Select.
        If 1 then the RSSI moving average read back is 8 bits. If 0 then the moving average is set to 4 bits.
        2
        refclksel
        Delta-Sigma Reference Clock Source Selection
        1:	10MHz
        0:	 PLL
        1
        refclkinv
        Delta-Sigma Reference Clock Inversion Enable.
        0
        distogg
        If reset, the discriminator toggling is disabled.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>
        7
        Direct Control to Analog.
        6
        fbdiv_rst
        Direct Control to Analog.
        5
        cpforceup
        Charge Pump Force Up.
        4
        cpforcedn
        Charge Pump Force Down.
        3
        cdconly
        Charge Pump DC Offset Only.
        2:0
        cdcurr[2:0]
        Charge Pump DC Current Selection.
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming/Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>
        7:6
        Charge Pump Current (Gain Setting).
        Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        5
        cpcorrov
        Charge Pump Correction Override Enable.
        4:0
        cpcorr[4:0]
        Charge Pump Correction Value.
        During read, you read what the Charge Pump sees. If cpcorrov = 1, then the value you write will go to the Charge Pump, and will also be the value you read. By default, cpcorr[4:0] wakes up as all Zeros.
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcorboosten" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        7
        If this is Set, then vcocorr (reg 5A[5:2]) = 1111 during TX Mode and VCO CAL followed by TX.
        6
        fbdivhc
        Feedback (fractional) Divider High Current Enable (+5  A).
        5:4
        d3trim[1:0]
        Divider 3 Current Trim Value.
        3:2
        d2trim[1:0]
        Divider 2 Current Trim Value.
        1:0
        d1p5trim[1:0]
        Divider 1.5 (div-by-1.5) Current Trim Value.
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcurboosten" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        7
        If this is Set, then vcocur = 11 during TX Mode and VCO CAL followed by TX.
        6
        vcocorrov
        VCO Current Correction Override.
        5:2
        vcocorr[3:0]
        VCO Current Correction Value.
        1:0
        vcocur[1:0]
        VCO Current Trim Value.
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov/vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>
        7
        VCO Calibration Override/Done.
        When vcocalov=0 the internal VCO calibration results may be viewed by reading the vcocal register. When vcocalov=1 the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives 1 if the calibration process has been finished.
        6:0
        vcocal[6:0]
        VCO Calibration Results.
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="0" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>
        7
        Enable DSM Dithering.
        If low, dithering is disabled.
        6
        Reserved
        Will read 0.
        5
        enoloop
        Open Loop Mode Enable.
        4
        dsmod
        Delta-Sigma Modulus.
        0: 64 000
        1: 65 536
        3:2
        dsorder[1:0]
        Delta-Sigma Order.
        00: 	0 order
        01: 	1st order
        10: 	2nd order
        11: 	Mash 111
        1
        dsrstmode
        Delta-Sigma Reset Mode.
        0
        dsrst
        Delta-Sigma Reset.
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>
        7
        Mixer Enable Override.
        6
        enlna
        LNA Enable Override.
        5
        enpga
        PGA Enable Override.
        4
        enpa
        Power Amplifier Enable Override.
        3
        enbf5
        Buffer 5 Enable Override.
        2
        endv32
        Divider 3_2 Enable Override.
        1
        enbf12
        Buffer 1_2 Enable Override.
        0
        enmx2
        Multiplexer 2 Enable Override.
      </Description>
    </Register>
    <Register address="5E" name=" Block Enable Override 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>
        7
        Delta-Sigma Enable Override.
        6
        Reserved
        5
        enmx3
        Multiplexer 3 Enable Override.
        4
        enbf4
        Buffer 4 Enable Override.
        3
        enbf3
        Buffer 3 Enable Override.
        2
        enbf11
        Buffer 1_1 Enable Override.
        1
        enbf2
        Buffer 2 Enable Override.
        0
        pllreset
        PLL Reset Enable Override.
      </Description>
    </Register>
    <Register address="5F" name=" Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>
        7
        Fractional Divider Enable Override.
        6
        endv31
        Divider 3_1 Enable Override.
        5
        endv2
        Divider 2 Enable Override.
        4
        endv1p5
        Divider 1.5 (div-by-1.5) Enable Override.
        3
        dvbshunt
        VCO Bias Shunt Enable Override Mode.
        2
        envco
        VCO Enable Override.
        1
        encp
        Charge Pump Enable Override.
        0
        enbg
        Bandgap Enable Override.
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="50" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description></Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description></Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        7:5
        Internal Power States of the Chip.
        LP:	000
        RDY:	001
        Tune:	011
        TX:	010
        4
        clkhyst
        Clock Hysteresis Setting.
        3
        enbias2x
        2 Times Higher Bias Current Enable.
        2
        enamp2x
        2 Times Higher Amplification Enable.
        1
        bufovr
        Output Buffer Enable Override.
        If set to 1 then the enbuf bit controls the output buffer.
        0: output buffer is controlled by the state machine.
        1: output buffer is controlled by the enbuf bit.
        0
        enbuf
        Output Buffer Enable.
        This bit is active only if the bufovr bit is set to 1.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>
        7
        RC Oscillator Coarse Calibration Override.
        When rccov=0 the internal Coarse Calibration results may be viewed by reading the rcccal register. When rccov=1 the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        6:0
        rcc[6:0]
        RC Oscillator Coarse Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>
        7
        RC Oscillator Fine Calibration Override.
        When rcfov=0 the internal Fine Calibration results may be viewed by reading the rcfcal register. When rcfov=1 the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        6:0
        rcf[6:0]
        RC Oscillator Fine Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>
        7
        Smart POR Enable.
        6
        enbias
        Bias Enable.
        5
        envcoldo
        VCO LDO Enable.
        4
        enifldo
        IF LDO Enable.
        3
        enrfldo
        RF LDO Enable.
        2
        enpllldo
        PLL LDO Enable.
        1
        endigldo
        Digital LDO Enable.
        0
        endigpwdn
        Digital Power Domain Powerdown Enable in Idle Mode.
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>
        7
        Enable Overrides.
        If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks.
        6
        enxtal
        Xtal Override Enable Value.
        5
        ents
        Temperature Sensor Enable.
        4
        enrc32
        32K Oscillator Enable.
        3
        Reserved
        2:0
        diglvl
        Digital LDO Level Setting.
      </Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        2:0
        firadd[2:0]
        GFSK FIR Filter Coefficient Look-up Table Address.
        The address for Gaussian filter coefficients used in the TX path. The default GFSK setting is for BT=0.5. It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000: 	i_coe0 (Default =d1)
        001: 	i_coe1 (Default =d3)
        010: 	i_coe2 (Default =d6)
        011: 	i_coe3 (Default =d10)
        100: 	i_coe4 (Default =d15)
        101: 	i_coe5 (Default =d19)
        110: 	i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>
        5:0
        firval[5:0]
        FIR Coefficient Value in the lOok-up Table Addressed by the firadd[2:0].
        The default coefficient can be read or modified.
      </Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="papeakval" />
      <Bit index="6" name="papeaken" />
      <Bit index="5" name="papeaklvl[1]" />
      <Bit index="4" name="papeaklvl[0]" />
      <Bit index="3" name="Ina_sw" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>
        6
        papeaken
        PA Peak Detector Value Read Register.
        Reading a 1 in this register when the papeaken=1 then the PA drain voltage is too high and the match network needs adjusting for optimal efficiency.
        5
        papeaklvl[1]
        PA Peak Detector Enable.
        4
        papeaklvl[0]
        PA Peak Detect Level (direct from register).
        00=6.5
        01=7
        10=7.5
        11=8
        00 = default
        3
        lna_sw
        LNA Switch Controller.
        If set, lna_sw control from the digital will go high during TX modes, and low during other times. If reset, the digital control signal is low at all times.
        2:0
        txpow[2:0]
        TX Output Power.
        The output power is configurable from    8dBm to +13dBm in ~3dBm steps. txpow[2:0]=111 corresponds to +13dBm and 000 to    8dBm.
      </Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>
        Data Rate Upper Byte.
        The data rate can be calculated as: TX_DR=103xtxdr[15:0] / 216 [kbps] (if address 70[5]=0) or
      </Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="3D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>
        Data Rate Lower Byte.
        See formula above. Defaults = 40kbps.
      </Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txdtrtscale" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        5
        txdtrtscale
        This bit should be set for Data Rates below 30kbps.
        4
        enphpwdn
        If set, the Packet Handler will be powered down when chip is in low power mode.
        3
        manppol
        Manchester Preamble Polarity (will transmit a series of 1 if set, or series of 0 if reset).
        This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester Mode is enabled.
        2
        enmaninv
        Manchester Data Inversion is Enabled if this bit is set.
        1
        enmanch
        Manchester Coding is Enabled if this bit is set.
        0
        enwhite
        Data Whitening is Enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        TX Data Clock Configuration.
        00:	No TX Data CLK is available (asynchronous mode     Can only work with modulations FSK or OOK).
        01:	TX Data CLK is available via the GPIO (one of the GPIO   s should be programmed as well).
        10:	TX Data CLK is available via the SDO pin.
        11:	TX Data CLK is available via the nIRQ pin.
        5:4
        dtmod[1:0]
        Modulation Source.
        00: 	Direct Mode using TX_Data function via the GPIO pin 	(one of the GPIO   s should be programmed accordingly as well)
        01: 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10: 	FIFO Mode
        11: 	PN9 (internally generated)
        3
        eninv
        TX Data.
        2
        fd[8]
        MSB of Frequency Deviation Setting, see"Register 72h. Frequency Deviation".
        1:0
        modtyp[1:0]
        Modulation Type.
        00:	Unmodulated carrier
        01:	OOK
        10:	FSK
        11:	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>
        Frequency Deviation Setting.

      </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>
        Frequency Offset Setting.
        The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value.
      </Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>
        1:0
        fo[9:8]
        Upper Bits of the Frequency Offset Setting.
        fo[9] is the sign bit. The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value.
      </Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        6
        sbsel
        Side Band Select.
        5
        hbsel
        High Band Select.
        Setting hbsel = 1 will choose the frequency range from 480   960MHz (high bands). Setting hbsel = 0 will choose the frequency range from 240   479.9MHz (low bands).
        4:0
        fb[4:0]
        Frequency Band Select.
        Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands. Setting fb[4:0]=00000 corresponds to the 240   250MHz Band for hbsel=0 and the 480   500MHz Band for hbsel=1. Setting fb[4:0]=00001 corresponds to the 250   260MHz Band for hbsel=0 and the 500   520MHz Band for hbsel=1.
        The RF carrier frequency can be calculated as follows:
        fcarrier = (fb+24+(fc+fo) / 64000)x10000x(hbsel+1) + (fhchxfhsx10) [kHz],
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>
        Nominal Carrier Frequency Setting.
      </Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>
        Nominal Carrier Frequency Setting.
      </Description>
    </Register>
    <Register address="78" name="Miscellaneous Settings" size="8" defaultVal="19" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="ifsw_en" />
      <Bit index="3" name="Alt_PA_Seq" />
      <Bit index="2" name="rcosc[2]" />
      <Bit index="1" name="rcosc[1]" />
      <Bit index="0" name="rcosc[0]" />
      <Description>
        4
        ifsw_en
        Enable for IF SW between PA and IF.
        3
        alt_pa_seq
        Alternative PA sequencing.
        If set, we will enable the alternative PA sequence. By default, this is not enabled.
        2:0
        rcosc_cal[2:0]
        rcosc_cal[2:0].
        Fine changes on the RC OSC Calibration target frequency, to help compensate for    calibration biases.    This register should not be changed by costumers.
      </Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>Frequency Hopping Channel Number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>
        Frequency Hopping Step Size in 10kHz Increments.
        See formula for the nominal carrier frequency at"Register 76h. Nominal Carrier Frequency".
      </Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>
        5:0
        txafthr[5:0]
        TX FIFO Almost Full Threshold.
      </Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>
        5:0
        txfaethr[5:0]
        TX FIFO Almost Empty Threshold.
      </Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        FIFO Data.
        A Write (R/W=1) to this Address will begin a Burst Write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented. To conclude the TX FIFO Write the SEL pin should be brought HIGH, in the same manner.
      </Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="22" type="Si4330" revision="B1" projectID="0" name="Ara 4330_B1">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="8" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        4:0
        dt[4:0]
        Device Type Code.
        EZRadioPRO: 01000.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="06" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>
        4:0
        vc[4:0]
        Version Code.
        Code indicating the version of the chip.
      </Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>
        7
        RX FIFO Overflow Status.
        6
        ffunfl
        RX FIFO Underflow Status.
        5
        rxffem
        RX FIFO Empty Status.
        4
        headerr
        Header Error Status.
        Indicates if the received packet has a header check error.
        3:2
        Reserved
        1:0
        cps[1:0]
        Chip Power State.
        00:	Idle State
        01:	RX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>
        7
        FIFO Underflow/Overflow Error.
        When set to 1 the RX FIFO has overflowed or underflowed.
        6:5
        Reserved
        5
        itxffaem
        TX FIFO Almost Empty.
        When set to 1 the TX FIFO is almost empty and needs to be filled.
        4
        irxffafull
        RX FIFO Almost Full.When set to 1 the RX FIFO has met its almost full threshold and needs to be read by the microcontroller.
        3
        iext
        External Interrupt.
        When set to 1 an interrupt occurred on one of the GPIO   s if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        2
        Reserved
        1
        ipkvalid
        Valid Packet Received.When set to 1 a valid packet has been received.
        0
        icrcerror
        CRC Error.
        When set to 1 the cyclic redundancy check is failed.
        When any of the Interrupt/Status 1 bits change state from 0 to 1 the device will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 1 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 1 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
        Table 26. Interrupt or Status 1 Bit Set/Clear Description
        Bit
        Status Name
        Set/Clear Conditions
        7
        ifferr
        Set if there is a FIFO overflow or underflow. Cleared by applying FIFO reset.
        6:5
        Reserved
        5
        itxffaem
        Set when the number of bytes in the TX FIFO is less than or equal to the Almost Empty threshold. Automatically cleared when the number of data bytes in the TX FIFO is above the Almost Empty threshold.
        4
        irxffafull
        Set when the number of bytes in the RX FIFO is greater than the Almost Full threshold. Cleared when the number of bytes in the RX FIFO is below the Almost Full threshold.
        3
        iext
        External interrupt source.
        2
        Reserved
        1
        ipkvalid
        Set up the successful reception of a packet (no RX abort). Cleared upon receiving and acknowledging the Sync Word for the next packet.
        0
        icrcerror
        Set if the CRC computed from the RX packet differs from the CRC in the TX packet. Cleared at the start of reception for the next packet.
        Table 27. When are Individual Status Bits Set/Cleared if not Enabled as Interruptsu
        Bit
        Status Name
        Set/Clear Conditions
        7
        ifferr
        Set if there is a FIFO Overflow or Underflow. It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
        6:5
        Reserved
        5
        itxffaem
        Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
        4
        irxffafull
        Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we read enough data from RX FIFO so that the number of data bytes not yet read is below the Almost Full threshold.
        3
        iext
        External interrupt source
        2
        Reserved
        1
        ipkvalid
        Goes high once a packet is fully received (no RX abort). It is automatically cleaned once we receive and acknowledge the Sync Word for the next packet.
        0
        icrcerror
        Goes High once the CRC computed during RX differs from the CRC sent in the packet by the TX. It is cleaned once we start receiving new data in the next packet.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        7
        Sync Word Detected.
        When a sync word is detected this bit will be set to 1.
        6
        ipreaval
        Valid Preamble Detected.
        When a preamble is detected this bit will be set to 1.
        5
        ipreainval
        Invalid Preamble Detected.
        When the preamble is not found within a period of time set by the invalid preamble detection threshold in Register 54h, this bit will be set to 1.
        4
        irssi
        RSSI.
        When RSSI level exceeds the programmed threshold this bit will be set to 1.
        3
        iwut
        Wake-Up-Timer.
        On the expiration of programmed wake-up timer this bit will be set to 1.
        2
        ilbd
        Low Battery Detect.
        When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        1
        ichiprdy
        Chip Ready (XTAL).
        When a chip ready event has been detected this bit will be set to 1.
        0
        ipor
        Power-on-Reset (POR).
        When the chip detects a Power on Reset above the desired setting this bit will be set to 1.
        When any of the Interrupt/Status Register 2 bits change state from 0 to 1 the control block will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 2 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 2 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
        Table 28.  Interrupt or Status 2 Bit Set/Clear Description
        Bit
        Status Name
        Set/Clear Conditions
        7
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        6
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        5
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        4
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        3
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        2
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        1
        ichiprdy
        Chip ready goes high once we enable the xtal, RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        0
        ipor
        Power on status.
        Table 29. Detailed Description of Status Registers when not Enabled as Interrupts
        Bit
        Status Name
        Set/Clear Conditions
        7
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        6
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        5
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        4
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        3
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        2
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        1
        ichiprdy
        Chip ready goes high once we enable the xtal, RX, and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        0
        ipor
        Power on status.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>
        7
        Enable FIFO Underflow/Overflow.
        When set to 1 the FIFO Underflow/Overflow interrupt will be enabled.
        6:5
        Reserved
        4
        enrxffafull
        Enable RX FIFO Almost Full.
        When set to 1 the RX FIFO Almost Full interrupt will be enabled.
        3
        enext
        Enable External Interrupt.
        When set to 1 the External Interrupt will be enabled.
        2
        Reserved
        1
        enpkvalid
        Enable Valid Packet Received.
        When ipkvalid = 1 the Valid Packet Received Interrupt will be enabled.
        0
        encrcerror
        Enable CRC Error.
        When set to 1 the CRC Error interrupt will be enabled.
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        7
        Enable Sync Word Detected.
        When mpreadet =1 the Preamble Detected Interrupt will be enabled.
        6
        enpreaval
        Enable Valid Preamble Detected.
        When mpreadet =1 the Valid Preamble Detected Interrupt will be enabled.
        5
        enpreainval
        Enable Invalid Preamble Detected.
        When mpreadet =1 the Invalid Preamble Detected Interrupt will be enabled.
        4
        enrssi
        Enable RSSI.
        When set to 1 the RSSI Interrupt will be enabled.
        3
        enwut
        Enable Wake-Up Timer.
        When set to 1 the Wake-Up Timer interrupt will be enabled.
        2
        enlbd
        Enable Low Battery Detect.
        When set to 1 the Low Battery Detect interrupt will be enabled.
        1
        enchiprdy
        Enable Chip Ready (XTAL).
        When set to 1 the Chip Ready interrupt will be enabled.
        0
        enpor
        Enable POR.
        When set to 1 the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        7
        Software Register Reset Bit.
        This bit may be used to reset all registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register. The RESET is accomplished by setting swres = 1. This bit will be automatically cleared.
        6
        enlbd
        Enable Low Battery Detect.
        When this bit is set to 1 the Low Battery Detector circuit and threshold comparison will be enabled.
        5
        enwt
        Enable Wake-Up-Timer.
        Enabled when enwt = 1. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        4
        x32ksel
        32,768 kHz Crystal Oscillator Select.
        0:	RC oscillator
        1:	32kHz crystal
        3
        Reserved
        2
        rxon
        RX on in Manual Receiver Mode.
        Automatically cleared if Multiple Packets config. is disabled and a valid packet received.
        1
        pllon
        TUNE Mode (PLL is ON).
        When pllon = 1 the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        0
        xton
        READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="Reserved" />
      <Description>
        7
        Enable Antenna Diversity.
        The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
        RX state	non RX state
        GPIO Ant1	GPIO Ant2	GPIO Ant1	GPIO Ant2
        000: 	0	1	0	0
        001:	1	0	0	0
        010: 	0	1	1	1
        011:	1	0	1	1
        100:	antenna diversity algorithm	0	0
        101: 	antenna diversity algorithm	1	1
        110:	ant. div. algorithm in beacon mode	0	0
        111: 	ant. div. algorithm in beacon mode 	1	1
        4
        rxmpk
        RX Multi Packet.
        When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the receiver will automatically leave the RX State after the first valid packet has been received.
        3
        Reserved
        2
        enldm
        Enable Low Duty Cycle Mode.
        If this bit is set to 1 then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
        1
        ffclrrx
        RX FIFO Reset/Clear.
        This has to be a two writes operation: Setting ffclrrx=1 followed by ffclrrx= 0 will clear the contents of the RX FIFO.
        0
        Reserved
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>
        7
        Additional capacitance to course shift the frequency if xlc[6:0] is not sufficient. Not binary with xlc[6:0].
        6:0
        xlc[6:0]
        Tuning Capacitance for the 30MHz XTAL.
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        5:4
        clkt[1:0]
        Clock Tail.
        If enlfc = 0 then it can be useful to provide a few extra cycles for the microcontroller to complete its operation. Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00: 	0 cycle
        01: 	128 cycles
        10: 	256 cycles
        11: 	512 cycles
        3
        enlfc
        Enable Low Frequency Clock.
        When enlfc = 1 and the chip is in Sleep mode then the 32.768kHz clock will be provided to the microcontroller no matter what the selection of mclk[2:0] is. For example if mclk[2:0] =    000   , 30MHz will be available through the GPIO to output to the microcontroller in all Idle or RX states. When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        2:0
        mclk[2:0]
        Microcontroller Clock.
        Different clock frequencies may be selected for configurable GPIO clock output. All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator. The mclk[2:0] setting is only valid when xton = 1 except the 111.
        000: 	30 MHz
        001: 	15 MHz
        010: 	10 MHz
        011: 	4 MHz
        100: 	3 MHz
        101: 	2 MHz
        110: 	1 MHz
        111:	32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        7:6
        GPIO Driving Capability Setting.
        5
        pup0
        Pullup Resistor Enable on GPIO0.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio0[4:0]
        GPIO0 pin Function Select.
        00000: 	Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	RX Data CLK output to be used in conjunction with RX Data pin (output)
        10000:	Reserved
        10001:	External Retransmission Request (input)
        10010:	Reserved
        10011:	Reserved
        10100:	RX Data (output)
        10101:	RX State (output)
        10110:	RX FIFO Almost Full (output)
        10111:	Antenna 1 Switch used for antenna diversity (output)
        11000:	Antenna 2 Switch used for antenna diversity (output)
        11001:	Valid Preamble Detected (output)
        11010:	Invalid Preamble Detected (output)
        11011:	Sync Word Detected (output)
        11100:	Clear Channel Assessment (output)
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        7:6
        GPIO Driving Capability Setting.
        5
        pup1
        Pullup Resistor Enable on GPIO1.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio1[4:0]
        GPIO1 pin Function Select.
        00000: 	Inverted Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	Reserved
        10000:	Reserved
        10001:	External Retransmission Request (input)
        10010:	Reserved
        10011:	Reserved
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        7:6
        GPIO Driving Capability Setting.
        5
        pup2
        Pullup Resistor Enable on GPIO2.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio2[4:0]
        GPIO2 pin Function Select.
        00000: 	Microcontroller Clock
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	RX Data CLK output to be used in conjunction with RX Data pin (output)
        10000:	Reserved
        10001:	External Retransmission Request (input)
        10010:	Reserved
        10011:	Reserved
        10100:	Reserved
        10101:	Reserved
        10110:	Reserved
        10111:	Reserved
        11000:	Reserved
        11001:	Reserved
        11010:	Reserved
        11011:	Reserved
        11100:	Reserved
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        6
        extitst[2]
        External Interrupt Status.
        If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        5
        extitst[1]
        External Interrupt Status.
        If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        4
        extitst[0]
        External Interrupt Status.
        If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        3
        itsdo
        Interrupt Request Output on the SDO Pin.
        nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        2
        dio2
        Direct I/O for GPIO2.
        If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        1
        dio1
        Direct I/O for GPIO1.
        If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        0
        dio0
        Direct I/O for GPIO0.
        If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart/adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        7
        ADC Measurement Start Bit.
        Reading this bit gives 1 if the ADC measurement cycle has been finished.
        6:4
        adcsel[2:0]
        ADC Input Source Selection.
        The internal 8-bit ADC input source can be selected as follows:
        000:	Internal Temperature Sensor
        001:	GPIO0, single-ended
        010:	GPIO1, single-ended
        011: 	GPIO2, single-ended
        100:	GPIO0(+)     GPIO1(   ), differential
        101:	GPIO1(+)     GPIO2(   ), differential
        110:	GPIO0(+)     GPIO2(   ), differential
        111:	GND
        3:2
        adcref[1:0]
        ADC Reference Voltage Selection.
        The reference voltage of the internal 8-bit ADC can be selected as follows:
        0X:	bandgap voltage (1.2V)
        10:	VDD / 3
        11: 	VDD / 2
        1:0
        adcgain[1:0]
        ADC Sensor Amplifier Gain Selection.
        The full scale range of the internal 8-bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0:	adcref[0] = 1:
        FS = 0.014 x (adcgain[1:0] + 1) x VDD 	FS = 0.021 x (adcgain[1:0] + 1) x VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>
        3:0
        adcoffs[3:0]
        ADC Sensor Amplifier Offset*.
        *Note:	 The offset can be calculated as Offset = adcoffs[2:0] x VDD / 1000; MSB = adcoffs[3] = Sign bit.
      </Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>
        7:6
        Temperature Sensor Range Selection.
        (FS range is 0..1024mV)
        00:	   40uoC .. 64uoC (full operating range), with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        01:	   40uoC .. 85uoC, with 1uoC resolution (1 LSB in the 8-bit ADC)
        11:	   0uoC .. 85uoC, with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        10:	   40uoF .. 216uoF, with 1uoF resolution (1 LSB in the 8-bit ADC)
        5
        entsoffs
        Temperature Sensor Offset to Convert from K to   C.
        4
        entstrim
        Temperature Sensor Trim Enable.
        3:0
        tstrim[3:0]
        Temperature Sensor Trim Value.
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>
        Temperature Value Offset.
        This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)
      </Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description>
        4:0
        wtr[4:0]
        Wake Up Timer Exponent (R) Value*.
        Maximum value for R is decimal 20. A value greater than 20 will yield a result as if 20 were written. R Value = 0 can be written here.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms. R=0 is allowed, and the maximum value for R is decimal 20. A value greater than 20 will result in the same as if 20 was written.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        M[7:0] = 0 is not valid here. Write at least decimal 1.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>
        Low-Duty Cycle Mode Duration (LDC)*.
        If enabled, the LDC will start together when the WUT is supposed to start, and the duration of the LDC is specified by the address 19h and the equation that goes with it. In order for the LDC to work, the LDC value has to be smaller than the M value specified in registers 15h and 16h.
        LDC = 0 is not allowed here. Write at least decimal 1.
        *Note:	 The period of the low-duty cycle ON time can be calculated as TLDC_ON = (4 x LDC x 2R) / 32.768 ms. R is the same as in the wake-up timer setting in"Register 14h. Wake-Up Timer Period 1". The LDC works in conjunction with the WUT. The LDC period must be specified to be smaller than the WUT period. (i.e., the LDC register must be smaller than the M register). The LDC may not be programmed to 0.
      </Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>
        4:0
        lbdt[4:0]
        Low Battery Detector Threshold.
        This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2.7V.*
        *Note:	 The threshold can be calculated as Vthreshold = 1.7+lbdtx50mV.
      </Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        4:0
        vbat[4:0]
        Battery Voltage Level.
        The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continuously.
      </Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>
        7
        Bypass Decimator by 3 (if set).
        6:4
        ndec_exp[2:0]
        IF Filter Decimation Rates.
        3:0
        filset[3:0]
        IF Filter Coefficient Sets.
        Defaults are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz.
      </Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afcbd" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="afcgearl[2]" />
      <Bit index="1" name="afcgearl[1]" />
      <Bit index="0" name="afcgearl[0]" />
      <Description>
        7
        If set, the tolerated AFC frequency error will be halved.
        6
        enafc
        AFC Enable.
        5:3
        afcgearh[2:0]
        AFC High Gear Setting.
        2:0
        afcgearl[2:0]
        AFC Low Gear Setting.
      </Description>
    </Register>
    <Register address="1E" name="AFC Timing Control" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swait_timer[1]" />
      <Bit index="6" name="swait_timer[0]" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="anwait[2]" />
      <Bit index="1" name="anwait[1]" />
      <Bit index="0" name="anwait[0]" />
      <Description>
        7:6
        Short Wait RSSI Timer.
        The second phase RSSI waiting timer offset.
        5:3
        shwait[2:0]
        Short Wait Periods after AFC Correction.
        Used before preamble is detected. Short wait = (RegValue + 1)x2Tb. If set to 0 then no AFC correction will occur before preamble detect, i.e. AFC will be disabled.
        2:0
        anwait[2:0]
        Antenna Switching Wait Time.
        Value corresponds to number of bits.
      </Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>
        5:3
        crfast[2:0]
        Clock Recovery Fast Gearshift Value.
        2:0
        crslow[2:0]
        Clock Recovery Slow Gearshift Value.
        The gear-shift register controls BCR loop gain. Before the preamble is detected, BCR loop gain is as follows:
        Once the preamble is detected, internal state machine automatically shift BCR loop gain to the following:
        crfast = 3   b000 and crslow = 3   b101 are recommended for most applications. The value of    crslow    should be greater than    crfast   .
      </Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>
        Oversampling Rate.
        3 LSBs are the fraction, default = 0110 0100 = 12.5 clock cycles per data bit
        The oversampling rate can be calculated as rxosr = 500kHz/(2ndec_expxRX_DR). The ndec_exp and the dwn3_bypass values found at Address: 1Ch     IF Filter Bandwidth register together with the receive data rate (Rb) are the parameters needed to calculate rxosr:
        The Rb unit used in this equation is in kbps. The enmanch is the Manchester Coding parameter (see Reg. 70h, enmach is 1 when Manchester coding is enabled, enmanch is 0 when disabled). The number found in the equation should be rounded to an integer. The integer can be translated to a hexadecimal.
      </Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="stallctrl" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>
        7:5
        Oversampling Rate.
        Upper bits.
        4
        stallctrl
        Used for BCR Purposes.
        3:0
        ncoff[19:16]
        NCO Offset.
        See formula above.
        The offset can be calculated as follows:
      </Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>
        NCO Offset.
        See formula above
      </Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>
        NCO Offset.
        See formula above
      </Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="rxncocomp" />
      <Bit index="3" name="crgain2x" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>
        4
        rxncocomp
        Receive Compensation Enable for High Data Rate Offset.
        3
        cgainx2
        Multiplying the CR Gain by 2.
        2:0
        crgain[10:8]
        Clock Recovery Timing Loop Gain.
        The loop gain can be calculated as follows:
      </Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>Clock Recovery Timing Loop Gain.</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>Received Signal Strength Indicator Value.</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="1E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>
        RSSI Threshold.
        Interrupt is set if the RSSI value is above this threshold.
      </Description>
    </Register>
    <Register address="2A" name="AFC Limiter" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Afclim[7]" />
      <Bit index="6" name="Afclim[6]" />
      <Bit index="5" name="Afclim[5]" />
      <Bit index="4" name="Afclim[4]" />
      <Bit index="3" name="Afclim[3]" />
      <Bit index="2" name="Afclim[2]" />
      <Bit index="1" name="Afclim[1]" />
      <Bit index="0" name="Afclim[0]" />
      <Description>
        AFC Limiter.
        AFC limiter value.
        For the following registers (addresses 2Bh and 2Ch), use the following equation:
        where Rb's unit is in kHz and    enmanch    is the Manchester Enable bit (found at address 71h bit [1]).
      </Description>
    </Register>
    <Register address="2B" name="AFC Correction Read" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[8]" />
      <Bit index="5" name="afc_corr[7]" />
      <Bit index="4" name="afc_corr[6]" />
      <Bit index="3" name="afc_corr[5]" />
      <Bit index="2" name="afc_corr[4]" />
      <Bit index="1" name="afc_corr[3]" />
      <Bit index="0" name="afc_corr[2]" />
      <Description>
        AFC Correction Values.
        AFC loop correction values [9:2] (MSBs only). Values are updated once, after sync word is found during receiving. See also address 2Ch.
      </Description>
    </Register>
    <Register address="2C" name="OOK Counter Value 1" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[9]" />
      <Bit index="5" name="ookfrzen" />
      <Bit index="4" name="peakdeten" />
      <Bit index="3" name="madeten" />
      <Bit index="2" name="ookcnt[10]" />
      <Bit index="1" name="ookcnt[9]" />
      <Bit index="0" name="ookcnt[8]" />
      <Description>
        7:6
        AFC Correction Values.
        AFC loop correction values [1:0] (LSBs). Values are updated once, after sync word is found during receiving. See also address 2Bh.
        5
        ookfrzen
        OOK Freeze.
        OOK AGC freeze if this bit is set.
        4
        peakdeten
        Peak Detector Enable.
        Peak detector enable if high.
        3
        madeten
        MA_Enable.
        MA block enable if high.
        2:0
        ookcnt[2:0]
        OOK Counter [10:8].
        OOK counter value MSBs.
      </Description>
    </Register>
    <Register address="2D" name="OOK Counter Value 2" size="8" defaultVal="BC" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ookcnt[7]" />
      <Bit index="6" name="ookcnt[6]" />
      <Bit index="5" name="ookcnt[5]" />
      <Bit index="4" name="ookcnt[4]" />
      <Bit index="3" name="ookcnt[3]" />
      <Bit index="2" name="ookcnt[2]" />
      <Bit index="1" name="ookcnt[1]" />
      <Bit index="0" name="ookcnt[0]" />
      <Description>
        OOK Counter [7:0].
        OOK counter value LSBs.
      </Description>
    </Register>
    <Register address="2E" name="Slicer Peak Hold" size="8" defaultVal="26" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="attack[2]" />
      <Bit index="5" name="attack[1]" />
      <Bit index="4" name="attack[0]" />
      <Bit index="3" name="decay[3]" />
      <Bit index="2" name="decay[2]" />
      <Bit index="1" name="decay[1]" />
      <Bit index="0" name="decay[0]" />
      <Description>
        6:4
        attack[2:0]
        Attack.
        3:0
        decay[3:0]
        Decay.
      </Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="skip2ph" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        7
        Enable Packet RX Handling.
        If FIFO Mode (dtmod=10) is being used automatic packet handling may be enabled. Setting enpacrx=1 will enable automatic packet handling in the RX path. Register 30   4D allow for various configurations of the packet structure. Setting enpacrx=0 will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
        6
        lsbfrst
        LSB First Enable.
        The LSB of the data will be received first if this bit is set.
        5
        crcdonly
        CRC Data Only Enable.
        When this bit is set to 1 the CRC is checked against the packet data fields only.
        4
        skip2ph
        Skip 2nd Phase of Preamble Detection.
        If set, we skip the second phase of the preamble detection (under certain conditions) if antenna diversity is enabled.
        3
        Reserved
        2
        encrc
        CRC Enable.
        Cyclic Redundancy Check generation is enabled if this bit is set.
        1:0
        crc[1:0]
        CRC Polynomial Selection.
        00:	CCITT
        01:	CRC-16 (IBM)
        10:	IEC-16
        11:	Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="rxcrc1" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="Reserved" />
      <Bit index="0" name="Reserved" />
      <Description>
        6
        rxcrc1
        If high, it indicates the last CRC received is all one   s.
        May indicated Transmitter underflow in case of CRC error.
        5
        pksrch
        Packet Searching.
        When pksrch = 1 the radio is searching for a valid packet.
        4
        pkrx
        Packet Receiving.
        When pkrx = 1 the radio is currently receiving a valid packet.
        3
        pkvalid
        Valid Packet Received.
        When a pkvalid = 1 a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
        2
        crcerror
        CRC Error.
        When crcerror = 1 a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
        1:0
        Reserved
        1
        pktx
        Packet Transmitting.
        When pktx = 1 the radio is currently transmitting a packet.
        0
        pksent
        Packet Sent.
        A pksent = 1 a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcen[3]" />
      <Bit index="6" name="bcen[2]" />
      <Bit index="5" name="bcen[1]" />
      <Bit index="4" name="bcen[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>
        7:4
        Broadcast Address (FFh) Check Enable.
        If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
        0000:	No broadcast address enable.
        0001:	Broadcast address enable for header byte 0.
        0010:	Broadcast address enable for header byte 1.
        0011:	Broadcast address enable for header bytes 0 &amp; 1.
        0100:
        3:0
        hdch[3:0]
        Received Header Bytes to be Checked Against the Check Header Bytes.
        One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.
        0000:	No Received Header check
        0001:	Received Header check for byte 0.
        0010:	Received Header check for bytes 1.
        0011:	Received header check for bytes 0 &amp; 1.
        0100:
      </Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        6:4
        hdlen[2:0]
        Header Length.
        Length of header used if packet handler is enabled for RX (enpacrx). Headers are received in descending order.
        000:	NoRX header
        001: 	Header 3
        010: 	Header 3 and 2
        011: 	Header 3 and 2 and 1
        100: 	Header 3 and 2 and 1 and 0
        3
        fixpklen
        Fix Packet Length.
        When fixpklen = 1 the packet length (pklen[7:0]) is not included in the header. When fixpklen = 0 the packet length is included in the header.
        2:1
        synclen[1:0]
        Synchronization Word Length.
        The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00: 	Synchronization Word 3
        01: 	Synchronization Word 3 and 2
        10: 	Synchronization Word 3 and 2 and 1
        11: 	Synchronization Word 3 and 2 and 1 and 0
        0
        prealen[8]
        MSB of Preamble Length.
        See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>
        Preamble Length.
        The value in the prealen[8:0] register corresponds to the number of nibbles (4 bits) in the packet. For example prealen[8:0] =    000001000    corresponds to a preamble length of 32 bits (8x4bits) or 4 bytes. The maximum preamble length is prealen[8:0] = 111111111 which corresponds to a 255 bytes Preamble. Writing 0 will have the same result as if writing 1, which corresponds to one single nibble of preamble.
      </Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description>
        7:3
        Number of nibbles processed during detection.
        2:0
        rssi_offset[2:0]
        rssi_offset[2:0]
        Value added as offset to RSSI calculation. Every increment in this register results in an increment of +4dB in the RSSI.
      </Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>
        Synchronization Word 3.
        4th byte of the synchronization word.
      </Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>
        Synchronization Word 2.
        3rd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>
        Synchronization Word 1.
        2nd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>
        Synchronization Word 0.
        1st byte of the synchronization word.
      </Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>
        Check Header 3.
        4th byte of the check header.
      </Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>
        Check Header 2.
        3rd byte of the check header.
      </Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>
        Check Header 1.
        2nd byte of the check header.
      </Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>
        Check Header 0.
        1st byte of the check header.
      </Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>
        Header Enable 3.
        4th byte of the check header.
      </Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>
        Header Enable 2.
        3rd byte of the check header.
      </Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>
        Header Enable 1.
        2nd byte of the check header.
      </Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>
        Header Enable 0.
        1st byte of the check header.
      </Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>
        Received Header 3.
        4th byte of the received header.
      </Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>
        Received Header 2.
        3rd byte of the received header.
      </Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>
        Received Header 1.
        2nd byte of the received header.
      </Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>
        Received Header 0.
        1st byte of the received header.
      </Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>
        Length Byte of the Received Packet during fixpklen = 0.
        (Specifies the number of Data bytes in the last received packet) This will be relevant ONLY if fixpklen (address 33h, bit[3]) is low during the receive time. If fixpklen is high, then the number of received Data Bytes can be read from the pklen register (address h3E).
      </Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description>
        5:0
        adc8[5:0]
        ADC8 Control Bits.
      </Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>
        4:0
        atb[4:0]
        Analog Test Bus.
        The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
        Table 30. Internal Analog Signals Available on the Analog Test Bus
        Addr
        hex
        ATBp
        ATBn
        0
        0
        1
        1
        MixIp
        MixIn
        2
        2
        MixQp
        MixQn
        3
        3
        PGA_Ip
        PGA_In
        4
        4
        PGA_Qp
        PGA_Qn
        5
        5
        vcmout
        vbn
        6
        6
        refmid
        vbiasp
        7
        7
        ADC_vcm
        ADC_vcmb
        8
        8
        ADC_ipoly10
        ADC_ref
        9
        9
        RefADC_p
        RefADC_m
        10
        A
        ADC_Res1Ip
        ADC_Res1In
        11
        B
        ADC_Res1Qp
        ADC_Res1Qn
        12
        C
        ADC_Res2Ip
        ADC_Res2In
        13
        D
        ADC_Res2Qp
        ADC_Res2Qn
        14
        E
        ADC_Res3Ip
        ADC_Res3In
        15
        F
        ADC_Res3Qp
        ADC_Res3Qn
        16
        10
        NC
        NC
        17
        11
        ADC_Cal_Ucap
        ADC_Cal_Ures
        18
        12
        I_CP_test
        PLL_IBG_05
        19
        13
        PLL_VBG
        VSS_VCO
        20
        14
        Vctrl_Test
        PLL_IPTAT_05
        21
        15
        PA_Vbias
        NC
        22
        16
        DIGBG
        DIGVFB
        23
        17
        IFBG
        IFVFB
        24
        18
        PLLBG
        PLLVREG
        25
        19
        IBias_10u
        IBias_5u
        26
        1A
        CLK_65K_Out
        AVSS
        27
        1B
        ADC8_VIN
        ADC8_VDAC
        28
        1C
        LBDcomp
        LBDcompref
        29
        1D
        TSBG
        TSVtemp
        30
        1E
        RFBG
        RFVREG
        31
        1F
        VCOBG
        VCOVREG
      </Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description></Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>
        7:3
        PLL Soft Settling Time (TS).
        This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0   s and 310  s, in 10   s intervals. The default plltime corresponds to 100  s. See formula above.
        2:0
        pllt0
        PLL Settling Time (TO).
        This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0   s and 70  s, in 10  s steps. The default pllt0 corresponds to 20  s. See formula above.
      </Description>
    </Register>
    <Register address="54" name="Invalid Preamble Threshold and PA Misc" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="pa_duty[1]" />
      <Bit index="4" name="pa_duty[0]" />
      <Bit index="3" name="ldoramplv[1]" />
      <Bit index="2" name="ldoramplv[0]" />
      <Bit index="1" name="Ido_pa_boost" />
      <Bit index="0" name="pabias_boost" />
      <Description>
        5:4
        pa_duty[1:0]
        PA Duty Cycle Control.
        Shifting the duty cycle of the PA will effect PA efficiency and harmonics.
        3:2
        ldoramplv[1:0]
        PA LDO Ramp Level.
        The starting ramp level of the PA LDO. The ramp level will effect modulation depth and spectral splatter.
        1
        ldo_pa_boost
        LDO PA Boost.
        0
        pa_vbias_boost
        PA VBIAS Boost.
      </Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        6
        xtalstarthalf
        If Set, the Xtal Wake Time Period is Halved.
        5
        adccaldone
        Delta-sigma ADC Calibration Done.Reading this bit gives 1 if the calibration process has been finished.
        4
        enrcfcal
        RC Oscillator Fine Calibration Enable.
        If this bit is set to 1 then the RC oscillator performs fine calibration in every app. 30 s.
        3
        rccal
        RC Calibration Force.
        If setting rccal=1 will automatically perform a forced calibration of the 32kHz RC Oscillator. The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a 0 to 1 will initiate the calibration. This bit is cleared automatically.
        2
        vcocaldp
        VCO Calibration Double Precision Enable.
        When this bit is set to 1 then the VCO calibration measures longer thus calibrates more precisely.
        1
        vcocal
        VCO Calibration Force.
        If in Idle Mode and pllon=1, setting vcocal=1 will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        0
        skipvco
        Skip VCO Calibration.
        Setting skipvco=1 will skip the VCO calibration when going from the Idle state to the RX state.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="oscdeten" />
      <Bit index="3" name="rssimasel" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>
        7
        If set, BCR phase compensation will be bypassed.
        6
        slicfbyp
        If set, slicer phase compensation will be bypassed.
        5
        dttype
        Dithering Type.
        If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add   1.
        4
        oscdeten
        If low, the ADC Oscillation Detection mechanism is allowed to work. If set, we disable the function.
        3
        rssimasel
        RSSI Moving Average Select.
        If 1 then the RSSI moving average read back is 8 bits. If 0 then the moving average is set to 4 bits.
        2
        refclksel
        Delta-Sigma Reference Clock Source Selection
        1:	10MHz
        0:	 PLL
        1
        refclkinv
        Delta-Sigma Reference Clock Inversion Enable.
        0
        distogg
        If reset, the discriminator toggling is disabled.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>
        7
        Direct Control to Analog.
        6
        fbdiv_rst
        Direct Control to Analog.
        5
        cpforceup
        Charge Pump Force Up.
        4
        cpforcedn
        Charge Pump Force Down.
        3
        cdconly
        Charge Pump DC Offset Only.
        2:0
        cdcurr[2:0]
        Charge Pump DC Current Selection.
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming/Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>
        7:6
        Charge Pump Current (Gain Setting).
        Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        5
        cpcorrov
        Charge Pump Correction Override Enable.
        4:0
        cpcorr[4:0]
        Charge Pump Correction Value.
        During read, you read what the Charge Pump sees. If cpcorrov = 1, then the value you write will go to the Charge Pump, and will also be the value you read. By default, cpcorr[4:0] wakes up as all Zeros.
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        6
        fbdivhc
        Feedback (fractional) Divider High Current Enable (+5  A).
        5:4
        d3trim[1:0]
        Divider 3 Current Trim Value.
        3:2
        d2trim[1:0]
        Divider 2 Current Trim Value.
        1:0
        d1p5trim[1:0]
        Divider 1.5 (div-by-1.5) Current Trim Value.
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        6
        vcocorrov
        VCO Current Correction Override.
        5:2
        vcocorr[3:0]
        VCO Current Correction Value.
        1:0
        vcocur[1:0]
        VCO Current Trim Value.
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov/vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>
        7
        VCO Calibration Override/Done.
        When vcocalov=0 the internal VCO calibration results may be viewed by reading the vcocal register. When vcocalov=1 the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives 1 if the calibration process has been finished.
        6:0
        vcocal[6:0]
        VCO Calibration Results.
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="0" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>
        7
        Enable DSM Dithering.
        If low, dithering is disabled.
        6
        Reserved
        Will read 0.
        5
        enoloop
        Open Loop Mode Enable.
        4
        dsmod
        Delta-Sigma Modulus.
        0: 64000
        1: 65 536
        3:2
        dsorder[1:0]
        Delta-Sigma Order.
        00: 	0 order
        01: 	1st order
        10: 	2nd order
        11: 	Mash 111
        1
        dsrstmode
        Delta-Sigma Reset Mode.
        0
        dsrst
        Delta-Sigma Reset.
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>
        7
        Mixer Enable Override.
        6
        enlna
        LNA Enable Override.
        5
        enpga
        PGA Enable Override.
        4
        Reserved
        3
        enbf5
        Buffer 5 Enable Override.
        2
        endv32
        Divider 3_2 Enable Override.
        1
        enbf12
        Buffer 1_2 Enable Override.
        0
        enmx2
        Multiplexer 2 Enable Override.
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>
        7
        Delta-Sigma Enable Override.
        6
        Reserved
        5
        enmx3
        Multiplexer 3 Enable Override.
        4
        enbf4
        Buffer 4 Enable Override.
        3
        enbf3
        Buffer 3 Enable Override.
        2
        enbf11
        Buffer 1_1 Enable Override.
        1
        enbf2
        Buffer 2 Enable Override.
        0
        pllreset
        PLL Reset Enable Override.
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>
        7
        Fractional Divider Enable Override.
        6
        endv31
        Divider 3_1 Enable Override.
        5
        endv2
        Divider 2 Enable Override.
        4
        endv1p5
        Divider 1.5 (div-by-1.5) Enable Override.
        3
        dvbshunt
        VCO Bias Shunt Enable Override Mode.
        2
        envco
        VCO Enable Override.
        1
        encp
        Charge Pump Enable Override.
        0
        enbg
        Bandgap Enable Override.
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="50" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>
        3:0
        chfiladd[3:0]
        Channel Filter Coefficient Look-up Table Address.
        The address for channel filter coefficients used in the RX path.
      </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>
        5:0
        chfilval[5:0]
        Filter Coefficient Value in the Look-up Table Addressed by the chfiladd[3:0].
      </Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        7:5
        Internal Power States of the Chip.
        LP:	000
        RDY:	001
        Tune:	011
        RX:	111
        4
        clkhyst
        Clock Hysteresis Setting.
        3
        enbias2x
        2 Times Higher Bias Current Enable.
        2
        enamp2x
        2 Times Higher Amplification Enable.
        1
        bufovr
        Output Buffer Enable Override.
        If set to 1 then the enbuf bit controls the output buffer.
        0: output buffer is controlled by the state machine.
        1: output buffer is controlled by the enbuf bit.
        0
        enbuf
        Output Buffer Enable.
        This bit is active only if the bufovr bit is set to 1.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>
        7
        RC Oscillator Coarse Calibration Override.
        When rccov=0 the internal Coarse Calibration results may be viewed by reading the rcccal register. When rccov=1 the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        6:0
        rcc[6:0]
        RC Oscillator Coarse Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>
        7
        RC Oscillator Fine Calibration Override.
        When rcfov=0 the internal Fine Calibration results may be viewed by reading the rcfcal register. When rcfov=1 the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        6:0
        rcf[6:0]
        RC Oscillator Fine Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>
        7
        Smart POR Enable.
        6
        enbias
        Bias Enable.
        5
        envcoldo
        VCO LDO Enable.
        4
        enifldo
        IF LDO Enable.
        3
        enrfldo
        RF LDO Enable.
        2
        enpllldo
        PLL LDO Enable.
        1
        endigldo
        Digital LDO Enable.
        0
        endigpwdn
        Digital Power Domain Powerdown Enable in Idle Mode.
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>
        7
        Enable Overrides.
        If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks.
        6
        enxtal
        Xtal Override Enable Value.
        5
        ents
        Temperature Sensor Enable.
        4
        enrc32
        32K Oscillator Enable.
        3
        Reserved
        2:0
        diglvl
        Digital LDO Level Setting.
      </Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="1F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>
        7
        Delta-Sigma ADC Reset.
        Active low.
        6
        enrefdac
        Delta-Sigma ADC Reference DAC Enable Override.
        5
        enadc
        Delta-Sigma ADC Enable Override.
        4
        adctuneovr
        Resonator RC Calibration Value Override Enable.
        3:0
        adctune[3:0]
        Resonator RC Calibration Value.
      </Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>
        4
        envcm
        Delta-Sigma ADC VCM Enable Override.
        3
        adcoloop
        Delta-Sigma ADC Open Loop Enable.
        2:0
        adcref[2:0]
        Delta-Sigma ADC Reference Voltage.
        000:	0.5 V
        001:	0.6 V
        010:	0.7 V

        111:	1.2 V
      </Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sgi" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>
        6
        SGI
        Stop Increasing Gain for AGC Loop.
        Default = 0.
        5
        agcen
        Automatic Gain Control Enable.
        When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
        4
        lnagain
        LNA Gain Select.
        0     min. gain = 5 dB	1    max. gain = 25 dB
        3:0
        pga[3:0]
        PGA Gain Override Value.
        000:	0 dB
        001:	3 dB
        010:	6 dB
        ...
        101:	24 dB max.
      </Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="agcovpm" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>
        7
        If set, AGC will ignore the Preamble Detection.
        6
        agcslow
        AGC Slow Gain Increase Enable.
        When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
        5:2
        lnacomp[3:0]
        LNA Gain Compensation.
        This bit is used for smoothing RSSI value when LNA gain is switched.
        1:0
        pgath[1:0]
        Window Comparator Reference Voltage Adjust in the PGA.
      </Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        5
        Reserved
        4
        enphpwdn
        If set, the Packet Handler will be powered down when chip is in low power mode.
        3
        manppol
        Manchester Preamble Polarity (will transmit a series of 1 if set, or series of 0 if reset).
        This is valid ONLY if Manchester Mode is enabled.
        2
        enmaninv
        Manchester Data Inversion is Enabled if this bit is set.
        1
        enmanch
        Manchester Coding is Enabled if this bit is set.
        0
        enwhite
        Data Whitening is Enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="reserved" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        5:4
        dtmod[1:0]
        Modulation Source.
        00: 	Direct Mode using TX_Data function via the GPIO pin 	(one of the GPIO   s should be programmed accordingly as well)
        01: 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10: 	FIFO Mode
        11: 	PN9 (internally generated)
        3
        eninv
        RX Data.
        2
        fd[8]
        MSB of Frequency Deviation Setting, see"Register 72h. Frequency Deviation".
        1:0
        Reserved
      </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>
        Frequency Offset Setting.
        The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value. Reading from this register will give the AFC correction last results, not this register value.
      </Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>
        1:0
        fo[9:8]
        Upper Bits of the Frequency Offset Setting.
        fo[9] is the sign bit.The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value. Reading from this register will give the AFC correction last results, not this register value.
      </Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        6
        sbsel
        Side Band Select.
        5
        hbsel
        High Band Select.
        Setting hbsel = 1 will choose the frequency range from 480   960MHz (high bands). Setting hbsel = 0 will choose the frequency range from 240   479.9MHz (low bands).
        4:0
        fb[4:0]
        Frequency Band Select.
        Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands. Setting fb[4:0]=00000 corresponds to the 240   250MHz Band for hbsel=0 and the 480   500MHz Band for hbsel=1. Setting fb[4:0]=00001 corresponds to the 250   260MHz Band for hbsel=0 and the 500   520MHz Band for hbsel=1.
        The RF carrier frequency can be calculated as follows:
        fcarrier = (fb+24+(fc+fo) / 64000)x10000x(hbsel+1) + (fhchxfhsx10) [kHz],
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>
        Nominal Carrier Frequency Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>
        Nominal Carrier Frequency Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="78" name="Miscellaneous Settings" size="8" defaultVal="19" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="ifsw_en" />
      <Bit index="3" name="Alt_PA_Seq" />
      <Bit index="2" name="rcosc[2]" />
      <Bit index="1" name="rcosc[1]" />
      <Bit index="0" name="rcosc[0]" />
      <Description>
        4
        ifsw_en
        Enable for IF SW between PA and IF.
        3
        alt_pa_seq
        Alternative PA sequencing.
        If set, we will enable the alternative PA sequence. By default, this is not enabled.
        2:0
        rcosc_cal[2:0]
        rcosc_cal[2:0].
        Fine changes on the RC OSC Calibration target frequency, to help compensate for    calibration biases.    This register should not be changed by costumers.
      </Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>Frequency Hopping Channel Number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>
        Frequency Hopping Step Size in 10kHz Increments.
        See formula for the nominal carrier frequency at"Register 76h. Nominal Carrier Frequency".
      </Description>
    </Register>
    <Register address="7B" name="Turn Around and 15.4 Length Compliance" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="15.4 Length" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="turn_around_en" />
      <Bit index="1" name="Phase[1]" />
      <Bit index="0" name="Phase[0]" />
      <Description>
        15.4 Packet Length Compliance.
        If set, then PK Length definition for both TX and RX will also include the CRC bytes, If reset, then the Length refers ONLY to the DATA payload. For example, writing    9    to this register when it is set, means we are sending/expecting    7    bytes of DATA, and the other    2    should be the CRC (CRC should be enabled separately).
        6:3
        Reserved[6:3]
        2
        turn_around_en
        Turn Around Enable.
        Enabling for the turn around functionality.
        1:0
        phase[1:0]
        Turn Around Phase.
        The RX to TX and vice-versa change in frequency will happen (if bit [2] is set) at the last byte, and these two registers set the bit position in which the frequency shifts should occur. Make sure it does not happen to early otherwise the last bits will be missed.
      </Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>
        5:0
        rxafthr[5:0]
        RX FIFO Almost Full Threshold.
      </Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        FIFO Data.
        A Read (R/W=0) to this address will begin a burst read of the RX FIFO.
      </Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="23" type="Si4432" revision="B1" projectID="0" name="Ara 4430-31-32_B1">
    <TxPufferSize>0</TxPufferSize>
    <RxPufferSize>0</RxPufferSize>
    <TxPufferAddress>0</TxPufferAddress>
    <RxPufferAddress>0</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        dt[4:0] = Device Type Code. This internally hardwired code identifies the type or family of chip.
        EZRadioPRO devices = 01000 = 08h.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="06" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>vc[4:0] = Version Code. This internally hardwired code identifies the chip revision. For EZRadioPRO devices, V2 revision = 00010 = 02h, A0 revision = 00100 = 04h,  B1 revision = 00110 = 06h.</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="1'b0" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>
        ffovfl = RX/TX FIFO Overflow status.
        ffunfl = RX/TX FIFO Underflow status.
        rxffem = RX FIFO Empty status.
        headerr = Header Error status. The actual received packet has a header check error.
        freqerr = Frequency Error status. The programmed frequency is outside of the operating range. The actual frequency is saturated to the max/min value.
        read 1'b0
        cps[1:0] = Chip Power State:
        00 - Idle State
        01 - RX State
        10 - TX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>
        ifferr = FIFO Underflow/Overflow Error.  When set to '1' the TX or RX FIFO has overflowed or underflowed.
        itxffafull = TX FIFO Almost Full.  When set to '1' the TX FIFO has met its almost full threshold and needs to be transmitted.
        itxffaem= TX FIFO Almost Empty.  When set to '1' the TX FIFO is almost empty and needs to be filled.
        irxffafull = RX FIFO Almost Full.  When set to '1' the RX FIFO has met its almost full threshold and needs to be read by the microcontroller
        iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        ipksent = Packet Sent Interrupt. When set to'1' a valid packet has been transmitted.
        ipkvalid =  Valid Packet Received. When set to '1' a valid packet has been received.
        icrcerror = CRC Error. When set to '1' the cyclic redundancy check is failed.
        When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
        Bit
        Status Name
        Set/Clear conditions:
        [7]
        ifferr
        Set if there is a TX or RX FIFO Overflow or Underflow condition.  It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
        [6]
        itxffafull
        Will be set when the number of bytes written to the TX FIFO is greater than the TX Almost Full Threshold set in SPI Reg 7Ch.  It is automatically cleared when a sufficient number of bytes have been read from the TX FIFO and transmitted, such that the remaining number of bytes in the TX FIFO is less than or equal to the TX Almost Full Threshold.
        [5]
        itxffaem
        Will be set when the number of bytes remaining for transmission in the TX FIFO is less than or equal to the TX Almost Empty Threshold set in SPI Reg 7Dh.  It is automatically cleared when a sufficient number of bytes have been written to the TX FIFO, such that the number of data bytes not yet transmitted is above the TX Almost Empty Threshold.  Update of this status flag requires a clock from the internal TX domain circuitry, and thus may not indicate accurately until TX mode is entered.
        [4]
        irxffafull
        Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the RX Almost Full threshold set in SPI Reg 7Eh.  It is automatically cleared when a sufficient number of bytes are read from the RX FIFO, such that the remaining number of bytes in the RX FIFO is below the RX Almost Full Threshold.  Update of this status flag requires a clock from the internal RX domain circuitry, and thus may not indicate accurately until RX mode is entered.
        [3]
        iext
        External interrupt source
        [2]
        ipksent
        Will be set upon complete transmission of a packet (no TX abort).  This status will be cleared if 1) The chip is commanded to leave FIFO mode, or 2) While the chip is in FIFO mode a new transmission is started.  Packet Sent functionality remains available even if the TX Packet Handler (enpactx bit D3 in SPI Reg 30h) is not enabled, as it is possible construct and send an entire packet from the FIFO without making use of the Packet Handler.
        [1]
        ipkvalid
        Will be set upon full and correct reception of a packet (no RX abort).  It is not automatically cleared by simply re-entering RX mode, but is only cleared upon detection of a valid Sync Word in the next RX packet.  Packet Valid functionality is not available if the RX Packet Handler (enpacrx bit D7 in SPI Reg 30h) is not enabled.
        [0]
        icrcerror
        Will be set if the CRC computed during RX differs from the CRC sent in the packet by the TX.  It is cleared upon start of data reception in a new packet.  CRC functionality is not available if the RX Packet Handler (enpacrx bit D7 in SPI Reg 30h) is not enabled.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
        ipreaval = Valid Preamble Detected. When a preamble is detected this bit will be set to 1.
        ipreainval = Invalid Preamble Detected. When the preamble is not found within a period of time after the RX is enabled, this bit will be set to 1.
        irssi = RSSI. When RSSI level exceeds the programmed thershold this bit will be set to 1.
        iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.
        ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
        ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.
        When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
        Bit
        Status Name
        Set/Clear conditions:
        [7]
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        [6]
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        [5]
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        [4]
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        [3]
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        [2]
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        [1]
        ichiprdy
        Chip ready goes high once we enable the xtal, Tx or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        [0]
        ipor
        Power on status.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>
        enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
        entxffafull = Enable TX FIFO Almost Full. When set to '1' the TX FIFO Almost Full interrupt will be enabled.
        entxffaem = Enable TX FIFO Almost Empty. When set to '1' the TX FIFO Almost Empty interrupt will be enabled.
        enrxffafull = Enable RX FIFO Almost Full. When set to '1' the RX FIFO Almost Full interrupt will be enabled.
        enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
        enpksent = Enable Packet Sent. When ipksent ='1' the Packet Sense Interrupt will be enabled.
        enpkvalid = Enable Valid Packet Received. When ipkvalid = '1' the Valid Packet Received Interrupt will be  enabled
        encrcerror = Enable CRC Error. When set to '1' the CRC Error  interrupt will be enabled.
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        enswdet = Enable Sync Word Detected. When '1' the Sync Word Detected Interrupt will be enabled.
        enpreaval = Enable Valid Preamble Detected. When '1' the Valid Preamble Detected Interrupt will be enabled.
        enpreainval = Enable Invalid Preamble Detected. When '1' the Invalid Preamble Detected Interrupt will be enabled.
        enrssi = Enable RSSI. When set to '1' the RSSI Interrupt will be  enabled.
        enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
        enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
        enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
        enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.
        enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.
        enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
        txon = TX on in manual transmit mode. It is automatically cleared in FIFO mode once the packet is sent.
        rxon = RX on in manual receiver mode. It is automatically cleared if Multiple Packets config. is disabled and a valid packet received.
        pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        xton = READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="ffclrtx" />
      <Description>
        antdiv[2:0] = Enable Antenna Diversity. The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
        RX/TX state non RX/TX state
        GPIO Ant1 GPIO Ant2 GPIO Ant1 GPIO Ant2
        000 -  1 0 0 0
        001 - 0 1 0 0
        010 -  1 0 1 1
        011 - 0 1 1 1
        100 - antenna diversity algorythm 0 0
        101 -  antenna diversity algorythm 1 1
        110 - ant. div. algorythm in beacon mode 0 0
        111 -  ant. div. algorythm in beacon mode   1 1
        rxmpk = RX Multi Packet. When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the transceiver will automatically leave the RX State after the first valid packet has been received.
        autotx = Automatic Transmission. When autotx = '1' the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.
        enldm = Enable Low Duty Cycle Mode. If this bit is set to '1' then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
        ffclrrx = RX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrrx='1' followed by ffclrrx= '0' will clear the contents of the RX FIFO.
        ffclrtx = TX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrtx='1' followed by ffclrtx= '0' will clear the contents of the TX FIFO.
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>
        xtalshft = Direct control to Analog
        xlc[6:0] = Tuning Capacitance for the 30MHz XTAL
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        clkt[1:0] = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00 -  0 cycle
        01 -  128 cycles
        10 -  256 cycles
        11 -  512 cycles
        enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = '1' except the '111'.
        000 -  30 MHz
        001 -  15 MHz
        010 -  10 MHz
        011 -  4 MHz
        100 -  3 MHz
        101 -  2 MHz
        110 -  1 MHz
        111 - 32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        gpiodrv0[1:0] - Gpio driving capability setting
        pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio0[4:0] = GPIO0pin function select:
        00000 -  Power-On-Reset (output)
        00001 -  Wake-Up Timer: '1' when WUT has expired  (output)
        00010 -  Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 -  Direct Digital Input
        00100 - External Interrupt, falling edge (input)
        00101 -  External Interrupt, rising edge (input)
        00110 -  External Interrupt, state change (input)
        00111 - ADC Analog Input
        01000 - Reserved (Analog Test N Intput)
        01001 - Reserved (Analog Test P Intput)
        01010 - Direct Digital Output
        01011 - Reserved (Digital Test Output)
        01100 - Reserved (Analog Test N Output)
        01101 - Reserved (Analog Test P Output)
        01110 - Reference Voltage (output)
        01111 - TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000 - TX Data input for direct modulation (input)
        10001 - External Retransmission Request (input)
        10010 - TX State (output)
        10011 - TX FIFO Almost Full  (output)
        10100 - RX Data (output)
        10101 - RX State (output)
        10110 - RX FIFO Almost Full  (output)
        10111 - Antenna 1 Switch used for antenna diversity  (output)
        11000 - Antenna 2 Switch used for antenna diversity  (output)
        11001 - Valid Preamble Detected  (output)
        11010 - Invalid Preamble Detected  (output)
        11011 - Sync Word Detected  (output)
        11100 - Clear Channel Assessement  (output)
        11101 - VDD
        else    - GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        gpiodrv1[1:0] - Gpio driving capability setting
        pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio1[4:0] = GPIO1 pin function select:
        00000 -  Power-On-Reset Inverted (output)
        00001 -  Wake-Up Timer: '1' when WUT has expired  (output)
        00010 -  Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 -  Direct Digital Input
        00100 - External Interrupt, falling edge (input)
        00101 -  External Interrupt, rising edge (input)
        00110 -  External Interrupt, state change (input)
        00111 - ADC Analog Input
        01000 - Reserved (Analog Test N Intput)
        01001 - Reserved (Analog Test P Intput)
        01010 - Direct Digital Output
        01011 - Reserved (Digital Test Output)
        01100 - Reserved (Analog Test N Output)
        01101 - Reserved (Analog Test P Output)
        01110 - Reference Voltage (output)
        01111 - TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000 - TX Data input for direct modulation (input)
        10001 - External Retransmission Request (input)
        10010 - TX State (output)
        10011 - TX FIFO Almost Full  (output)
        10100 - RX Data (output)
        10101 - RX State (output)
        10110 - RX FIFO Almost Full  (output)
        10111 - Antenna 1 Switch used for antenna diversity  (output)
        11000 - Antenna 2 Switch used for antenna diversity  (output)
        11001 - Valid Preamble Detected  (output)
        11010 - Invalid Preamble Detected  (output)
        11011 - Sync Word Detected  (output)
        11100 - Clear Channel Assessement  (output)
        11101 - VDD
        else    - GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        gpiodrv2[1:0] - Gpio driving capability setting
        pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio2[4:0] = GPIO2 pin function select:
        00000 - Microcontroller Clock (output)
        00001 -  Wake-Up Timer: '1' when WUT has expired  (output)
        00010 -  Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 -  Direct Digital Input
        00100 - External Interrupt, falling edge (input)
        00101 -  External Interrupt, rising edge (input)
        00110 -  External Interrupt, state change (input)
        00111 - ADC Analog Input
        01000 - Reserved (Analog Test N Intput)
        01001 - Reserved (Analog Test P Intput)
        01010 - Direct Digital Output
        01011 - Reserved (Digital Test Output)
        01100 - Reserved (Analog Test N Output)
        01101 - Reserved (Analog Test P Output)
        01110 - Reference Voltage (output)
        01111 - TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000 - TX Data input for direct modulation (input)
        10001 - External Retransmission Request (input)
        10010 - TX State (output)
        10011 - TX FIFO Almost Full  (output)
        10100 - RX Data (output)
        10101 - RX State (output)
        10110 - RX FIFO Almost Full  (output)
        10111 - Antenna 1 Switch used for antenna diversity  (output)
        11000 - Antenna 2 Switch used for antenna diversity  (output)
        11001 - Valid Preamble Detected  (output)
        11010 - Invalid Preamble Detected  (output)
        11011 - Sync Word Detected  (output)
        11100 - Clear Channel Assessement  (output)
        11101 - VDD
        else    - GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart/adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        adcstart / adcdone = Set this bit = 1 starts the ADC measurement process. This bit self-clears during the measurement cycle, and returns high when the measurement is complete. The conversion process is fast; reading this bit may always appear to return a 1.
        adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
        000 - Internal Temperature Sensor
        001 - GPIO0, single-ended
        010 - GPIO1, single-ended
        011 -  GPIO2, single-ended
        100 - GPIO0(+) - GPIO1(-), differential
        101 - GPIO1(+) - GPIO2(-), differential
        110 - GPIO0(+) - GPIO2(-), differential
        111 - GND, ADC is disabled
        adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
        0X - bandgap voltage (1.2V)
        10 - VDD / 3
        11 -  VDD / 2
        adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0: adcref[0] = 1:
        FS = 0.014 * (adcgain[1:0] + 1) * VDD  FS = 0.021 * (adcgain[1:0] + 1) * VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.</Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>
        tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
        00 - -40oC .. 64oC (full operating range), with 0.5oC resolution (1 LSB in the 8 bit ADC)
        01 - -40oC .. 85oC, with 1oC resolution (1 LSB in the 8 bit ADC)
        11 -    0oC .. 85oC, with 0.5oC resolution (1 LSB in the 8 bit ADC)
        10 - -40oF .. 216oF, with 1oF resolution (1 LSB in the 8 bit ADC)
        entsoffs = Temperature Sensor Offset to convert from K to oC.
        entstrim = Temperature Sensor Trim enable
        tstrim[3:0] = Temperature Sensor Trim value
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>
        tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)
        NOTE for registers 14h through 19h: If a new configuration is needed (for example for the WUT, or for the LDC), we require, for proper functionality, that the function be first disabled, then the settings changed, and then enabled back on.
      </Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description>
        wtr[4:0] = Wake Up Timer Exponent (R) value.  See formula above.
        Maximum value for R is decimal 20.   A value greater than 20 will yield a result as if 20 were written.
        R Value = 0 is allowed  to be written here.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>wtm[15:8] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        wtm[7:0] = Wake Up Timer Mantissa (M) value.  See formula above.
        M[7:0]  = 0 is not valid here. Write at least decimal 1.
      </Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>wtv[15:8] = Wake Up Timer counter Current Mantissa (M) value. (Read only)</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>wtv[7:0] = Wake Up Timer counter Current  Mantissa (M) value.  (Read only)</Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>
        ldc[7:0] = Low-Duty Cycle Mode Duration (LDC).  See formula above
        If enabled, the LDC will start together when the WUT is supposed to start, and the duration of the LDC is specified by the address 19h above and the equation that goes with it. In order for the LDC to work, the LDC Value above (reg 19h) has to be smaller than the M Value specified in registers 15h and 16h. Also, LDC = 0 is not allowed here, write at least 1.
      </Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>lbdt[4:0] = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.</Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC if the LBD bit D6 of Reg 07h is also set. In Sleep Mode the register is updated in every 1 s. In other states it measures continuously.
        The measured voltage is calculated by the following formula:
        Vbat_meas = 1.7[V] + vbat[4:0] x 50 mV.
      </Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>
        dwn3_bypass = Bypass decimator by 3 (if set).
        ndec_exp[2:0] = IF Filter decimation rates
        filset[3:0] = IF Filter coefficient sets ; defauts are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz
        When the required bandwidth (BW) is calculated then the three filter parameters, ndec_exp, dwn3_bypass and filset, can be found from the table below. When the calculated bandwidth value is not exactly available then select the higher available bandwidth closest to the calculated bandwidth.
        BW [kHz]
        ndec_exp
        1C-[6:4]
        dwn3_bypass
        1C-[7]
        filset
        1C-[3:0]
        BW [kHz]
        ndec_exp
        1C-[6:4]
        dwn3_bypass
        1C-[7]
        filset
        1C-[3:0]
        2.6
        5
        0
        1
        41.7
        1
        0
        2
        2.8
        5
        0
        2
        45.2
        1
        0
        3
        3.1
        5
        0
        3
        47.9
        1
        0
        4
        3.2
        5
        0
        4
        56.2
        1
        0
        5
        3.7
        5
        0
        5
        64.1
        1
        0
        6
        4.2
        5
        0
        6
        69.2
        1
        0
        7
        4.5
        5
        0
        7
        75.2
        0
        0
        1
        4.9
        4
        0
        1
        83.2
        0
        0
        2
        5.4
        4
        0
        2
        90.0
        0
        0
        3
        5.9
        4
        0
        3
        95.3
        0
        0
        4
        6.1
        4
        0
        4
        112.1
        0
        0
        5
        7.2
        4
        0
        5
        127.9
        0
        0
        6
        8.2
        4
        0
        6
        137.9
        0
        0
        7
        8.8
        4
        0
        7
        142.8
        1
        1
        4
        9.5
        3
        0
        1
        167.8
        1
        1
        5
        10.6
        3
        0
        2
        181.1
        1
        1
        9
        11.5
        3
        0
        3
        191.5
        0
        1
        15
        12.1
        3
        0
        4
        225.1
        0
        1
        1
        14.2
        3
        0
        5
        248.8
        0
        1
        2
        16.2
        3
        0
        6
        269.3
        0
        1
        3
        17.5
        3
        0
        7
        284.9
        0
        1
        4
        18.9
        2
        0
        1
        335.5
        0
        1
        8
        21.0
        2
        0
        2
        361.8
        0
        1
        9
        22.7
        2
        0
        3
        420.2
        0
        1
        10
        24.0
        2
        0
        4
        468.4
        0
        1
        11
        28.2
        2
        0
        5
        518.8
        0
        1
        12
        32.2
        2
        0
        6
        577.0
        0
        1
        13
        34.7
        2
        0
        7
        620.7
        0
        1
        14
        37.7
        1
        0
        1
      </Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afcbd" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="1p5 bypass" />
      <Bit index="1" name="matap" />
      <Bit index="0" name="ph0size" />
      <Description>
        Afcbd = AFC wide band enable (active high).  If set, the IF filter bandwidth is reduced after preamble detection in order to optimize RX sensitivity.
        The alternate IF filter coefficients must be specified in SPI Reg 60h and 61h; contact Silicon Labs Application Support for details.
        enafc = AFC enable
        afcgearh[2:0] = AFC High Gear Setting. Feedback loop gain during AFC settling process is proportional to 2^(-afcgearh[2:0]).
        1p5bypass = If high (1) select 0dB bias for the second phase antenna selection, if  low (0), select 1.5 dB. The default is (1), selecting 0 dB.
        matap = Number of taps for moving average filter during Antenna Diversity RSSI evaluation. Allows for reduced noise variation on measured RSSI value but with slower update rate. If high (1), filter tap length = 8*Tb. If low (0 = default), filter tap length = 8*Tb prior to first PREAMBLE_VALID, and 4*Tb thereafter.
        ph0size = If low, we will reset the Preamble detector if there are 5 consecutive zero phases. If high, the reset will happen after 3 consecutive zero phases.
      </Description>
    </Register>
    <Register address="1E" name="AFC/ AntDiv Timing Control" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swant_timer[1]" />
      <Bit index="6" name="swant_timer[0]" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="anwait[2]" />
      <Bit index="1" name="anwait[1]" />
      <Bit index="0" name="anwait[0]" />
      <Description>
        swant_timer  = additional number of bit periods to wait for RSSI value to stabilize during Antenna Diversity 2nd phase antenna evaluation. If matap=0, total wait time = 8*Tb+swant_timer[1:0]. If matap=1,total wait time = 12*Tb+swant_timer[1:0]. Effective only during Antenna Diversity.
        shwait[2:0] = short wait periods after AFC correction used before preamble is detected. Short wait = (RegValue+1)*2Tb. If set to '0' then no AFC correction will occur before preamble detect, i.e. AFC will be disabled.
        anwait[2:0] = Antenna switching wait time. Number of bit periods between toggling selection of antennas in AntDiv mode, prior to reception of first PREAMBLE_VALID.
        Number of bit periods = ( anwait[2:0] + 2 ) * 4 +3 (when AFC = enabled)
        Number of bit periods = ( anwait[2:0] + 2 ) * 2 +3 (when AFC = disabled)
        Default value = 3'b010 = 19 bit periods (AFC = enabled).
      </Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>
        crfast[2:0] = Clock Recovery Fast Gearshift value
        crslow[2:0] = Clock Recovery Slow Gearshift value
      </Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>
        rxosr[7:0] = Oversampling Rate, 3 LSBs are the fraction
        default = 0110 0100 = 12.5 clock cycles per data bit
      </Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="skip2phth" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>
        rxosr[10:8] = Oversampling Rate, upper bits
        skip2phth  = threshold for skipping the 2nd phase of RSSI detection during antenna diversity algorithm. 0 = 16 dB (default), 1 = 11 dB.
        NOT RECOMMENDED FOR USER CONFIGURATION.
        ncoff[19:16] = NCO offset. See formula above.
      </Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>ncoff[15:8] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>ncoff[7:0] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="rxncocomp" />
      <Bit index="3" name="cgainx2" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>
        rxncocomp = Receive compensation enable for high data rate offset.
        cgainx2 = multiplying the CR gain by two.
        crgain[10:8] = Clock Recovery Timing Loop Gain
      </Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>crgain[7:0] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>rssi[7:0] = Received Signal Strength Indicator value</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="1E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>rssith[7:0] = RSSI Threshold. Interrupt is set if the RSSI value is above this threshold.</Description>
    </Register>
    <Register address="28" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>adrssi1[7:0] = Measured RSSI value on antenna 1</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description>adrssi2[7:0] = Measured RSSI value on antenna 2</Description>
    </Register>
    <Register address="2A" name="AFC Limiter" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Afclim[7]" />
      <Bit index="6" name="Afclim[6]" />
      <Bit index="5" name="Afclim[5]" />
      <Bit index="4" name="Afclim[4]" />
      <Bit index="3" name="Afclim[3]" />
      <Bit index="2" name="Afclim[2]" />
      <Bit index="1" name="Afclim[1]" />
      <Bit index="0" name="Afclim[0]" />
      <Description>
        AFC Limiter[7:0] = AFC limiter value.
        For the following registers (addresses 2Bh and 2Ch), use the following equation:
        where Rb's unit is in  kHz and 'enmanch' is the Manchester Enable bit (found at address 71h bit [1]).
        Therefore, the  minimal data rate that this register can support without Manchester is 0.366 kbps.
      </Description>
    </Register>
    <Register address="2B" name="AFC Correction Read" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[8]" />
      <Bit index="5" name="afc_corr[7]" />
      <Bit index="4" name="afc_corr[6]" />
      <Bit index="3" name="afc_corr[5]" />
      <Bit index="2" name="afc_corr[4]" />
      <Bit index="1" name="afc_corr[3]" />
      <Bit index="0" name="afc_corr[2]" />
      <Description>AFC Correction Values = AFC loop correction values [9:2]  (MSB's only). Values are updated once, after sync word is found during receiving. See also address 2Ch.</Description>
    </Register>
    <Register address="2C" name="OOK Counter Value 1" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="afc_corr[1]" />
      <Bit index="6" name="afc_corr[0]" />
      <Bit index="5" name="ookfrzen" />
      <Bit index="4" name="peakdeten" />
      <Bit index="3" name="madeten" />
      <Bit index="2" name="ookcnt[10]" />
      <Bit index="1" name="ookcnt[9]" />
      <Bit index="0" name="ookcnt[8]" />
      <Description>
        AFC Correction Values = AFC loop correction values [1:0] (LSB's). Values are updated once, after sync word is found during receiving. See also address 2Bh.
        ookfrzen = when '0' (default), AGC and OOK Moving Average Detector threshold operate continuously. When '1', AGC and OOK MA Detector threshold operate until PREAMBLE_VALID signal is detected; values are frozen thereafter. Recommended for use with non-Manchestered payload data.
        peakdeten = when '1' (default), Peak Detector for OOK Modem is enabled. Provides improved performance in presence of co-channel interferers, at slight reduction of sensitivity. Peak Detector output is logically AND'ed with Moving Average Detector output.
        madeten = when '1' (default), Moving Average Detector for OOK Modem is enabled. Provides best sensitivity, but requires DC-balanced data (e.g. Manchester data) and is more sensitive to co-channel interference. Peak Detector output is logically AND'ed with Moving Average Detector output.
        OOK Counter [10:8] = OOK counter Value MSBs. This counter value will affect the OOK AGC's decay time.
      </Description>
    </Register>
    <Register address="2D" name="OOK Counter Value 2" size="8" defaultVal="BC" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ookcnt[7]" />
      <Bit index="6" name="ookcnt[6]" />
      <Bit index="5" name="ookcnt[5]" />
      <Bit index="4" name="ookcnt[4]" />
      <Bit index="3" name="ookcnt[3]" />
      <Bit index="2" name="ookcnt[2]" />
      <Bit index="1" name="ookcnt[1]" />
      <Bit index="0" name="ookcnt[0]" />
      <Description>OOK Counter [7:0] = OOK counter Value LSBs. This counter value will affect the OOK AGC's decay time.</Description>
    </Register>
    <Register address="2E" name="Slicer Peak Hold" size="8" defaultVal="26" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="reserv." />
      <Bit index="6" name="attack[2]" />
      <Bit index="5" name="attack[1]" />
      <Bit index="4" name="attack[0]" />
      <Bit index="3" name="decay[3]" />
      <Bit index="2" name="decay[2]" />
      <Bit index="1" name="decay[1]" />
      <Bit index="0" name="decay[0]" />
      <Description>
        Reserved
        attack[2:0] = OOK Peak Detector attack time. Peak detector value charges up at rate proportional to 2^(-attack[2:0]).  OOK slicing threshold is set 6 dB below peak detector value. Effective only when OOK Peak Detector is enabled.
        decay [3:0] = OOK Peak Detector decay time. Peak detector value discharges at rate proportional to 2^(-decay[3:0]). OOK slicing threshold is set 6 dB below peak detector value. Effective only when OOK Peak Detector is enabled.
      </Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="8D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="skip2ph" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        enpacrx = Enable Packet RX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpacrx='1' will enable automatic packet handling in the RX path. Register 30-4D allow for various configurations of the packet structure. Setting enpacrx='0' will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
        lsbfrst = LSB First enable. The LSB of the data will be transmitted/received first if this bit is set.
        crcdonly = CRC Data Only enable When this bit is set to '1' the CRC is calculated on and check against the packet data fields only.
        skip2ph = If set, we skip the second phase of preamble detection (under certain conditions) if the antenna diversity was enabled.
        enpactx = Enable Packet TX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpactx='1' will enable automatic packet handling in the TX path. Register 30-4D allow for various configurations of the packet structure. Setting enpactx='0' will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
        encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
        crc[1:0] = CRC polynomial selection.
        00 - CCITT
        01 - CRC-16 (IBM)
        10 - IEC-16
        11 - Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="rxcrc1" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>
        rxcrc1 = If high, it indicates the last CRC received is all one's. May indicated Transmitter underflow in case of CRC error.
        pksrch = Packet Searching. When pksrch = '1' the radio is searching for a valid packet.
        pkrx = Packet Receiving. When pkrx = '1' the radio is currently receiving a valid packet.
        pkvalid = Valid Packet Received. When a pkvalid = '1' a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
        crcerror = CRC Error.  When crcerror = '1' a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
        pktx = Packet Transmitting. When pktx = '1' the radio is currently transmitting a packet.
        pksent = Packet Sent.  A pksent  = '1' a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enbcast[1]" />
      <Bit index="6" name="enbcast[1]" />
      <Bit index="5" name="enbcast[1]" />
      <Bit index="4" name="enbcast[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>
        bcen[3:0] = Broadcast Address (FFh) Check enable.  If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
        0000 - No broadcast address enable.
        0001 - Broadcast address enable for header byte 0.
        0010 - Broadcast address enable for header byte 1.
        0011 - Broadcast address enable for header bytes 0 &amp; 1.
        0100 - ...
        hdch[3:0] = Received Header bytes to be checked against the Check Header bytes.  One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.
        0000 - No Received Header check
        0001 - Received Header check for byte 0.
        0010 - Received Header check for bytes 1.
        0011 - Received header check for bytes 0 &amp; 1.
        0100 - ...
      </Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="skipsyn" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        skipsyn = Skip Sync Word search timeout. If high, the system will ignore the search timeout period when failing to find Sync Word, and will not return to searching for Preamble. Setting this bit does NOT eliminate the search for Sync Word. Proper detection of Sync Word remains necessary in FIFO mode in order to determine the start of the Payload field and to thus store the correct bytes in the RX FIFO.
        hdlen[2:0] = Transmit/Receive Header Length. Length of header used if packet handler is enabled for TX/RX (enpactx/rx). Headers are transmitted/received in descending order.
        000 - NoTX/RX header
        001 -  Header 3
        010 -  Header 3 and 2
        011 -  Header 3 and 2 and 1
        100 -  Header 3 and 2 and 1 and 0
        fixpklen = Fix Transmit/Receive Packet Length.  When fixpklen = '1' the packet length (pklen[7:0]) is not included in the header. When fixpklen = '0' the packet length is included in the header.
        synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00 -  Synchronization Word 3
        01 -  Synchronization Word 3 and 2
        10 -  Synchronization Word 3 and 2 and 1
        11 -  Synchronization Word 3 and 2 and 1 and 0
        prealen[8] = MSB of Preamble Length. See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register  corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = '000001000'  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = '111111111' which corresponds to a 255 Bytes Preamble. Writing '0' will have the same result as if writing '1', which will send one single nibble of preamble.</Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description>
        preath[4:0] = Number of nibbles processed during detection.
        rssi_offset[2:0] = Value added as offset to RSSI calculation. Every increment in this register results in an increment of +4dB in the RSSI.
      </Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] - Packet Length.  The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = '00001000' corresponds to a packet length of 8 Bytes.  The maximum packet length is pklen[7:0] = '11111111', a 255 byte packet. Writing '0' is possible, in this case we do not send any data in the packet. During RX, if fixpklen = 1, this will specify also the Packet Length for RX mode.</Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>chhd[31:24] = Check Header 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>chhd[23:16] = Check Header 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>chhd[15:8] = Check Header 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>chhd[7:0] = Check Header 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>hden[31:24] = Header Enable 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>hden[23:16] = Header Enable 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>hden[15:8] = Header Enable 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>hden[7:0] = Header Enable 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>rxhd[31:24] = Received Header 3. 4th byte of the received header.</Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>rxhd[23:16] = Received Header 2. 3rd byte of the received header.</Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>rxhd[15:8] = Received Header 1. 2nd byte of the received header.</Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>rxhd[7:0] = Received Header  0. 1st byte of the received header.</Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>rxplen[7:0] = This register specifies the number of Data bytes in the last received packet, and reflects the value of the packet length byte in the received header. This is relevant ONLY if the fixpklen bit D3 of Reg 33h is cleared. If the fixpklen bit is set, then the expected number of received Data bytes must be programmed into the pklen[7:0] field in Reg 3Eh.</Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description>ADC8 Control bits =</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>
        atb[4:0] = Analog Test Bus.  The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
        Internal analog signals available on the Analog Test Bus:
        Atb/addr[4:0]
        hex
        ATBp / GPIOx
        ATBn / GPIOx
        0
        0
        1
        1
        MixIp
        MixIn
        2
        2
        MixQp
        MixQn
        3
        3
        PGA_Ip
        PGA_In
        4
        4
        PGA_Qp
        PGA_Qn
        5
        5
        vcmout
        vbn
        6
        6
        refmid
        vbiasp
        7
        7
        ADC_vcm
        ADC_vcmb
        8
        8
        ADC_ipoly10
        ADC_ref
        9
        9
        RefADC_p
        RefADC_m
        10
        A
        ADC_Res1Ip
        ADC_Res1In
        11
        B
        ADC_Res1Qp
        ADC_Res1Qn
        12
        C
        ADC_Res2Ip
        ADC_Res2In
        13
        D
        ADC_Res2Qp
        ADC_Res2Qn
        14
        E
        ADC_Res3Ip
        ADC_Res3In
        15
        F
        ADC_Res3Qp
        ADC_Res3Qn
        16
        10
        NC
        NC
        17
        11
        ADC_Cal_Ucap
        ADC_Cal_Ures
        18
        12
        I_CP_test
        PLL_IBG_05
        19
        13
        PLL_VBG
        VSS_VCO
        20
        14
        Vctrl_Test
        PLL_IPTAT_05
        21
        15
        PA_Vbias
        NC
        22
        16
        DIGBG
        DIGVFB
        23
        17
        IFBG
        IFVFB
        24
        18
        PLLBG
        PLLVREG
        25
        19
        IBias_10u
        IBias_5u
        26
        1A
        CLK_65K_Out
        AVSS
        27
        1B
        ADC8_VIN
        ADC8_VDAC
        28
        1C
        LBDcomp
        LBDcompref
        29
        1D
        TSBG
        TSVtemp
        30
        1E
        RFBG
        RFVREG
        31
        1F
        VCOBG
        VCOVREG
      </Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>
        ensctest = Scan Test Enable. When set to '1' then GPIO0 will be the ScanEn input.
        dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
        Internal digital signals available on the Digital Test Bus:
        dtb[4:0]
        GPIO0
        Signal
        GPIO1
        Signal
        GPIO2
        Signal
        0
        wkup_clk_32k
        wake-up 32kHz clock
        rbase_en
        first divided clock
        clk_base
        timebase clock
        1
        wkup_clk_32k
        wake-up 32kHz clock
        wake_up
        wake-up event
        tm1sec
        1 sec timebase
        2
        ts_adc_en
        aux. ADC enable
        adc_rdy_n
        aux. ADC conversion ready
        adc_done
        aux. ADC measurement done
        3
        cont_lbd
        low battery continouos mode
        lbd_on
        low battery ON signal
        lbd
        unfiltered output of LBD
        4
        div_clk_g
        gated divided clock
        uc_clk
        microcontroller clock
        ckout_rcsel
        slow clock selected
        5
        en_div_sync
        clock divider enable (sync'ed)
        en_ckout
        clock out enable
        en_ckout_s
        clock out enable (sync'ed)
        6
        osc30_en
        oscillator enable
        osc30_bias2x
        oscillator bias control
        xok
        chip ready
        7
        xok
        chip ready
        zero_cap
        cap. load zero
        osc30_buff_en
        buffer enable
        8
        tsadc_needed
        aux. ADC enable
        ext_retran
        ext. retransmission request
        tx_mod_gpio
        TX modulation inpit
        9
        gpio_0_oen_n
        GPIO0 output enable
        gpio_0_aen
        GPIO0 analog selection
        gpio_0_aden
        GPIO0 ADC input line enable
        10
        int_ack1
        interrupt acknowledge 1
        int_ack2
        interrupt acknowledge 2
        int_store
        interrupt latch closed
        11
        ext_int2
        ext. interrupt from GPIO2
        irq_bit8
        combined external status
        msk_bit8
        combined masked ext. int.
        12
        sdo_aux_sel
        SDO aux. function select
        sdo_aux
        SDO aux. signal
        nirq_aux_sel
        nIRQ aux. function select
        13
        trdata_on_sdi
        TX/RX data on SDI
        tx_mod
        TX modulation input
        tx_clk_out
        TX clock output
        14
        start_full_sync
        RC osc. full calibration start
        start_fine_sync
        RC osc. fine calibration start
        xtal_req
        crystal req. for RC osc. cal.
        15
        coarse_rdy
        RC osc. coarse cal. ready
        fine_rdy
        RC osc. fine cal. ready
        xtal_req_sync
        sync'ed crystal request
        16
        vco_cal_rst_s_n
        VCO calibration reset
        vco_cal
        VCO calibration is running
        vco_cal_done
        VCO calibration done
        17
        vco_cal_en
        VCO calibration enable
        en_ref_cnt
        reference counter enable
        en_freq_cnt_s
        frequency counter enable
        18
        vco_cal_en
        VCO calibration enable
        pos_diff
        positive difference to goal
        en_freq_cnt_s
        frequency counter enable
        19
        dsm_clk_mux
        DSM multiplexed clock
        pll_fb_clk_tst
        PLL feedback clock
        pll_ref_clk_tst
        PLL reference clock
        20
        dsm[0]
        delta-sigma output
        dsm[1]
        delta-sigma output
        dsm[2]
        delta-sigma output
        21
        dsm[3]
        delta-sigma output
        pll_fbdiv15
        dsm_rst_s_n
        delta-sigma reset
        22
        pll_en
        PLL enable: TUNE state
        pllt0_ok
        PLL initial settling OK
        pllts_ok
        PLL soft settling OK
        23
        ch_freq_req
        frequency change request
        pllts_ok
        PLL soft settling OK
        vco_cal_done
        VCO calibration done
        24
        vco_cal_en
        VCO calibration enable
        pll_vbias_shunt_en
        VCO bias shunt enable
        prog_req
        frequency recalculation req.
        25
        bandgap_en
        bandgap enable
        frac_div_en
        fractional divider enable
        buff3_en
        buffer3 enable
        26
        pll_pfd_up
        PFD up signal
        pll_pfd_down
        PFD down signal
        pfd_up_down
        PFD output change (XOR'ed)
        27
        pllts_ok
        PLL soft settling OK
        pll_en
        PLL enable: TUNE state
        pllt0_ok
        PLL initial settling OK
        28
        i_if_shift_n
        IF Shift indication
        i_vco_cal
        VCO Cal is in progress
        i_tx_en
        Active TX indication
        29
        pwst[0]
        internal power state
        pwst[1]
        internal power state
        pwst[2]
        internal power state
        Internal digital signals available on the Digital Test Bus (continued from the previous page):
        dtb[4:0]
        GPIO0
        Signal
        GPIO1
        Signal
        GPIO2
        Signal
        30
        xok
        chip ready: READY state
        pll_en
        PLL enable: TUNE state
        tx_en
        TX enable: TX state
        31
        ts_en
        temperature sensor enable
        auto_tx_on
        automatic TX ON
        tx_off
        TX OFF
        32
        ch_freq_req
        frequency change request
        return_tx
        return from TX
        pk_sent
        packet sent
        33
        retran_req
        retransmission request
        tx_ffpt_store
        TX FIFO pointer store
        tx_ffpt_restore
        TX FIFO pointer restore
        34
        pa_on_trig
        PA ON trigger
        dly_5us_ok
        5 us delay expired
        mod_dly_ok
        modulator delay expired
        35
        tx_shdwn
        TX shutdown
        ramp_start
        modulator ramp down start
        ramp_done
        modulator ramp down ended
        36
        pk_sent_dly
        delayed packet sent
        tx_shdwn_done
        TX shutdown done
        pa_ramp_en
        PA ramp enable
        37
        tx_en
        TX enable: TX state
        ldo_rf_precharge
        RF LDO precharge
        pa_ramp_en
        PA ramp enable
        38
        pa_on_trig
        TX enable: TX state
        dp_tx_en
        packet handler (TX) enable
        mod_en
        modulator enable
        39
        reg_wr_en
        register write enable
        reg_rd_en
        register rdead enable
        addr_inc
        register address increment
        40
        dp_tx_en
        packet handler (TX) enable
        data_start
        start of TX data
        pk_sent
        packet has been sent
        41
        data_start
        start of TX data
        tx_out
        packet handler TX data out
        pk_sent
        packet has been sent
        42
        ramp_done
        ramp is done
        data_start
        start of TX data
        pk_tx
        packet is being transmitted
        43
        tx_ffaf
        TX FIFO almost full
        tx_fifo_wr_en
        TX FIFO write enable
        tx_ffem_tst
        internal TX FIFO empty
        44
        clk_mod
        modulator gated 10MHz clock
        tx_clk
        TX clock from NCO
        rd_clk_x8
        read clock = tx_clk / 10
        45
        mod_en
        modulator enable
        ramp_start
        start modulator ramping down
        ramp_done
        modulator ramp done
        46
        data_start
        data input start from PH
        ook_en
        OOK modulation enable
        ook (also internal PN9)
        OOK modulation
        47
        prog_req
        freq. channel update request
        freq_err
        wrong freq. indication
        dsm_rst_s_n
        dsm sync. reset
        48
        mod_en
        modulator enable
        tx_rdy
        TX ready
        tx_clk
        TX clock from NCO
        49
        dp_rx_en
        packet handler (RX) enable
        prea_valid
        valid preamble
        pk_srch
        packet is being searched
        50
        pk_srch
        packet is being searched
        sync_ok
        sync. word has been detected
        rx_data
        packet handler RX data input
        51
        pk_rx
        packet is being received
        sync_ok
        sync. word has been detected
        pk_valid
        valid packet received
        52
        sync_ok
        sync. word has been detected
        crc_error
        CRC error has been detected
        hdch_error
        header error detected
        53
        direct_mode
        direct mode
        rx_ffaf
        RX FIFO almost full
        rx_fifo_rd_en
        RX FIFO read enable
        54
        bit_clk
        bit clock
        prea_valid
        valid preamble
        rx_data
        demodulator RX data output
        55
        prea_valid
        valid preamble
        prea_inval
        invalid preamble
        ant_div_sw
        antenna switch (algorythm)
        56
        sync_ok
        sync. word has been detected
        bit_clk
        bit clock
        rx_data
        demodulator RX data output
        57
        prea_valid
        Valid preamble
        Rx_dout
        demodulator data out
        ook_rawd
        Demodulator ook raw data out
        58
        prea_valid
        valid preamble
        bcr_error
        BCR error found
        PM_rst
        Preamble detector reset
        59
        agc_smp_clk
        AGC sample clock
        win_h_tp
        window comparator high
        win_l_tp
        window comparator low dly'd
        60
        prea_valid
        valid preamble
        Afc_out_band
        AFC is out of Band
        Pm_restart
        Restart signal for the Preamble detection
        61
        ldc_on
        active low duty cycle
        pll_en
        PLL enable: TUNE state
        rx_en
        RX enable: RX state
        62
        ldc_on
        active low duty cycle
        no_sync_det
        no sync word detected
        prea_valid
        valid preamble
        63
        adc_en
        ADC enable
        adc_refdac_en
        ADC reference DAC enable
        adc_rst_n
        combined ADC reset
      </Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="DF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldoramp en" />
      <Bit index="6" name="txmodly[2]" />
      <Bit index="5" name="txmodly[1]" />
      <Bit index="4" name="txmodly[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>
        ldorampen = Enable the ramp of the PA LDO in conjunction with the PA vbias ramp. Default =1 If this bit is SET, then the digital output named o_ldo_rf_tx will go high during TX and work normally. If this bit is LOW, then o_ldo_rf_tx will be low at all times.
        txmoddly[2:0] = TX Modulation ON/OFF Delay. The time delay between PA enable and the start of the TX modulation to allow for PA ramp-up, and also the time between Pa shut down to the end of the transmission to allow for PA ramp-down.  It can be set from 0 us to 28 us in 4 us steps.  During transmission start, writing 0 or 1 will yield 4 us (same setting).
        ldoramp[1:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00 - 5 us
        01 - 10 us
        10 - 15 us
        11 - 20 us
        txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00 -  5 us
        01 -  10 us
        10 -  15 us
        11 -  20 us
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="  52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>
        pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 us and 310 us, in 10 us intervals. The default plltime  corresponds to 100 us. See formula above.
        pllt0 = PLL Settling Time (TO). This register will set the time allowed for initial wakeup and settling of the PLL and associated bias circuitry. The value is configurable between 0 us and 70 us, in 10 us steps. The default pllt0 corresponds to 20 us. See formula above.
      </Description>
    </Register>
    <Register address="54" name="PA Boost" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="paduty [1]" />
      <Bit index="4" name="paduty [0]" />
      <Bit index="3" name="ldoramplvl[1]" />
      <Bit index="2" name="ldoramplvl[0]" />
      <Bit index="1" name="ldo_pa_boost" />
      <Bit index="0" name="pa_vbias_boost" />
      <Description>
        Reserved
        Pa duty = will shift the duty cycle of the PA driver to improve efficiency.
        Ldo Ramp Lvl = will change the starting ramp voltage for the PA LDO to control the modulation depth
        LDO_PA_BOOST
        PA_VBIAS_BOOST
      </Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        xtalstarthalf = If set, the Xtal wake time period is halved.
        adccaldone = Delta-sigma ADC Calibration Done. Reading this bit gives '1' if the calibration process has been finished.
        enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to '1' then the RC oscillator performs fine calibration in every app. 30 s.
        rccal = RC Calibration Force. If setting rccal='1' will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a '0' to '1' will initiate the calibration. This bit is cleared automatically.

        vcocal = VCO Calibration Force.  If in Tune Mode ( pllon='1'), setting vcocal='1' will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        skipvco = Skip VCO Calibration. Setting skipvco='1' will prevent the VCO calibration from happening.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="oscdeten" />
      <Bit index="3" name="rssimasel" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>
        bcrfbyp = If set, BCR phase compensation will be bypassed.
        slicfbyp = If set,slicer phase compensation will be bypassed.
        dttype = Dithering Type: If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add +1/-1.
        oscdeten  = If low, the ADC Oscillation Detection mechanism is allowed to work. If set, we disable the function.
        rssimasel  = Number of taps for moving average filter during RSSI evaluation, except during Antenna Diversity. Allows for  reduced noise variation on measured RSSI value but with slower update rate. If high (1), filter tap length = 8*Tb. If low (0 = default), filter tap length = 4*Tb.
        refclksel = Delta-sigma Reference 10 MHz Clock Source Selection (1: PLL Ref clock, 0: FeedBack divider clock)
        refclkinv = Delta-sigma Reference Clock Inversion enable
        distogg = If reset, the discriminator toggling is disabled.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdctristate" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>
        pfdrst = Direct control to analog.
        fbdiv_rst = Direct control to analog
        cpforceup = Charge Pump Force Up
        cpforcedn = Charge Pump Force Down
        cdctristate = Charge Pump DC
        cdcurr[2:0] = Charge Pump DC Current selection
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>
        cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        cpcorrov = Charge Pump Correction Override enable
        cpcorr[4:0] = Charge Pump Correction value
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcor boosten" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        txcorboosten = If this is set, then vcocorr (reg 5A[5:2]) = 1111 during TX mode and VCO CAL followed by TX.
        fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
        d3trim[1:0] = Divider 3 Current Trim value
        d2trim[1:0] = Divider 2 Current Trim value
        d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcur boosten" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        txcurboosten = If this is set, then vcocur = 11 during TX mode and VCO CAL followed by TX.
        vcocorrov = VCO Current Correction override
        vcocorr[3:0] = VCO Current Correction value
        vcocur[1:0] = VCO Current Trim value
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>
        vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov='0' the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov='1' the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives '1' if the calibration process has been finished.
        vcocal[6:0] = VCO Calibration Results
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="1'b0" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>
        dsmdt = Enable DSM ditherting. If low, dithering is disabled.
        read 1'b0
        enoloop = Open Loop Mode enable
        dsmod = Delta-Sigma Modulus
        0 - 64000 1 - 63997
        dsorder[1:0] = Delta-Sigma Order
        00 -  0 order
        01 -  1st order
        10 -  2nd order
        11 -  Mash 111
        dsrstmode = Delta-Sigma Reset Mode
        dsrst = Delta-Sigma Reset
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>
        enmix = Mixer enable override
        enlna = LNA enable override
        enpga = PGA enable override
        enpa = Power Amplifier enable override
        enbf5 = Buffer 5 enable override
        endv32 = Divider 3_2 enable override
        enbf12 = Buffer 1_2 enable override
        enmx2 = Multiplexer 2 enable override
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="en_rftx_ldo" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>
        ends = Delta-Sigma enable override
        en LDO RF Tx = If set, the LDO RF TX is forced on.
        enmx3 = Mutiplexer 3 enable override
        enbf4 = Buffer 4 enable override
        enbf3 = Buffer 3 enable override
        enbf11 = Buffer 1_1 enable override
        enbf2 = Buffer 2 enable override
        pllreset = PLL reset enable override
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>
        enfrdv = Fractional Divider enable override
        endv31 = Divider 3_1 enable override
        endv2 = Divider 2 enable override
        endv1p5 = Divider 1.5 (div-by-1.5) enable override
        dvbshunt = VCO Bias Shunt enable override mode.
        envco = VCO enable override
        encp = Charge Pump enable override
        enbg = Bandgap enable override
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="A0" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Inv_pre_th [3]" />
      <Bit index="6" name="Inv_pre_th [2]" />
      <Bit index="5" name="Inv_pre_th [1]" />
      <Bit index="4" name="Inv_pre_th [0]" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>
        Invalid_preamble_threshold[3:0] = This configures (in nibbles) for how long we will search for preamble. If during this time, the preamble is not detected, we will send a signal (which can be configured as interrupt) and restart looking for the preamble again.
        The interval between each interrupt is given by the formula below.
        chfiladd[3:0] = Channel Filter Coefficient Look-up Table Address. The address for channel filter coefficients used in the RX path.
        Invalid preamble will be evaluated during this period:  (invalid_preamble_Threshold *4 ) * Bit Rate period.
      </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>chfilval[5:0] = Filter Coefficient Value in the look-up table addressed by the chfiladd[3:0]</Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        pwst[2:0] = Internal Power States of the chip
        000 - low power (stand-by / sleep / sensor)
        001 - ready
        011 - tune
        010 - TX
        111 - RX
        clkhyst = Clock Hysteresis Setting
        enbias2x = 2 times higher bias current enable
        enamp2x = 2 times higher amplification enable
        bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
        0 - output buffer is controlled by the state machine
        1 - output buffer is controlled by the enbuf bit
        enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>
        rccov = RC Oscillator Coarse Calibration Override. When rccov='0' the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov='1' the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>
        rcfov = RC Oscillator Fine Calibration Override. When rcfov='0' the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov='1' the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>
        enspor = Smart POR enable
        enbias = Bias enable
        envcoldo = VCO LDO enable
        enifldo = IF LDO enable
        enrfldo = RF LDO enable
        enpllldo = PLL LDO enable
        endigldo = Digital LDO enable
        endigpwdn = Digital Power Domain Powerdown enable in Idle mode
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="0" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>
        enovr = Enable Overrides (If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks).
        enxtal = Xtal override enable value.
        ents = temperature sensor enable.
        enrc32 = 32K oscillator enable.

        diglvl = digital LDO level setting
      </Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="1F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>
        adcrst = delta-sigma ADC reset
        enrefdac = delta-sigma ADC reference DAC enable override
        enadc = delta-sigma ADC enable override
        adctuneovr = resonator RC calibration value override enable
        adctune[3:0] = resonator RC calibration value
      </Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adcwdog" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>
        ADC wdog = ADC Watch dog enable (active high).
        envcm = delta-sigma ADC VCM enable override
        adcoloop = delta-sigma ADC open loop enable
        adcref[2:0] = delta-sigma ADC reference voltage
        000 - 0.5 V
        001 - 0.6 V
        010 - 0.7 V
        ...
        111 - 1.2 V
      </Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sgin" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>
        sgin = AGC stop increasing gain override bit (active low). When '0' (default), AGC gain increases during signal reductions are prevented. When '1', AGC gain increases during signal reductions are allowed. Only effective during Preamble, prior to detection of PREAMBLE_VALID signal.
        agcen = Automatic Gain Control enable When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
        lnagain = LNA Gain select
        0 - min. gain = 5 dB 1 -max. gain = 25 dB
        pga[3:0] = PGA Gain Override value
        000 - 0 dB
        001 - 3 dB
        010 - 6 dB
        ...
        101 - 24 dB max.
      </Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="agcovpkt" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>
        agcovpkt  = If '1' (default), AGC function operates over the entire packet. If '0', the full AGC function operates only during Preamble; gain increases over remainder of packet are  not allowed. Gain reductions (in the event of signal level increases) are always allowed.
        agcslow = AGC Slow Gain Increase enable. When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
        lnacomp[3:0] = LNA Gain Compensation, used for smoothing RSSI value when LNA gain is switched.
        pgath[1:0] = window comparator reference voltage adjust in the PGA
      </Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000 -  i_coe0 (Default =d1)
        001 -  i_coe1 (Default =d3)
        010 -  i_coe2 (Default =d6)
        011 -  i_coe3 (Default =d10)
        100 -  i_coe4 (Default =d15)
        101 -  i_coe5 (Default =d19)
        110 -  i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="papeak val" />
      <Bit index="6" name="papeak en" />
      <Bit index="5" name="papeaklvl[1]" />
      <Bit index="4" name="papeaklvl[0]" />
      <Bit index="3" name="lna_sw" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>
        papeakval - PA Peak Detector Value Read only Register
        Reading a 1 in this register when peapeken=1 means the PA drain voltage is too high and the match network needs adjusting for optimal efficiency.
        papeaken  - PA Peak Detector Enable (direct from register) default =0
        papeaklvl[1:0]  - PA Peak Detect Level (direct from Register)
        00=6.5
        01=7
        10=7.5
        11=8
        (01 =  default )
        lna_sw  - LNA Switch Controller
        This bit determines when internal MOS switches at the LNA input(s) are closed. When lna_sw = 0, these switches are always open. When lna_sw = 1, these switches are closed in TX mode and open at all other times. This bit MUST be set for proper operation in any Direct Tie application.
        txpow[2:0] - TX output Power
        The output power is configurable from +13 dBm to -8 dBm (Si4430/31), and from +20 dBm to -1 dBm (Si4432) in ~3 dB steps.
        txpow[2:0] = 000 corresponds to min output power, and txpow[2:0] = 111 corresponds to max output power.
      </Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="3D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txdtrtscale" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        txdtrtscale = This bit should be set for data rates below 30 [kbps].
        enphpwdn = If set, the Packet Handler will be powered down when chip is in low power mode.
        manppol = Manchester Preamble Polarity (will transmit a series of '1' if set, or series of '0' if reset). This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester mode is enabled.
        enmaninv = Manchester Data Inversion is enabled if this bit is set.
        enmanch = Manchester Coding is enabled if this bit is set.
        enwhite = Data Whitening is enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        trclk[1:0] = TX/RX Data Clock Configuration.
        00 - No TX Data CLK is available (asynchronous mode - Can only work with modulations FSK or OOK)
        01 - TX Data CLK is available via the GPIO (one of the GPIO's should be programmed as well)
        10 - TX/RX Data CLK is available via the SDO pin
        11 - TX/RX Data CLK is available via the nIRQ pin
        dtmod[1:0] = Data Source
        00 -  Direct Mode using TX_Data function via the GPIO pin (one of the GPIO's should be  programmed accordingly as well)
        01 -  Direct Mode using TX_Data function via the SDI pin (only when nSEL is high), or RX Data out during RX.
        10 -  FIFO Mode
        11 -  PN9 (internally generated)
        eninv = Invert TX and RX Data
        fd[8]  = See register 72h
        modtyp[1:0] = Modulation Type
        00 - Unmodulated carrier
        01 - OOK
        10 - FSK
        11 - GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>
        fd[7:0] = Frequency Deviation Setting. See formula above. (please see note below)
        Note: It's recommended to use modulation index of 1 or higher (maximum allowable modulation index is 62). The modulation index is defined by
      </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>fo[7:0] = Frequency Offset Setting. Values written to it will be used during TX, and during RX if AFC is disabled.</Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>fo[9:8] = Upper bits of the Frequency Offset Setting. fo[9] is the sign bit. Values written to it will be used during TX, and during RX if AFC is disabled.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        sbsel = Side Band Select.
        hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-960MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
        fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]='00000' corresponds to the 240-250MHz Band for hbsel='0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0]='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="78" name="Misc. Settings" size="8" defaultVal="19" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txantval" />
      <Bit index="6" name="txant" />
      <Bit index="5" name="fmshft" />
      <Bit index="4" name="ifintcen" />
      <Bit index="3" name="Alt PA Seq" />
      <Bit index="2" name="rcosc[2]" />
      <Bit index="1" name="rcosc[1]" />
      <Bit index="0" name="rcosc[0]" />
      <Description>
        Readout ONLY: Current TX antenna value.
        TX antenna: If set, TX will no longer use the antenna selected during a previous RX.
        FM IF SHIFT = If set, we enable double If shift during RX VCO Cal.
        ifintc Enable = enable for the inner IF LDO switch.
        Alternative PA sequencing = If set, we will enable the alternative PA sequence.
        rcosc_cal[2:0] = fine changes on the RC OSC Calibration target frequency, to help compensate for 'calibration biases'. This register should not be changed by costumers.
      </Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7B" name="Turn Around and 15.4" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="15.4 Lenght" />
      <Bit index="6" name="txfrequpdt" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="turn_around_en" />
      <Bit index="1" name="Phase[1]" />
      <Bit index="0" name="Phase[0]" />
      <Description>
        15.4 Packet Length compliance If set, then PK Length definition for both TX and RX will also include the CRC bytes, If reset, then the Length refers ONLY to the DATA payload. For example, writing '9' to this register when it is set, means we are sending/expecting '7' bytes of DATA, and the other '2' should be the CRC (CRC should be enabled separately).
        txfrequpdt = If low, we enable a frequency update right after VCO CAL is done, when entering a TX state.
        reserved
        Turn Around Enable Enabling for the turn around functionality.
        Turn Around phase The RX to TX change in frequency will happen (if bit [2] is set) at the last byte, and these two registers set the bit position in which the frequency shifts should occur. Make sure it does not happen to early otherwise the last bits will be missed.
      </Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold</Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>rxafthr[5:0] = RX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        fifod[7:0] = A write (R/W='1') to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH. A Read (R/W='0') to this address will begin a burst read of the RX FIFO, in the same manner.
        11/11/2011   Silicon Labs Inc.    Confidential 47/51
        Current for CHIP revision: EZRadioPRO (B1)      Doc Version: 1.92
        EZRadioPRO (B1)  ISM Preliminary
        Current for CHIP revision: EZRadioPRO (B1)
        11/11/2011 Silicon Labs Inc.   Confidential 1/46
        Current for CHIP revision: EZRadioPRO (B1)      Doc Version: 1.92
      </Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="26" type="Si4432" revision="B2" projectID="0" name="Ara 4430-31-32_B2">
    <TxPufferSize>0</TxPufferSize>
    <RxPufferSize>0</RxPufferSize>
    <TxPufferAddress>0</TxPufferAddress>
    <RxPufferAddress>0</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        dt[4:0] = Device Type Code. This internally hardwired code identifies the type or family of chip.
        EZRadioPRO devices = 01000 = 08h.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="06" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>vc[4:0] = Version Code. This internally hardwired code identifies the chip revision. For EZRadioPRO devices, V2 revision = 00010 = 02h, A0 revision = 00100 = 04h,  B1 revision = 00110 = 06h.</Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="freqerr" />
      <Bit index="2" name="1'b0" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>
        ffovfl = RX/TX FIFO Overflow status.
        ffunfl = RX/TX FIFO Underflow status.
        rxffem = RX FIFO Empty status.
        headerr = Header Error status. The actual received packet has a header check error.
        freqerr = Frequency Error status. The programmed frequency is outside of the operating range. The actual frequency is saturated to the max/min value.
        read 1'b0
        cps[1:0] = Chip Power State:
        00 - Idle State
        01 - RX State
        10 - TX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>
        ifferr = FIFO Underflow/Overflow Error.  When set to '1' the TX or RX FIFO has overflowed or underflowed.
        itxffafull = TX FIFO Almost Full.  When set to '1' the TX FIFO has met its almost full threshold and needs to be transmitted.
        itxffaem= TX FIFO Almost Empty.  When set to '1' the TX FIFO is almost empty and needs to be filled.
        irxffafull = RX FIFO Almost Full.  When set to '1' the RX FIFO has met its almost full threshold and needs to be read by the microcontroller
        iext = External Interrupt. When set to '1' an interrupt occurred on one of the GPIO's if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        ipksent = Packet Sent Interrupt. When set to'1' a valid packet has been transmitted.
        ipkvalid =  Valid Packet Received. When set to '1' a valid packet has been received.
        icrcerror = CRC Error. When set to '1' the cyclic redundancy check is failed.
        When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
        Bit
        Status Name
        Set/Clear conditions:
        [7]
        ifferr
        Set if there is a TX or RX FIFO Overflow or Underflow condition.  It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
        [6]
        itxffafull
        Will be set when the number of bytes written to the TX FIFO is greater than the TX Almost Full Threshold set in SPI Reg 7Ch.  It is automatically cleared when a sufficient number of bytes have been read from the TX FIFO and transmitted, such that the remaining number of bytes in the TX FIFO is less than or equal to the TX Almost Full Threshold.
        [5]
        itxffaem
        Will be set when the number of bytes remaining for transmission in the TX FIFO is less than or equal to the TX Almost Empty Threshold set in SPI Reg 7Dh.  It is automatically cleared when a sufficient number of bytes have been written to the TX FIFO, such that the number of data bytes not yet transmitted is above the TX Almost Empty Threshold.  Update of this status flag requires a clock from the internal TX domain circuitry, and thus may not indicate accurately until TX mode is entered.
        [4]
        irxffafull
        Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the RX Almost Full threshold set in SPI Reg 7Eh.  It is automatically cleared when a sufficient number of bytes are read from the RX FIFO, such that the remaining number of bytes in the RX FIFO is below the RX Almost Full Threshold.  Update of this status flag requires a clock from the internal RX domain circuitry, and thus may not indicate accurately until RX mode is entered.
        [3]
        iext
        External interrupt source
        [2]
        ipksent
        Will be set upon complete transmission of a packet (no TX abort).  This status will be cleared if 1) The chip is commanded to leave FIFO mode, or 2) While the chip is in FIFO mode a new transmission is started.  Packet Sent functionality remains available even if the TX Packet Handler (enpactx bit D3 in SPI Reg 30h) is not enabled, as it is possible construct and send an entire packet from the FIFO without making use of the Packet Handler.
        [1]
        ipkvalid
        Will be set upon full and correct reception of a packet (no RX abort).  It is not automatically cleared by simply re-entering RX mode, but is only cleared upon detection of a valid Sync Word in the next RX packet.  Packet Valid functionality is not available if the RX Packet Handler (enpacrx bit D7 in SPI Reg 30h) is not enabled.
        [0]
        icrcerror
        Will be set if the CRC computed during RX differs from the CRC sent in the packet by the TX.  It is cleared upon start of data reception in a new packet.  CRC functionality is not available if the RX Packet Handler (enpacrx bit D7 in SPI Reg 30h) is not enabled.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        iswdet = Sync Word Detected. When a sync word is detected this bit will be set to 1.
        ipreaval = Valid Preamble Detected. When a preamble is detected this bit will be set to 1.
        ipreainval = Invalid Preamble Detected. When the preamble is not found within a period of time after the RX is enabled, this bit will be set to 1.
        irssi = RSSI. When RSSI level exceeds the programmed thershold this bit will be set to 1.
        iwut = Wake-Up-Timer. On the expiration of programmed wake-up timer this bit will be set to 1.
        ilbd = Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        ichiprdy = Chip Ready (XTAL). When a chip ready event has been detected this bit will be set to 1.
        ipor = Power-on-Reset (POR).  When the chip detectes a Power on Reset above the desired setting this bit will be set to 1.
        When does the individual Status bits get Set/Cleared, if not enabled as an Interruptu
        Bit
        Status Name
        Set/Clear conditions:
        [7]
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        [6]
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        [5]
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        [4]
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        [3]
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        [2]
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        [1]
        ichiprdy
        Chip ready goes high once we enable the xtal, Tx or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        [0]
        ipor
        Power on status.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>
        enfferr = Enable FIFO Underflow/Overflow. When set to '1' the FIFO Underflow/Overflow interrupt will be enabled.
        entxffafull = Enable TX FIFO Almost Full. When set to '1' the TX FIFO Almost Full interrupt will be enabled.
        entxffaem = Enable TX FIFO Almost Empty. When set to '1' the TX FIFO Almost Empty interrupt will be enabled.
        enrxffafull = Enable RX FIFO Almost Full. When set to '1' the RX FIFO Almost Full interrupt will be enabled.
        enext = Enable External Interrupt. When set to '1' the External Interrupt will be enabled.
        enpksent = Enable Packet Sent. When ipksent ='1' the Packet Sense Interrupt will be enabled.
        enpkvalid = Enable Valid Packet Received. When ipkvalid = '1' the Valid Packet Received Interrupt will be  enabled
        encrcerror = Enable CRC Error. When set to '1' the CRC Error  interrupt will be enabled.
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        enswdet = Enable Sync Word Detected. When '1' the Sync Word Detected Interrupt will be enabled.
        enpreaval = Enable Valid Preamble Detected. When '1' the Valid Preamble Detected Interrupt will be enabled.
        enpreainval = Enable Invalid Preamble Detected. When '1' the Invalid Preamble Detected Interrupt will be enabled.
        enrssi = Enable RSSI. When set to '1' the RSSI Interrupt will be  enabled.
        enwut = Enable Wake-Up Timer. When set to '1' the Wake-Up Timer  interrupt will be enabled.
        enlbd = Enable Low Battery Detect. When set to '1' the Low Battery Detect interrupt will be enabled.
        enchiprdy = Enable Chip Ready (XTAL). When set to '1' the Chip Ready interrupt will be enabled.
        enpor = Enable POR.  When set to '1' the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        swres = Software Register Reset bit.  This bit may be used to reset all SPI registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register.  The RESET is accomplished by setting swres = '1'.  This bit will be automatically cleared.
        enlbd = Enable Low Battery Detect.  When this bit is set to '1' the Low Battery Detector circuit and threshold comparison will be enabled.
        enwt = Enable Wake-Up-Timer.  When this function will be  enabled when enwt = '1'. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        x32ksel = 32,768 kHz crystal oscillator select. The source of the 32kHz clock is the watch crystal oscillator instead of the RC oscillator if this bit is set.
        txon = TX on in manual transmit mode. It is automatically cleared in FIFO mode once the packet is sent.
        rxon = RX on in manual receiver mode. It is automatically cleared if Multiple Packets config. is disabled and a valid packet received.
        pllon = TUNE Mode (PLL is ON). When pllon = '1' the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        xton = READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="ffclrtx" />
      <Description>
        antdiv[2:0] = Enable Antenna Diversity. The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
        RX/TX state non RX/TX state
        GPIO Ant1 GPIO Ant2 GPIO Ant1 GPIO Ant2
        000 -  1 0 0 0
        001 - 0 1 0 0
        010 -  1 0 1 1
        011 - 0 1 1 1
        100 - antenna diversity algorythm 0 0
        101 -  antenna diversity algorythm 1 1
        110 - ant. div. algorythm in beacon mode 0 0
        111 -  ant. div. algorythm in beacon mode   1 1
        rxmpk = RX Multi Packet. When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the transceiver will automatically leave the RX State after the first valid packet has been received.
        autotx = Automatic Transmission. When autotx = '1' the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.
        enldm = Enable Low Duty Cycle Mode. If this bit is set to '1' then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
        ffclrrx = RX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrrx='1' followed by ffclrrx= '0' will clear the contents of the RX FIFO.
        ffclrtx = TX FIFO Reset/Clear. This has to be a two writes operation: Setting ffclrtx='1' followed by ffclrtx= '0' will clear the contents of the TX FIFO.
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>
        xtalshft = Direct control to Analog
        xlc[6:0] = Tuning Capacitance for the 30MHz XTAL
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        clkt[1:0] = Clock Tail.  If enlfc = '0' then it can be useful to provide a few extra cycles for the microcontroller to complete its operation.  Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00 -  0 cycle
        01 -  128 cycles
        10 -  256 cycles
        11 -  512 cycles
        enlfc = Enable Low Frequency Clock.  When enlfc = '1' and the chip is in Sleep mode then the 32.768kHz clock will be provided to the Microcontroller no matter what the selection of mclk[2:0] is.  For example if mclk[2:0] = '000', 30MHz will be available through the GPIO to output to the Microctroller in all Idle, TX, or RX states.  When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        mclk[2:0] = Microcontroller Clock.  Different clock frequencies may be selected for configurable GPIO clock output.  All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator.  The mclk[2:0] setting is only valid when xton = '1' except the '111'.
        000 -  30 MHz
        001 -  15 MHz
        010 -  10 MHz
        011 -  4 MHz
        100 -  3 MHz
        101 -  2 MHz
        110 -  1 MHz
        111 - 32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        gpiodrv0[1:0] - Gpio driving capability setting
        pup0 = Pull-up Resistor enable on GPIO0. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio0[4:0] = GPIO0pin function select:
        00000 -  Power-On-Reset (output)
        00001 -  Wake-Up Timer: '1' when WUT has expired  (output)
        00010 -  Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 -  Direct Digital Input
        00100 - External Interrupt, falling edge (input)
        00101 -  External Interrupt, rising edge (input)
        00110 -  External Interrupt, state change (input)
        00111 - ADC Analog Input
        01000 - Reserved (Analog Test N Intput)
        01001 - Reserved (Analog Test P Intput)
        01010 - Direct Digital Output
        01011 - Reserved (Digital Test Output)
        01100 - Reserved (Analog Test N Output)
        01101 - Reserved (Analog Test P Output)
        01110 - Reference Voltage (output)
        01111 - TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000 - TX Data input for direct modulation (input)
        10001 - External Retransmission Request (input)
        10010 - TX State (output)
        10011 - TX FIFO Almost Full  (output)
        10100 - RX Data (output)
        10101 - RX State (output)
        10110 - RX FIFO Almost Full  (output)
        10111 - Antenna 1 Switch used for antenna diversity  (output)
        11000 - Antenna 2 Switch used for antenna diversity  (output)
        11001 - Valid Preamble Detected  (output)
        11010 - Invalid Preamble Detected  (output)
        11011 - Sync Word Detected  (output)
        11100 - Clear Channel Assessement  (output)
        11101 - VDD
        else    - GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        gpiodrv1[1:0] - Gpio driving capability setting
        pup1 = Pull-up Resistor enable on GPIO1. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio1[4:0] = GPIO1 pin function select:
        00000 -  Power-On-Reset Inverted (output)
        00001 -  Wake-Up Timer: '1' when WUT has expired  (output)
        00010 -  Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 -  Direct Digital Input
        00100 - External Interrupt, falling edge (input)
        00101 -  External Interrupt, rising edge (input)
        00110 -  External Interrupt, state change (input)
        00111 - ADC Analog Input
        01000 - Reserved (Analog Test N Intput)
        01001 - Reserved (Analog Test P Intput)
        01010 - Direct Digital Output
        01011 - Reserved (Digital Test Output)
        01100 - Reserved (Analog Test N Output)
        01101 - Reserved (Analog Test P Output)
        01110 - Reference Voltage (output)
        01111 - TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000 - TX Data input for direct modulation (input)
        10001 - External Retransmission Request (input)
        10010 - TX State (output)
        10011 - TX FIFO Almost Full  (output)
        10100 - RX Data (output)
        10101 - RX State (output)
        10110 - RX FIFO Almost Full  (output)
        10111 - Antenna 1 Switch used for antenna diversity  (output)
        11000 - Antenna 2 Switch used for antenna diversity  (output)
        11001 - Valid Preamble Detected  (output)
        11010 - Invalid Preamble Detected  (output)
        11011 - Sync Word Detected  (output)
        11100 - Clear Channel Assessement  (output)
        11101 - VDD
        else    - GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        gpiodrv2[1:0] - Gpio driving capability setting
        pup2 = Pull-up Resistor enable on GPIO2. When set to '1' the a 200 kohm resistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        gpio2[4:0] = GPIO2 pin function select:
        00000 - Microcontroller Clock (output)
        00001 -  Wake-Up Timer: '1' when WUT has expired  (output)
        00010 -  Low Battery Detect: '1' when battery is below threshold setting (output)
        00011 -  Direct Digital Input
        00100 - External Interrupt, falling edge (input)
        00101 -  External Interrupt, rising edge (input)
        00110 -  External Interrupt, state change (input)
        00111 - ADC Analog Input
        01000 - Reserved (Analog Test N Intput)
        01001 - Reserved (Analog Test P Intput)
        01010 - Direct Digital Output
        01011 - Reserved (Digital Test Output)
        01100 - Reserved (Analog Test N Output)
        01101 - Reserved (Analog Test P Output)
        01110 - Reference Voltage (output)
        01111 - TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000 - TX Data input for direct modulation (input)
        10001 - External Retransmission Request (input)
        10010 - TX State (output)
        10011 - TX FIFO Almost Full  (output)
        10100 - RX Data (output)
        10101 - RX State (output)
        10110 - RX FIFO Almost Full  (output)
        10111 - Antenna 1 Switch used for antenna diversity  (output)
        11000 - Antenna 2 Switch used for antenna diversity  (output)
        11001 - Valid Preamble Detected  (output)
        11010 - Invalid Preamble Detected  (output)
        11011 - Sync Word Detected  (output)
        11100 - Clear Channel Assessement  (output)
        11101 - VDD
        else    - GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        extitst[2] = External Interrupt Status. If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        extitst[1] = External Interrupt Status. If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        extitst[0] = External Interrupt Status. If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        itsdo = Interrupt Request Output on the SDO Pin. nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        dio2 = Direct I/O for GPIO2. If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        dio1 = Direct I/O for GPIO1. If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        dio0 = Direct I/O for GPIO0. If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart/adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        adcstart / adcdone = Set this bit = 1 starts the ADC measurement process. This bit self-clears during the measurement cycle, and returns high when the measurement is complete. The conversion process is fast; reading this bit may always appear to return a 1.
        adcsel[2:0] = ADC Input Source selection. The internal 8 bit ADC input source can be selected as follows:
        000 - Internal Temperature Sensor
        001 - GPIO0, single-ended
        010 - GPIO1, single-ended
        011 -  GPIO2, single-ended
        100 - GPIO0(+) - GPIO1(-), differential
        101 - GPIO1(+) - GPIO2(-), differential
        110 - GPIO0(+) - GPIO2(-), differential
        111 - GND, ADC is disabled
        adcref[1:0] = ADC Reference Voltage selection. The reference voltage of the internal 8 bit ADC can be selected as follows:
        0X - bandgap voltage (1.2V)
        10 - VDD / 3
        11 -  VDD / 2
        adcgain[1:0] = ADC Sensor Amplifier Gain selection. The full scale range of the internal 8 bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0: adcref[0] = 1:
        FS = 0.014 * (adcgain[1:0] + 1) * VDD  FS = 0.021 * (adcgain[1:0] + 1) * VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>adcoffs[3:0] = ADC Sensor Amplifier Offset. See formula above.</Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>adc[7:0] = Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>
        tsrange[1:0] = Temperature Sensor Range selection (FS range is 0..1024mV)
        00 - -40oC .. 64oC (full operating range), with 0.5oC resolution (1 LSB in the 8 bit ADC)
        01 - -40oC .. 85oC, with 1oC resolution (1 LSB in the 8 bit ADC)
        11 -    0oC .. 85oC, with 0.5oC resolution (1 LSB in the 8 bit ADC)
        10 - -40oF .. 216oF, with 1oF resolution (1 LSB in the 8 bit ADC)
        entsoffs = Temperature Sensor Offset to convert from K to oC.
        entstrim = Temperature Sensor Trim enable
        tstrim[3:0] = Temperature Sensor Trim value
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>
        tvoffs[7:0] = Temperature Value Offset. This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)
        NOTE for registers 14h through 19h: If a new configuration is needed (for example for the WUT, or for the LDC), we require, for proper functionality, that the function be first disabled, then the settings changed, and then enabled back on.
      </Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description>
        wtr[4:0] = Wake Up Timer Exponent (R) value.  See formula above.
        Maximum value for R is decimal 20.   A value greater than 20 will yield a result as if 20 were written.
        R Value = 0 is allowed  to be written here.
      </Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>wtm[15:8] = Wake Up Timer Mantissa (M) value.  See formula above.</Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        wtm[7:0] = Wake Up Timer Mantissa (M) value.  See formula above.
        M[7:0]  = 0 is not valid here. Write at least decimal 1.
      </Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>wtv[15:8] = Wake Up Timer counter Current Mantissa (M) value. (Read only)</Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>wtv[7:0] = Wake Up Timer counter Current  Mantissa (M) value.  (Read only)</Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>
        ldc[7:0] = Low-Duty Cycle Mode Duration (LDC).  See formula above
        If enabled, the LDC will start together when the WUT is supposed to start, and the duration of the LDC is specified by the address 19h above and the equation that goes with it. In order for the LDC to work, the LDC Value above (reg 19h) has to be smaller than the M Value specified in registers 15h and 16h. Also, LDC = 0 is not allowed here, write at least 1.
      </Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>lbdt[4:0] = Low Battery Detector Threshold. This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2V. See formula above.</Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        vbat[4:0] = Battery Voltage Level. The battery voltage is converted by a 5 bit ADC if the LBD bit D6 of Reg 07h is also set. In Sleep Mode the register is updated in every 1 s. In other states it measures continuously.
        The measured voltage is calculated by the following formula:
        Vbat_meas = 1.7[V] + vbat[4:0] x 50 mV.
      </Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>
        dwn3_bypass = Bypass decimator by 3 (if set).
        ndec_exp[2:0] = IF Filter decimation rates
        filset[3:0] = IF Filter coefficient sets ; defauts are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz
        When the required bandwidth (BW) is calculated then the three filter parameters, ndec_exp, dwn3_bypass and filset, can be found from the table below. When the calculated bandwidth value is not exactly available then select the higher available bandwidth closest to the calculated bandwidth.
        BW [kHz]
        ndec_exp
        1C-[6:4]
        dwn3_bypass
        1C-[7]
        filset
        1C-[3:0]
        BW [kHz]
        ndec_exp
        1C-[6:4]
        dwn3_bypass
        1C-[7]
        filset
        1C-[3:0]
        2.6
        5
        0
        1
        41.7
        1
        0
        2
        2.8
        5
        0
        2
        45.2
        1
        0
        3
        3.1
        5
        0
        3
        47.9
        1
        0
        4
        3.2
        5
        0
        4
        56.2
        1
        0
        5
        3.7
        5
        0
        5
        64.1
        1
        0
        6
        4.2
        5
        0
        6
        69.2
        1
        0
        7
        4.5
        5
        0
        7
        75.2
        0
        0
        1
        4.9
        4
        0
        1
        83.2
        0
        0
        2
        5.4
        4
        0
        2
        90.0
        0
        0
        3
        5.9
        4
        0
        3
        95.3
        0
        0
        4
        6.1
        4
        0
        4
        112.1
        0
        0
        5
        7.2
        4
        0
        5
        127.9
        0
        0
        6
        8.2
        4
        0
        6
        137.9
        0
        0
        7
        8.8
        4
        0
        7
        142.8
        1
        1
        4
        9.5
        3
        0
        1
        167.8
        1
        1
        5
        10.6
        3
        0
        2
        181.1
        1
        1
        9
        11.5
        3
        0
        3
        191.5
        0
        1
        15
        12.1
        3
        0
        4
        225.1
        0
        1
        1
        14.2
        3
        0
        5
        248.8
        0
        1
        2
        16.2
        3
        0
        6
        269.3
        0
        1
        3
        17.5
        3
        0
        7
        284.9
        0
        1
        4
        18.9
        2
        0
        1
        335.5
        0
        1
        8
        21.0
        2
        0
        2
        361.8
        0
        1
        9
        22.7
        2
        0
        3
        420.2
        0
        1
        10
        24.0
        2
        0
        4
        468.4
        0
        1
        11
        28.2
        2
        0
        5
        518.8
        0
        1
        12
        32.2
        2
        0
        6
        577.0
        0
        1
        13
        34.7
        2
        0
        7
        620.7
        0
        1
        14
        37.7
        1
        0
        1
      </Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afcbd" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="1p5 bypass" />
      <Bit index="1" name="matap" />
      <Bit index="0" name="ph0size" />
      <Description>
        Afcbd = AFC wide band enable (active high).  If set, the IF filter bandwidth is reduced after preamble detection in order to optimize RX sensitivity.
        The alternate IF filter coefficients must be specified in SPI Reg 60h and 61h; contact Silicon Labs Application Support for details.
        enafc = AFC enable
        afcgearh[2:0] = AFC High Gear Setting. Feedback loop gain during AFC settling process is proportional to 2^(-afcgearh[2:0]).
        1p5bypass = If high (1) select 0dB bias for the second phase antenna selection, if  low (0), select 1.5 dB. The default is (1), selecting 0 dB.
        matap = Number of taps for moving average filter during Antenna Diversity RSSI evaluation. Allows for reduced noise variation on measured RSSI value but with slower update rate. If high (1), filter tap length = 8*Tb. If low (0 = default), filter tap length = 8*Tb prior to first PREAMBLE_VALID, and 4*Tb thereafter.
        ph0size = If low, we will reset the Preamble detector if there are 5 consecutive zero phases. If high, the reset will happen after 3 consecutive zero phases.
      </Description>
    </Register>
    <Register address="1E" name="AFC/ AntDiv Timing Control" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swant_timer[1]" />
      <Bit index="6" name="swant_timer[0]" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="anwait[2]" />
      <Bit index="1" name="anwait[1]" />
      <Bit index="0" name="anwait[0]" />
      <Description>
        swant_timer  = additional number of bit periods to wait for RSSI value to stabilize during Antenna Diversity 2nd phase antenna evaluation. If matap=0, total wait time = 8*Tb+swant_timer[1:0]. If matap=1,total wait time = 12*Tb+swant_timer[1:0]. Effective only during Antenna Diversity.
        shwait[2:0] = short wait periods after AFC correction used before preamble is detected. Short wait = (RegValue+1)*2Tb. If set to '0' then no AFC correction will occur before preamble detect, i.e. AFC will be disabled.
        anwait[2:0] = Antenna switching wait time. Number of bit periods between toggling selection of antennas in AntDiv mode, prior to reception of first PREAMBLE_VALID.
        Number of bit periods = ( anwait[2:0] + 2 ) * 4 +3 (when AFC = enabled)
        Number of bit periods = ( anwait[2:0] + 2 ) * 2 +3 (when AFC = disabled)
        Default value = 3'b010 = 19 bit periods (AFC = enabled).
      </Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>
        crfast[2:0] = Clock Recovery Fast Gearshift value
        crslow[2:0] = Clock Recovery Slow Gearshift value
      </Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>
        rxosr[7:0] = Oversampling Rate, 3 LSBs are the fraction
        default = 0110 0100 = 12.5 clock cycles per data bit
      </Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="skip2phth" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>
        rxosr[10:8] = Oversampling Rate, upper bits
        skip2phth  = threshold for skipping the 2nd phase of RSSI detection during antenna diversity algorithm. 0 = 16 dB (default), 1 = 11 dB.
        NOT RECOMMENDED FOR USER CONFIGURATION.
        ncoff[19:16] = NCO offset. See formula above.
      </Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>ncoff[15:8] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>ncoff[7:0] = NCO offset. See formula above.</Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="rxncocomp" />
      <Bit index="3" name="cgainx2" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>
        rxncocomp = Receive compensation enable for high data rate offset.
        cgainx2 = multiplying the CR gain by two.
        crgain[10:8] = Clock Recovery Timing Loop Gain
      </Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>crgain[7:0] = Clock Recovery Timing Loop Gain</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>rssi[7:0] = Received Signal Strength Indicator value</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="1E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>rssith[7:0] = RSSI Threshold. Interrupt is set if the RSSI value is above this threshold.</Description>
    </Register>
    <Register address="28" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>adrssi1[7:0] = Measured RSSI value on antenna 1</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description>adrssi2[7:0] = Measured RSSI value on antenna 2</Description>
    </Register>
    <Register address="2A" name="AFC Limiter" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Afclim[7]" />
      <Bit index="6" name="Afclim[6]" />
      <Bit index="5" name="Afclim[5]" />
      <Bit index="4" name="Afclim[4]" />
      <Bit index="3" name="Afclim[3]" />
      <Bit index="2" name="Afclim[2]" />
      <Bit index="1" name="Afclim[1]" />
      <Bit index="0" name="Afclim[0]" />
      <Description>
        AFC Limiter[7:0] = AFC limiter value.
        For the following registers (addresses 2Bh and 2Ch), use the following equation:
        where Rb's unit is in  kHz and 'enmanch' is the Manchester Enable bit (found at address 71h bit [1]).
        Therefore, the  minimal data rate that this register can support without Manchester is 0.366 kbps.
      </Description>
    </Register>
    <Register address="2B" name="AFC Correction Read" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[8]" />
      <Bit index="5" name="afc_corr[7]" />
      <Bit index="4" name="afc_corr[6]" />
      <Bit index="3" name="afc_corr[5]" />
      <Bit index="2" name="afc_corr[4]" />
      <Bit index="1" name="afc_corr[3]" />
      <Bit index="0" name="afc_corr[2]" />
      <Description>AFC Correction Values = AFC loop correction values [9:2]  (MSB's only). Values are updated once, after sync word is found during receiving. See also address 2Ch.</Description>
    </Register>
    <Register address="2C" name="OOK Counter Value 1" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="afc_corr[1]" />
      <Bit index="6" name="afc_corr[0]" />
      <Bit index="5" name="ookfrzen" />
      <Bit index="4" name="peakdeten" />
      <Bit index="3" name="madeten" />
      <Bit index="2" name="ookcnt[10]" />
      <Bit index="1" name="ookcnt[9]" />
      <Bit index="0" name="ookcnt[8]" />
      <Description>
        AFC Correction Values = AFC loop correction values [1:0] (LSB's). Values are updated once, after sync word is found during receiving. See also address 2Bh.
        ookfrzen = when '0' (default), AGC and OOK Moving Average Detector threshold operate continuously. When '1', AGC and OOK MA Detector threshold operate until PREAMBLE_VALID signal is detected; values are frozen thereafter. Recommended for use with non-Manchestered payload data.
        peakdeten = when '1' (default), Peak Detector for OOK Modem is enabled. Provides improved performance in presence of co-channel interferers, at slight reduction of sensitivity. Peak Detector output is logically AND'ed with Moving Average Detector output.
        madeten = when '1' (default), Moving Average Detector for OOK Modem is enabled. Provides best sensitivity, but requires DC-balanced data (e.g. Manchester data) and is more sensitive to co-channel interference. Peak Detector output is logically AND'ed with Moving Average Detector output.
        OOK Counter [10:8] = OOK counter Value MSBs. This counter value will affect the OOK AGC's decay time.
      </Description>
    </Register>
    <Register address="2D" name="OOK Counter Value 2" size="8" defaultVal="BC" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ookcnt[7]" />
      <Bit index="6" name="ookcnt[6]" />
      <Bit index="5" name="ookcnt[5]" />
      <Bit index="4" name="ookcnt[4]" />
      <Bit index="3" name="ookcnt[3]" />
      <Bit index="2" name="ookcnt[2]" />
      <Bit index="1" name="ookcnt[1]" />
      <Bit index="0" name="ookcnt[0]" />
      <Description>OOK Counter [7:0] = OOK counter Value LSBs. This counter value will affect the OOK AGC's decay time.</Description>
    </Register>
    <Register address="2E" name="Slicer Peak Hold" size="8" defaultVal="26" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="reserv." />
      <Bit index="6" name="attack[2]" />
      <Bit index="5" name="attack[1]" />
      <Bit index="4" name="attack[0]" />
      <Bit index="3" name="decay[3]" />
      <Bit index="2" name="decay[2]" />
      <Bit index="1" name="decay[1]" />
      <Bit index="0" name="decay[0]" />
      <Description>
        Reserved
        attack[2:0] = OOK Peak Detector attack time. Peak detector value charges up at rate proportional to 2^(-attack[2:0]).  OOK slicing threshold is set 6 dB below peak detector value. Effective only when OOK Peak Detector is enabled.
        decay [3:0] = OOK Peak Detector decay time. Peak detector value discharges at rate proportional to 2^(-decay[3:0]). OOK slicing threshold is set 6 dB below peak detector value. Effective only when OOK Peak Detector is enabled.
      </Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="8D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="skip2ph" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        enpacrx = Enable Packet RX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpacrx='1' will enable automatic packet handling in the RX path. Register 30-4D allow for various configurations of the packet structure. Setting enpacrx='0' will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
        lsbfrst = LSB First enable. The LSB of the data will be transmitted/received first if this bit is set.
        crcdonly = CRC Data Only enable When this bit is set to '1' the CRC is calculated on and check against the packet data fields only.
        skip2ph = If set, we skip the second phase of preamble detection (under certain conditions) if the antenna diversity was enabled.
        enpactx = Enable Packet TX Handling.  If FIFO Mode (dtmod='10') is being used automatic packet handling may be enabled. Setting enpactx='1' will enable automatic packet handling in the TX path. Register 30-4D allow for various configurations of the packet structure. Setting enpactx='0' will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
        encrc = CRC enable. Cyclic Redundancy Check generation is enabled if this bit is set.
        crc[1:0] = CRC polynomial selection.
        00 - CCITT
        01 - CRC-16 (IBM)
        10 - IEC-16
        11 - Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="rxcrc1" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>
        rxcrc1 = If high, it indicates the last CRC received is all one's. May indicated Transmitter underflow in case of CRC error.
        pksrch = Packet Searching. When pksrch = '1' the radio is searching for a valid packet.
        pkrx = Packet Receiving. When pkrx = '1' the radio is currently receiving a valid packet.
        pkvalid = Valid Packet Received. When a pkvalid = '1' a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
        crcerror = CRC Error.  When crcerror = '1' a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
        pktx = Packet Transmitting. When pktx = '1' the radio is currently transmitting a packet.
        pksent = Packet Sent.  A pksent  = '1' a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enbcast[1]" />
      <Bit index="6" name="enbcast[1]" />
      <Bit index="5" name="enbcast[1]" />
      <Bit index="4" name="enbcast[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>
        bcen[3:0] = Broadcast Address (FFh) Check enable.  If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
        0000 - No broadcast address enable.
        0001 - Broadcast address enable for header byte 0.
        0010 - Broadcast address enable for header byte 1.
        0011 - Broadcast address enable for header bytes 0 &amp; 1.
        0100 - ...
        hdch[3:0] = Received Header bytes to be checked against the Check Header bytes.  One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.
        0000 - No Received Header check
        0001 - Received Header check for byte 0.
        0010 - Received Header check for bytes 1.
        0011 - Received header check for bytes 0 &amp; 1.
        0100 - ...
      </Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="skipsyn" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        skipsyn = Skip Sync Word search timeout. If high, the system will ignore the search timeout period when failing to find Sync Word, and will not return to searching for Preamble. Setting this bit does NOT eliminate the search for Sync Word. Proper detection of Sync Word remains necessary in FIFO mode in order to determine the start of the Payload field and to thus store the correct bytes in the RX FIFO.
        hdlen[2:0] = Transmit/Receive Header Length. Length of header used if packet handler is enabled for TX/RX (enpactx/rx). Headers are transmitted/received in descending order.
        000 - NoTX/RX header
        001 -  Header 3
        010 -  Header 3 and 2
        011 -  Header 3 and 2 and 1
        100 -  Header 3 and 2 and 1 and 0
        fixpklen = Fix Transmit/Receive Packet Length.  When fixpklen = '1' the packet length (pklen[7:0]) is not included in the header. When fixpklen = '0' the packet length is included in the header.
        synclen[1:0] = Synchronization Word Length.  The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00 -  Synchronization Word 3
        01 -  Synchronization Word 3 and 2
        10 -  Synchronization Word 3 and 2 and 1
        11 -  Synchronization Word 3 and 2 and 1 and 0
        prealen[8] = MSB of Preamble Length. See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>prealen[7:0] = Preamble Length.  The value in the prealen[8:0] register  corresponds to the number of nibbles (4bits) in the packet.  For example prealen[8:0] = '000001000'  corresponds to a preamble length of 32 bits (8*4bits) or 4 Bytes.  The maximum preamble length is prealen[8:0] = '111111111' which corresponds to a 255 Bytes Preamble. Writing '0' will have the same result as if writing '1', which will send one single nibble of preamble.</Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description>
        preath[4:0] = Number of nibbles processed during detection.
        rssi_offset[2:0] = Value added as offset to RSSI calculation. Every increment in this register results in an increment of +4dB in the RSSI.
      </Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>sync[31:24] = Synchronization Word 3. 4th byte of the synchronization word.</Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>sync[23:16] = Synchronization Word 2. 3rd byte of the synchronization word.</Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>sync[15:8] = Synchronization Word 1. 2nd byte of the synchronization word.</Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>sync[7:0] = Synchronization Word 0. 1st byte of the synchronization word.</Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>txhd[31:24] = Transmit Header 3. 4th byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>txhd[23:16] = Transmit Header 2. 3rd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>txhd[15:8] = Transmit Header 1. 2nd byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>txhd[7:0] = Transmit Header 0. 1st byte of the header to be transmitted.</Description>
    </Register>
    <Register address="3E" name="Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>pklen[7:0] - Packet Length.  The value in the pklen[7:0] register corresponds directly to the number of bytes in the Transmit Packet.  For example pklen[7:0] = '00001000' corresponds to a packet length of 8 Bytes.  The maximum packet length is pklen[7:0] = '11111111', a 255 byte packet. Writing '0' is possible, in this case we do not send any data in the packet. During RX, if fixpklen = 1, this will specify also the Packet Length for RX mode.</Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>chhd[31:24] = Check Header 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>chhd[23:16] = Check Header 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>chhd[15:8] = Check Header 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>chhd[7:0] = Check Header 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>hden[31:24] = Header Enable 3. 4th byte of the check header.</Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>hden[23:16] = Header Enable 2. 3rd byte of the check header.</Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>hden[15:8] = Header Enable 1. 2nd byte of the check header.</Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>hden[7:0] = Header Enable 0. 1st byte of the check header.</Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>rxhd[31:24] = Received Header 3. 4th byte of the received header.</Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>rxhd[23:16] = Received Header 2. 3rd byte of the received header.</Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>rxhd[15:8] = Received Header 1. 2nd byte of the received header.</Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>rxhd[7:0] = Received Header  0. 1st byte of the received header.</Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>rxplen[7:0] = This register specifies the number of Data bytes in the last received packet, and reflects the value of the packet length byte in the received header. This is relevant ONLY if the fixpklen bit D3 of Reg 33h is cleared. If the fixpklen bit is set, then the expected number of received Data bytes must be programmed into the pklen[7:0] field in Reg 3Eh.</Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description>ADC8 Control bits =</Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>
        atb[4:0] = Analog Test Bus.  The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
        Internal analog signals available on the Analog Test Bus:
        Atb/addr[4:0]
        hex
        ATBp / GPIOx
        ATBn / GPIOx
        0
        0
        1
        1
        MixIp
        MixIn
        2
        2
        MixQp
        MixQn
        3
        3
        PGA_Ip
        PGA_In
        4
        4
        PGA_Qp
        PGA_Qn
        5
        5
        vcmout
        vbn
        6
        6
        refmid
        vbiasp
        7
        7
        ADC_vcm
        ADC_vcmb
        8
        8
        ADC_ipoly10
        ADC_ref
        9
        9
        RefADC_p
        RefADC_m
        10
        A
        ADC_Res1Ip
        ADC_Res1In
        11
        B
        ADC_Res1Qp
        ADC_Res1Qn
        12
        C
        ADC_Res2Ip
        ADC_Res2In
        13
        D
        ADC_Res2Qp
        ADC_Res2Qn
        14
        E
        ADC_Res3Ip
        ADC_Res3In
        15
        F
        ADC_Res3Qp
        ADC_Res3Qn
        16
        10
        NC
        NC
        17
        11
        ADC_Cal_Ucap
        ADC_Cal_Ures
        18
        12
        I_CP_test
        PLL_IBG_05
        19
        13
        PLL_VBG
        VSS_VCO
        20
        14
        Vctrl_Test
        PLL_IPTAT_05
        21
        15
        PA_Vbias
        NC
        22
        16
        DIGBG
        DIGVFB
        23
        17
        IFBG
        IFVFB
        24
        18
        PLLBG
        PLLVREG
        25
        19
        IBias_10u
        IBias_5u
        26
        1A
        CLK_65K_Out
        AVSS
        27
        1B
        ADC8_VIN
        ADC8_VDAC
        28
        1C
        LBDcomp
        LBDcompref
        29
        1D
        TSBG
        TSVtemp
        30
        1E
        RFBG
        RFVREG
        31
        1F
        VCOBG
        VCOVREG
      </Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description>
        ensctest = Scan Test Enable. When set to '1' then GPIO0 will be the ScanEn input.
        dtb[5:0] = Digital Test Bus. GPIO must be configured to Digital Test Mux Output
        Internal digital signals available on the Digital Test Bus:
        dtb[4:0]
        GPIO0
        Signal
        GPIO1
        Signal
        GPIO2
        Signal
        0
        wkup_clk_32k
        wake-up 32kHz clock
        rbase_en
        first divided clock
        clk_base
        timebase clock
        1
        wkup_clk_32k
        wake-up 32kHz clock
        wake_up
        wake-up event
        tm1sec
        1 sec timebase
        2
        ts_adc_en
        aux. ADC enable
        adc_rdy_n
        aux. ADC conversion ready
        adc_done
        aux. ADC measurement done
        3
        cont_lbd
        low battery continouos mode
        lbd_on
        low battery ON signal
        lbd
        unfiltered output of LBD
        4
        div_clk_g
        gated divided clock
        uc_clk
        microcontroller clock
        ckout_rcsel
        slow clock selected
        5
        en_div_sync
        clock divider enable (sync'ed)
        en_ckout
        clock out enable
        en_ckout_s
        clock out enable (sync'ed)
        6
        osc30_en
        oscillator enable
        osc30_bias2x
        oscillator bias control
        xok
        chip ready
        7
        xok
        chip ready
        zero_cap
        cap. load zero
        osc30_buff_en
        buffer enable
        8
        tsadc_needed
        aux. ADC enable
        ext_retran
        ext. retransmission request
        tx_mod_gpio
        TX modulation inpit
        9
        gpio_0_oen_n
        GPIO0 output enable
        gpio_0_aen
        GPIO0 analog selection
        gpio_0_aden
        GPIO0 ADC input line enable
        10
        int_ack1
        interrupt acknowledge 1
        int_ack2
        interrupt acknowledge 2
        int_store
        interrupt latch closed
        11
        ext_int2
        ext. interrupt from GPIO2
        irq_bit8
        combined external status
        msk_bit8
        combined masked ext. int.
        12
        sdo_aux_sel
        SDO aux. function select
        sdo_aux
        SDO aux. signal
        nirq_aux_sel
        nIRQ aux. function select
        13
        trdata_on_sdi
        TX/RX data on SDI
        tx_mod
        TX modulation input
        tx_clk_out
        TX clock output
        14
        start_full_sync
        RC osc. full calibration start
        start_fine_sync
        RC osc. fine calibration start
        xtal_req
        crystal req. for RC osc. cal.
        15
        coarse_rdy
        RC osc. coarse cal. ready
        fine_rdy
        RC osc. fine cal. ready
        xtal_req_sync
        sync'ed crystal request
        16
        vco_cal_rst_s_n
        VCO calibration reset
        vco_cal
        VCO calibration is running
        vco_cal_done
        VCO calibration done
        17
        vco_cal_en
        VCO calibration enable
        en_ref_cnt
        reference counter enable
        en_freq_cnt_s
        frequency counter enable
        18
        vco_cal_en
        VCO calibration enable
        pos_diff
        positive difference to goal
        en_freq_cnt_s
        frequency counter enable
        19
        dsm_clk_mux
        DSM multiplexed clock
        pll_fb_clk_tst
        PLL feedback clock
        pll_ref_clk_tst
        PLL reference clock
        20
        dsm[0]
        delta-sigma output
        dsm[1]
        delta-sigma output
        dsm[2]
        delta-sigma output
        21
        dsm[3]
        delta-sigma output
        pll_fbdiv15
        dsm_rst_s_n
        delta-sigma reset
        22
        pll_en
        PLL enable: TUNE state
        pllt0_ok
        PLL initial settling OK
        pllts_ok
        PLL soft settling OK
        23
        ch_freq_req
        frequency change request
        pllts_ok
        PLL soft settling OK
        vco_cal_done
        VCO calibration done
        24
        vco_cal_en
        VCO calibration enable
        pll_vbias_shunt_en
        VCO bias shunt enable
        prog_req
        frequency recalculation req.
        25
        bandgap_en
        bandgap enable
        frac_div_en
        fractional divider enable
        buff3_en
        buffer3 enable
        26
        pll_pfd_up
        PFD up signal
        pll_pfd_down
        PFD down signal
        pfd_up_down
        PFD output change (XOR'ed)
        27
        pllts_ok
        PLL soft settling OK
        pll_en
        PLL enable: TUNE state
        pllt0_ok
        PLL initial settling OK
        28
        i_if_shift_n
        IF Shift indication
        i_vco_cal
        VCO Cal is in progress
        i_tx_en
        Active TX indication
        29
        pwst[0]
        internal power state
        pwst[1]
        internal power state
        pwst[2]
        internal power state
        Internal digital signals available on the Digital Test Bus (continued from the previous page):
        dtb[4:0]
        GPIO0
        Signal
        GPIO1
        Signal
        GPIO2
        Signal
        30
        xok
        chip ready: READY state
        pll_en
        PLL enable: TUNE state
        tx_en
        TX enable: TX state
        31
        ts_en
        temperature sensor enable
        auto_tx_on
        automatic TX ON
        tx_off
        TX OFF
        32
        ch_freq_req
        frequency change request
        return_tx
        return from TX
        pk_sent
        packet sent
        33
        retran_req
        retransmission request
        tx_ffpt_store
        TX FIFO pointer store
        tx_ffpt_restore
        TX FIFO pointer restore
        34
        pa_on_trig
        PA ON trigger
        dly_5us_ok
        5 us delay expired
        mod_dly_ok
        modulator delay expired
        35
        tx_shdwn
        TX shutdown
        ramp_start
        modulator ramp down start
        ramp_done
        modulator ramp down ended
        36
        pk_sent_dly
        delayed packet sent
        tx_shdwn_done
        TX shutdown done
        pa_ramp_en
        PA ramp enable
        37
        tx_en
        TX enable: TX state
        ldo_rf_precharge
        RF LDO precharge
        pa_ramp_en
        PA ramp enable
        38
        pa_on_trig
        TX enable: TX state
        dp_tx_en
        packet handler (TX) enable
        mod_en
        modulator enable
        39
        reg_wr_en
        register write enable
        reg_rd_en
        register rdead enable
        addr_inc
        register address increment
        40
        dp_tx_en
        packet handler (TX) enable
        data_start
        start of TX data
        pk_sent
        packet has been sent
        41
        data_start
        start of TX data
        tx_out
        packet handler TX data out
        pk_sent
        packet has been sent
        42
        ramp_done
        ramp is done
        data_start
        start of TX data
        pk_tx
        packet is being transmitted
        43
        tx_ffaf
        TX FIFO almost full
        tx_fifo_wr_en
        TX FIFO write enable
        tx_ffem_tst
        internal TX FIFO empty
        44
        clk_mod
        modulator gated 10MHz clock
        tx_clk
        TX clock from NCO
        rd_clk_x8
        read clock = tx_clk / 10
        45
        mod_en
        modulator enable
        ramp_start
        start modulator ramping down
        ramp_done
        modulator ramp done
        46
        data_start
        data input start from PH
        ook_en
        OOK modulation enable
        ook (also internal PN9)
        OOK modulation
        47
        prog_req
        freq. channel update request
        freq_err
        wrong freq. indication
        dsm_rst_s_n
        dsm sync. reset
        48
        mod_en
        modulator enable
        tx_rdy
        TX ready
        tx_clk
        TX clock from NCO
        49
        dp_rx_en
        packet handler (RX) enable
        prea_valid
        valid preamble
        pk_srch
        packet is being searched
        50
        pk_srch
        packet is being searched
        sync_ok
        sync. word has been detected
        rx_data
        packet handler RX data input
        51
        pk_rx
        packet is being received
        sync_ok
        sync. word has been detected
        pk_valid
        valid packet received
        52
        sync_ok
        sync. word has been detected
        crc_error
        CRC error has been detected
        hdch_error
        header error detected
        53
        direct_mode
        direct mode
        rx_ffaf
        RX FIFO almost full
        rx_fifo_rd_en
        RX FIFO read enable
        54
        bit_clk
        bit clock
        prea_valid
        valid preamble
        rx_data
        demodulator RX data output
        55
        prea_valid
        valid preamble
        prea_inval
        invalid preamble
        ant_div_sw
        antenna switch (algorythm)
        56
        sync_ok
        sync. word has been detected
        bit_clk
        bit clock
        rx_data
        demodulator RX data output
        57
        prea_valid
        Valid preamble
        Rx_dout
        demodulator data out
        ook_rawd
        Demodulator ook raw data out
        58
        prea_valid
        valid preamble
        bcr_error
        BCR error found
        PM_rst
        Preamble detector reset
        59
        agc_smp_clk
        AGC sample clock
        win_h_tp
        window comparator high
        win_l_tp
        window comparator low dly'd
        60
        prea_valid
        valid preamble
        Afc_out_band
        AFC is out of Band
        Pm_restart
        Restart signal for the Preamble detection
        61
        ldc_on
        active low duty cycle
        pll_en
        PLL enable: TUNE state
        rx_en
        RX enable: RX state
        62
        ldc_on
        active low duty cycle
        no_sync_det
        no sync word detected
        prea_valid
        valid preamble
        63
        adc_en
        ADC enable
        adc_refdac_en
        ADC reference DAC enable
        adc_rst_n
        combined ADC reset
      </Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="DF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldoramp en" />
      <Bit index="6" name="txmodly[2]" />
      <Bit index="5" name="txmodly[1]" />
      <Bit index="4" name="txmodly[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>
        ldorampen = Enable the ramp of the PA LDO in conjunction with the PA vbias ramp. Default =1 If this bit is SET, then the digital output named o_ldo_rf_tx will go high during TX and work normally. If this bit is LOW, then o_ldo_rf_tx will be low at all times.
        txmoddly[2:0] = TX Modulation ON/OFF Delay. The time delay between PA enable and the start of the TX modulation to allow for PA ramp-up, and also the time between Pa shut down to the end of the transmission to allow for PA ramp-down.  It can be set from 0 us to 28 us in 4 us steps.  During transmission start, writing 0 or 1 will yield 4 us (same setting).
        ldoramp[1:0] = TX LDO Ramp Time.  The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00 - 5 us
        01 - 10 us
        10 - 15 us
        11 - 20 us
        txramp[1:0] = TX ramp Time. The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00 -  5 us
        01 -  10 us
        10 -  15 us
        11 -  20 us
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="  52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>
        pllts[4:0] = PLL Soft Settling Time (TS). This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0 us and 310 us, in 10 us intervals. The default plltime  corresponds to 100 us. See formula above.
        pllt0 = PLL Settling Time (TO). This register will set the time allowed for initial wakeup and settling of the PLL and associated bias circuitry. The value is configurable between 0 us and 70 us, in 10 us steps. The default pllt0 corresponds to 20 us. See formula above.
      </Description>
    </Register>
    <Register address="54" name="PA Boost" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="paduty [1]" />
      <Bit index="4" name="paduty [0]" />
      <Bit index="3" name="ldoramplvl[1]" />
      <Bit index="2" name="ldoramplvl[0]" />
      <Bit index="1" name="ldo_pa_boost" />
      <Bit index="0" name="pa_vbias_boost" />
      <Description>
        Reserved
        Pa duty = will shift the duty cycle of the PA driver to improve efficiency.
        Ldo Ramp Lvl = will change the starting ramp voltage for the PA LDO to control the modulation depth
        LDO_PA_BOOST
        PA_VBIAS_BOOST
      </Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        xtalstarthalf = If set, the Xtal wake time period is halved.
        adccaldone = Delta-sigma ADC Calibration Done. Reading this bit gives '1' if the calibration process has been finished.
        enrcfcal = RC Oscillator Fine Calibration enable. If this bit is set to '1' then the RC oscillator performs fine calibration in every app. 30 s.
        rccal = RC Calibration Force. If setting rccal='1' will automatically perform a forced calibration of the 32kHz RC Oscillator.  The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a '0' to '1' will initiate the calibration. This bit is cleared automatically.

        vcocal = VCO Calibration Force.  If in Tune Mode ( pllon='1'), setting vcocal='1' will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        skipvco = Skip VCO Calibration. Setting skipvco='1' will prevent the VCO calibration from happening.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="oscdeten" />
      <Bit index="3" name="rssimasel" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>
        bcrfbyp = If set, BCR phase compensation will be bypassed.
        slicfbyp = If set,slicer phase compensation will be bypassed.
        dttype = Dithering Type: If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add +1/-1.
        oscdeten  = If low, the ADC Oscillation Detection mechanism is allowed to work. If set, we disable the function.
        rssimasel  = Number of taps for moving average filter during RSSI evaluation, except during Antenna Diversity. Allows for  reduced noise variation on measured RSSI value but with slower update rate. If high (1), filter tap length = 8*Tb. If low (0 = default), filter tap length = 4*Tb.
        refclksel = Delta-sigma Reference 10 MHz Clock Source Selection (1: PLL Ref clock, 0: FeedBack divider clock)
        refclkinv = Delta-sigma Reference Clock Inversion enable
        distogg = If reset, the discriminator toggling is disabled.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdctristate" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>
        pfdrst = Direct control to analog.
        fbdiv_rst = Direct control to analog
        cpforceup = Charge Pump Force Up
        cpforcedn = Charge Pump Force Down
        cdctristate = Charge Pump DC
        cdcurr[2:0] = Charge Pump DC Current selection
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming / Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>
        cpcurr[1:0] = Charge Pump Current (Gain Setting).  Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        cpcorrov = Charge Pump Correction Override enable
        cpcorr[4:0] = Charge Pump Correction value
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcor boosten" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        txcorboosten = If this is set, then vcocorr (reg 5A[5:2]) = 1111 during TX mode and VCO CAL followed by TX.
        fbdivhc = Feedback (fractional) Divider High Current enable (+5uA)
        d3trim[1:0] = Divider 3 Current Trim value
        d2trim[1:0] = Divider 2 Current Trim value
        d1p5trim[1:0] = Divider 1.5 (div-by-1.5) Current Trim value
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcur boosten" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        txcurboosten = If this is set, then vcocur = 11 during TX mode and VCO CAL followed by TX.
        vcocorrov = VCO Current Correction override
        vcocorr[3:0] = VCO Current Correction value
        vcocur[1:0] = VCO Current Trim value
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov / vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>
        vcocalov / vcdone = VCO Calibration Override / Done. When vcocalov='0' the internal VCO Calibration results may be viewed by reading the vcocal register. When vcocalov='1' the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives '1' if the calibration process has been finished.
        vcocal[6:0] = VCO Calibration Results
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="1'b0" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>
        dsmdt = Enable DSM ditherting. If low, dithering is disabled.
        read 1'b0
        enoloop = Open Loop Mode enable
        dsmod = Delta-Sigma Modulus
        0 - 64000 1 - 63997
        dsorder[1:0] = Delta-Sigma Order
        00 -  0 order
        01 -  1st order
        10 -  2nd order
        11 -  Mash 111
        dsrstmode = Delta-Sigma Reset Mode
        dsrst = Delta-Sigma Reset
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>
        enmix = Mixer enable override
        enlna = LNA enable override
        enpga = PGA enable override
        enpa = Power Amplifier enable override
        enbf5 = Buffer 5 enable override
        endv32 = Divider 3_2 enable override
        enbf12 = Buffer 1_2 enable override
        enmx2 = Multiplexer 2 enable override
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="en_rftx_ldo" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>
        ends = Delta-Sigma enable override
        en LDO RF Tx = If set, the LDO RF TX is forced on.
        enmx3 = Mutiplexer 3 enable override
        enbf4 = Buffer 4 enable override
        enbf3 = Buffer 3 enable override
        enbf11 = Buffer 1_1 enable override
        enbf2 = Buffer 2 enable override
        pllreset = PLL reset enable override
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>
        enfrdv = Fractional Divider enable override
        endv31 = Divider 3_1 enable override
        endv2 = Divider 2 enable override
        endv1p5 = Divider 1.5 (div-by-1.5) enable override
        dvbshunt = VCO Bias Shunt enable override mode.
        envco = VCO enable override
        encp = Charge Pump enable override
        enbg = Bandgap enable override
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="A0" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Inv_pre_th [3]" />
      <Bit index="6" name="Inv_pre_th [2]" />
      <Bit index="5" name="Inv_pre_th [1]" />
      <Bit index="4" name="Inv_pre_th [0]" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>
        Invalid_preamble_threshold[3:0] = This configures (in nibbles) for how long we will search for preamble. If during this time, the preamble is not detected, we will send a signal (which can be configured as interrupt) and restart looking for the preamble again.
        The interval between each interrupt is given by the formula below.
        chfiladd[3:0] = Channel Filter Coefficient Look-up Table Address. The address for channel filter coefficients used in the RX path.
        Invalid preamble will be evaluated during this period:  (invalid_preamble_Threshold *4 ) * Bit Rate period.
      </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>chfilval[5:0] = Filter Coefficient Value in the look-up table addressed by the chfiladd[3:0]</Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        pwst[2:0] = Internal Power States of the chip
        000 - low power (stand-by / sleep / sensor)
        001 - ready
        011 - tune
        010 - TX
        111 - RX
        clkhyst = Clock Hysteresis Setting
        enbias2x = 2 times higher bias current enable
        enamp2x = 2 times higher amplification enable
        bufovr = Output Buffer Enable Override If set to '1' then the enbuf bit controls the output buffer.
        0 - output buffer is controlled by the state machine
        1 - output buffer is controlled by the enbuf bit
        enbuf = Output Buffer Enable This bit is active only if the bufovr bit is set to '1'.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>
        rccov = RC Oscillator Coarse Calibration Override. When rccov='0' the internal Coarse Calibration results may be viewed by reading the rcccal register.  When rccov='1' the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        rcc[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>
        rcfov = RC Oscillator Fine Calibration Override. When rcfov='0' the internal Fine Calibration results may be viewed by reading the rcfcal register.  When rcfov='1' the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        rcf[6:0] = RC Oscillator Coarse Calibration Override Value / Results
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>
        enspor = Smart POR enable
        enbias = Bias enable
        envcoldo = VCO LDO enable
        enifldo = IF LDO enable
        enrfldo = RF LDO enable
        enpllldo = PLL LDO enable
        endigldo = Digital LDO enable
        endigpwdn = Digital Power Domain Powerdown enable in Idle mode
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="0" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>
        enovr = Enable Overrides (If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks).
        enxtal = Xtal override enable value.
        ents = temperature sensor enable.
        enrc32 = 32K oscillator enable.

        diglvl = digital LDO level setting
      </Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="1F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>
        adcrst = delta-sigma ADC reset
        enrefdac = delta-sigma ADC reference DAC enable override
        enadc = delta-sigma ADC enable override
        adctuneovr = resonator RC calibration value override enable
        adctune[3:0] = resonator RC calibration value
      </Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adcwdog" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>
        ADC wdog = ADC Watch dog enable (active high).
        envcm = delta-sigma ADC VCM enable override
        adcoloop = delta-sigma ADC open loop enable
        adcref[2:0] = delta-sigma ADC reference voltage
        000 - 0.5 V
        001 - 0.6 V
        010 - 0.7 V
        ...
        111 - 1.2 V
      </Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sgin" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>
        sgin = AGC stop increasing gain override bit (active low). When '0' (default), AGC gain increases during signal reductions are prevented. When '1', AGC gain increases during signal reductions are allowed. Only effective during Preamble, prior to detection of PREAMBLE_VALID signal.
        agcen = Automatic Gain Control enable When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
        lnagain = LNA Gain select
        0 - min. gain = 5 dB 1 -max. gain = 25 dB
        pga[3:0] = PGA Gain Override value
        000 - 0 dB
        001 - 3 dB
        010 - 6 dB
        ...
        101 - 24 dB max.
      </Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="agcovpkt" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>
        agcovpkt  = If '1' (default), AGC function operates over the entire packet. If '0', the full AGC function operates only during Preamble; gain increases over remainder of packet are  not allowed. Gain reductions (in the event of signal level increases) are always allowed.
        agcslow = AGC Slow Gain Increase enable. When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
        lnacomp[3:0] = LNA Gain Compensation, used for smoothing RSSI value when LNA gain is switched.
        pgath[1:0] = window comparator reference voltage adjust in the PGA
      </Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        firadd[2:0] = GFSK FIR Filter Coefficient Look-up Table Address. The address for Gaussian filter coefficients used in the TX path.  The default GFSK setting is for BT=0.5.  It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000 -  i_coe0 (Default =d1)
        001 -  i_coe1 (Default =d3)
        010 -  i_coe2 (Default =d6)
        011 -  i_coe3 (Default =d10)
        100 -  i_coe4 (Default =d15)
        101 -  i_coe5 (Default =d19)
        110 -  i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>firval[5:0] = FIR Coefficient Value in the look-up table addressed by the firadd[2:0]. The default coefficient can be read or modified.</Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="papeak val" />
      <Bit index="6" name="papeak en" />
      <Bit index="5" name="papeaklvl[1]" />
      <Bit index="4" name="papeaklvl[0]" />
      <Bit index="3" name="lna_sw" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>
        papeakval - PA Peak Detector Value Read only Register
        Reading a 1 in this register when peapeken=1 means the PA drain voltage is too high and the match network needs adjusting for optimal efficiency.
        papeaken  - PA Peak Detector Enable (direct from register) default =0
        papeaklvl[1:0]  - PA Peak Detect Level (direct from Register)
        00=6.5
        01=7
        10=7.5
        11=8
        (01 =  default )
        lna_sw  - LNA Switch Controller
        This bit determines when internal MOS switches at the LNA input(s) are closed. When lna_sw = 0, these switches are always open. When lna_sw = 1, these switches are closed in TX mode and open at all other times. This bit MUST be set for proper operation in any Direct Tie application.
        txpow[2:0] - TX output Power
        The output power is configurable from +13 dBm to -8 dBm (Si4430/31), and from +20 dBm to -1 dBm (Si4432) in ~3 dB steps.
        txpow[2:0] = 000 corresponds to min output power, and txpow[2:0] = 111 corresponds to max output power.
      </Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>txdr[15:8] = Data Rate upper byte.  See formula above.</Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="3D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>txdr[7:0] = Data Rate lower byte.  See formula above. Defaults = 40 kbps</Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txdtrtscale" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        txdtrtscale = This bit should be set for data rates below 30 [kbps].
        enphpwdn = If set, the Packet Handler will be powered down when chip is in low power mode.
        manppol = Manchester Preamble Polarity (will transmit a series of '1' if set, or series of '0' if reset). This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester mode is enabled.
        enmaninv = Manchester Data Inversion is enabled if this bit is set.
        enmanch = Manchester Coding is enabled if this bit is set.
        enwhite = Data Whitening is enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        trclk[1:0] = TX/RX Data Clock Configuration.
        00 - No TX Data CLK is available (asynchronous mode - Can only work with modulations FSK or OOK)
        01 - TX Data CLK is available via the GPIO (one of the GPIO's should be programmed as well)
        10 - TX/RX Data CLK is available via the SDO pin
        11 - TX/RX Data CLK is available via the nIRQ pin
        dtmod[1:0] = Data Source
        00 -  Direct Mode using TX_Data function via the GPIO pin (one of the GPIO's should be  programmed accordingly as well)
        01 -  Direct Mode using TX_Data function via the SDI pin (only when nSEL is high), or RX Data out during RX.
        10 -  FIFO Mode
        11 -  PN9 (internally generated)
        eninv = Invert TX and RX Data
        fd[8]  = See register 72h
        modtyp[1:0] = Modulation Type
        00 - Unmodulated carrier
        01 - OOK
        10 - FSK
        11 - GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>
        fd[7:0] = Frequency Deviation Setting. See formula above. (please see note below)
        Note: It's recommended to use modulation index of 1 or higher (maximum allowable modulation index is 62). The modulation index is defined by
      </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>fo[7:0] = Frequency Offset Setting. Values written to it will be used during TX, and during RX if AFC is disabled.</Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>fo[9:8] = Upper bits of the Frequency Offset Setting. fo[9] is the sign bit. Values written to it will be used during TX, and during RX if AFC is disabled.</Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        sbsel = Side Band Select.
        hbsel = High Band Select.  Setting hbsel = '1' will choose the freqency range from 480-960MHz (High Bands). Setting hbsel = '0' will choose the freqency range from 240-479.9MHz (Low Bands).
        fb[4:0] = Frequency Band Select.  Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands.  Setting fb[4:0]='00000' corresponds to the 240-250MHz Band for hbsel='0' and the 480-500MHz Band for hbsel='1'.  Setting fb[4:0]='00001' corresponds to the 250-260MHz Band for hbsel='0' and the 500-520MHz Band for hbsel='1'.
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>fc[15:8] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>fc[7:0] = Nominal Carrier Frequency Setting. See formula above.</Description>
    </Register>
    <Register address="78" name="Misc. Settings" size="8" defaultVal="19" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txantval" />
      <Bit index="6" name="txant" />
      <Bit index="5" name="fmshft" />
      <Bit index="4" name="ifintcen" />
      <Bit index="3" name="Alt PA Seq" />
      <Bit index="2" name="rcosc[2]" />
      <Bit index="1" name="rcosc[1]" />
      <Bit index="0" name="rcosc[0]" />
      <Description>
        Readout ONLY: Current TX antenna value.
        TX antenna: If set, TX will no longer use the antenna selected during a previous RX.
        FM IF SHIFT = If set, we enable double If shift during RX VCO Cal.
        ifintc Enable = enable for the inner IF LDO switch.
        Alternative PA sequencing = If set, we will enable the alternative PA sequence.
        rcosc_cal[2:0] = fine changes on the RC OSC Calibration target frequency, to help compensate for 'calibration biases'. This register should not be changed by costumers.
      </Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>fhch[7:0] = Frequency Hopping Channel number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>fhs[7:0] Frequency Hopping Step Size in 10kHz increments. See formula for the nominal carrier frequency at register 76h.</Description>
    </Register>
    <Register address="7B" name="Turn Around and 15.4" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="15.4 Lenght" />
      <Bit index="6" name="txfrequpdt" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="turn_around_en" />
      <Bit index="1" name="Phase[1]" />
      <Bit index="0" name="Phase[0]" />
      <Description>
        15.4 Packet Length compliance If set, then PK Length definition for both TX and RX will also include the CRC bytes, If reset, then the Length refers ONLY to the DATA payload. For example, writing '9' to this register when it is set, means we are sending/expecting '7' bytes of DATA, and the other '2' should be the CRC (CRC should be enabled separately).
        txfrequpdt = If low, we enable a frequency update right after VCO CAL is done, when entering a TX state.
        reserved
        Turn Around Enable Enabling for the turn around functionality.
        Turn Around phase The RX to TX change in frequency will happen (if bit [2] is set) at the last byte, and these two registers set the bit position in which the frequency shifts should occur. Make sure it does not happen to early otherwise the last bits will be missed.
      </Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>txafthr[5:0] = TX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>txfaethr[5:0] = TX FIFO Almost Empty Threshold</Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>rxafthr[5:0] = RX FIFO Almost Full Threshold</Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        fifod[7:0] = A write (R/W='1') to this address will begin a burst write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented.  To conclude the TX FIFO Write the SEL pin should be brought HIGH. A Read (R/W='0') to this address will begin a burst read of the RX FIFO, in the same manner.
        11/11/2011   Silicon Labs Inc.    Confidential 47/51
        Current for CHIP revision: EZRadioPRO (B1)      Doc Version: 1.92
        EZRadioPRO (B1)  ISM Preliminary
        Current for CHIP revision: EZRadioPRO (B1)
        11/11/2011 Silicon Labs Inc.   Confidential 1/46
        Current for CHIP revision: EZRadioPRO (B1)      Doc Version: 1.92
      </Description>
    </Register>
  </SPIDevice>
  <SPIDevice chipID="24" type="Si1000" revision="B1" projectID="0" name="MCM 1000-02_B1">
    <TxPufferSize>64</TxPufferSize>
    <RxPufferSize>64</RxPufferSize>
    <TxPufferAddress>7F</TxPufferAddress>
    <RxPufferAddress>7F</RxPufferAddress>
    <nFFS_control>0</nFFS_control>
    <Register address="00" name="Device Type" size="8" defaultVal="08" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="dt[4]" />
      <Bit index="3" name="dt[3]" />
      <Bit index="2" name="dt[2]" />
      <Bit index="1" name="dt[1]" />
      <Bit index="0" name="dt[0]" />
      <Description>
        dt[4:0]
        Device Type Code.
        EZRadioPRO: 01000.
      </Description>
    </Register>
    <Register address="01" name="Device Version" size="8" defaultVal="06" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vc[4]" />
      <Bit index="3" name="vc[3]" />
      <Bit index="2" name="vc[2]" />
      <Bit index="1" name="vc[1]" />
      <Bit index="0" name="vc[0]" />
      <Description>
        4:0
        vc[4:0]
        Version Code.
        Code indicating the version of the chip.

      </Description>
    </Register>
    <Register address="02" name="Device Status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="8" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ffovfl" />
      <Bit index="6" name="ffunfl" />
      <Bit index="5" name="rxffem" />
      <Bit index="4" name="headerr" />
      <Bit index="3" name="reserved" />
      <Bit index="2" name="reserved" />
      <Bit index="1" name="cps[1]" />
      <Bit index="0" name="cps[0]" />
      <Description>
        7
        RX/TX FIFO Overflow Status.
        6
        ffunfl
        RX/TX FIFO Underflow Status.
        5
        rxffem
        RX FIFO Empty Status.
        4
        headerr
        Header Error Status.
        Indicates if the received packet has a header check error.
        3:2
        Reserved
        1:0
        cps[1:0]
        Chip Power State.
        00:	Idle State
        01:	RX State10:	TX State
      </Description>
    </Register>
    <Register address="03" name="Interrupt Status 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="ifferr" />
      <Bit index="6" name="itxffafull" />
      <Bit index="5" name="itxffaem" />
      <Bit index="4" name="irxffafull" />
      <Bit index="3" name="iext" />
      <Bit index="2" name="ipksent" />
      <Bit index="1" name="ipkvalid" />
      <Bit index="0" name="icrcerror" />
      <Description>
        7
        FIFO Underflow/Overflow Error.
        When set to 1 the TX or RX FIFO has overflowed or underflowed.
        6
        itxffafull
        TX FIFO Almost Full.
        When set to 1 the TX FIFO has met its almost full threshold and needs to be transmitted.
        5
        itxffaem
        TX FIFO Almost Empty.
        When set to 1 the TX FIFO is almost empty and needs to be filled.
        4
        irxffafull
        RX FIFO Almost Full.When set to 1 the RX FIFO has met its almost full threshold and needs to be read by the microcontroller.
        3
        iext
        External Interrupt.
        When set to 1 an interrupt occurred on one of the GPIO   s if it is programmed so. The status can be checked in register 0Eh. See GPIOx Configuration section for the details.
        2
        ipksent
        Packet Sent Interrupt.
        When set to1 a valid packet has been transmitted.
        1
        ipkvalid
        Valid Packet Received.When set to 1 a valid packet has been received.
        0
        icrcerror
        CRC Error.
        When set to 1 the cyclic redundancy check is failed.
        When any of the Interrupt/Status 1 bits change state from 0 to 1 the device will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 1 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 1 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
        Table 27. Interrupt or Status 1 Bit Set/Clear Description
        Bit
        Status Name
        Set/Clear Conditions
        7
        ifferr
        Set if there is a FIFO overflow or underflow. Cleared by applying FIFO reset.
        6
        itxffafull
        Set when the number of bytes written to TX FIFO is greater than the Almost Full threshold. Automatically cleared at the start of transmission when the number of bytes in the FIFO is less than or equal to the threshold.
        5
        itxffaem
        Set when the number of bytes in the TX FIFO is less than or equal to the Almost Empty threshold. Automatically cleared when the number of data bytes in the TX FIFO is above the Almost Empty threshold.
        4
        irxffafull
        Set when the number of bytes in the RX FIFO is greater than the Almost Full threshold. Cleared when the number of bytes in the RX FIFO is below the Almost Full threshold.
        3
        iext
        External interrupt source.
        2
        ipksent
        Set once a packet is successfully sent (no TX abort). Cleared upon leaving FIFO mode or at the start of a new transmission.
        1
        ipkvalid
        Set up the successful reception of a packet (no RX abort). Cleared upon receiving and acknowledging the Sync Word for the next packet.
        0
        icrcerror
        Set if the CRC computed from the RX packet differs from the CRC in the TX packet. Cleared at the start of reception for the next packet.
        Table 28. When are Individual Status Bits Set/Cleared if not Enabled as Interruptsu
        Bit
        Status Name
        Set/Clear Conditions
        7
        ifferr
        Set if there is a FIFO Overflow or Underflow. It is cleared only by applying FIFO reset to the specific FIFO that caused the condition.
        6
        itxffafull
        Will be set when the number of bytes written to TX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we start transmitting and the FIFO data is read out and the number of bytes left in the FIFO is smaller or equal to the threshold).
        5
        itxffaem
        Will be set when the number of bytes (not yet transmitted) in TX FIFO is smaller or equal than the Almost Empty threshold set by SPI. It is automatically cleared when we write enough data to TX FIFO so that the number of data bytes not yet transmitted is above the Almost Empty threshold.
        4
        irxffafull
        Will be set when the number of bytes received (and not yet read-out) in RX FIFO is greater than the Almost Full threshold set by SPI. It is automatically cleared when we read enough data from RX FIFO so that the number of data bytes not yet read is below the Almost Full threshold.
        3
        iext
        External interrupt source
        2
        ipksent
        Will go high once a packet is sent all the way through (no TX abort). This status will be cleaned if 1) We leave FIFO mode or 2) In FIFO mode we start a new transmission.
        1
        ipkvalid
        Goes high once a packet is fully received (no RX abort). It is automatically cleaned once we receive and acknowledge the Sync Word for the next packet.
        0
        icrcerror
        Goes High once the CRC computed during RX differs from the CRC sent in the packet by the TX. It is cleaned once we start receiving new data in the next packet.
      </Description>
    </Register>
    <Register address="04" name="Interrupt Status 2" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="iswdet" />
      <Bit index="6" name="ipreaval" />
      <Bit index="5" name="ipreainval" />
      <Bit index="4" name="irssi" />
      <Bit index="3" name="iwut" />
      <Bit index="2" name="ilbd" />
      <Bit index="1" name="ichiprdy" />
      <Bit index="0" name="ipor" />
      <Description>
        7
        Sync Word Detected.
        When a sync word is detected this bit will be set to 1.
        6
        ipreaval
        Valid Preamble Detected.
        When a preamble is detected this bit will be set to 1.
        5
        ipreainval
        Invalid Preamble Detected.
        When the preamble is not found within a period of time set by the invalid preamble detection threshold in Register 54h, this bit will be set to 1.
        4
        irssi
        RSSI.
        When RSSI level exceeds the programmed threshold this bit will be set to 1.
        3
        iwut
        Wake-Up-Timer.
        On the expiration of programmed wake-up timer this bit will be set to 1.
        2
        ilbd
        Low Battery Detect.
        When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled.
        1
        ichiprdy
        Chip Ready (XTAL).
        When a chip ready event has been detected this bit will be set to 1.
        0
        ipor
        Power-on-Reset (POR).
        When the chip detects a Power on Reset above the desired setting this bit will be set to 1.
        When any of the Interrupt/Status Register 2 bits change state from 0 to 1 the control block will notify the microcontroller by setting the nIRQ pin LOW if it is enabled in the Interrupt Enable 2 register. The nIRQ pin will go to HIGH and all the enabled interrupt bits will be cleared when the microcontroller reads this address. If any of these bits is not enabled in the Interrupt Enable 2 register then it becomes a status signal that can be read anytime in the same location and will not be cleared by reading the register.
        Table 29.  Interrupt or Status 2 Bit Set/Clear Description
        Bit
        Status Name
        Set/Clear Conditions
        7
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        6
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        5
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        4
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        3
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        2
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        1
        ichiprdy
        Chip ready goes high once we enable the xtal, TX or RX and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        0
        ipor
        Power on status.
        Table 30. Detailed Description of Status Registers when not Enabled as Interrupts
        Bit
        Status Name
        Set/Clear Conditions
        7
        iswdet
        Goes high once the Sync Word is detected. Goes low once we are done receiving the current packet.
        6
        ipreaval
        Goes high once the preamble is detected. Goes low once the sync is detected or the RX wait for the sync times-out.
        5
        ipreainval
        Self cleaning, user should use this as an interrupt source rather than a status.
        4
        irssi
        Should remain high as long as the RSSI value is above programmed threshold level
        3
        iwut
        Wake time timer interrupt. Use as an interrupt, not as a status.
        2
        ilbd
        Low Battery Detect. When a low battery event is been detected this bit will be set to 1. This interrupt event is saved even if it is not enabled by the mask register bit and causes an interrupt after it is enabled. Probably the status is cleared once the battery is replaced.
        1
        ichiprdy
        Chip ready goes high once we enable the xtal, TX or RX, and a settling time for the Xtal clock elapses. The status stay high unless we go back to Idle mode.
        0
        ipor
        Power on status.
      </Description>
    </Register>
    <Register address="05" name="Interrupt Enable 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enfferr" />
      <Bit index="6" name="entxffafull" />
      <Bit index="5" name="entxffaem" />
      <Bit index="4" name="enrxffafull" />
      <Bit index="3" name="enext" />
      <Bit index="2" name="enpksent" />
      <Bit index="1" name="enpkvalid" />
      <Bit index="0" name="encrcerror" />
      <Description>
        7
        Enable FIFO Underflow/Overflow.
        When set to 1 the FIFO Underflow/Overflow interrupt will be enabled.
        6
        entxffafull
        Enable TX FIFO Almost Full.
        When set to 1 the TX FIFO Almost Full interrupt will be enabled.
        5
        entxffaem
        Enable TX FIFO Almost Empty.
        When set to 1 the TX FIFO Almost Empty interrupt will be enabled.
        4
        enrxffafull
        Enable RX FIFO Almost Full.
        When set to 1 the RX FIFO Almost Full interrupt will be enabled.
        3
        enext
        Enable External Interrupt.
        When set to 1 the External Interrupt will be enabled.
        2
        enpksent
        Enable Packet Sent.
        When ipksent =1 the Packet Sense Interrupt will be enabled.
        1
        enpkvalid
        Enable Valid Packet Received.
        When ipkvalid = 1 the Valid Packet Received Interrupt will be enabled.
        0
        encrcerror
        Enable CRC Error.
        When set to 1 the CRC Error interrupt will be enabled.
      </Description>
    </Register>
    <Register address="06" name="Interrupt Enable 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="1" />
      <Bit index="7" name="enswdet" />
      <Bit index="6" name="enpreaval" />
      <Bit index="5" name="enpreainval" />
      <Bit index="4" name="enrssi" />
      <Bit index="3" name="enwut" />
      <Bit index="2" name="enlbd" />
      <Bit index="1" name="enchiprdy" />
      <Bit index="0" name="enpor" />
      <Description>
        7
        Enable Sync Word Detected.
        When mpreadet =1 the Preamble Detected Interrupt will be enabled.
        6
        enpreaval
        Enable Valid Preamble Detected.
        When mpreadet =1 the Valid Preamble Detected Interrupt will be enabled.
        5
        enpreainval
        Enable Invalid Preamble Detected.
        When mpreadet =1 the Invalid Preamble Detected Interrupt will be enabled.
        4
        enrssi
        Enable RSSI.
        When set to 1 the RSSI Interrupt will be enabled.
        3
        enwut
        Enable Wake-Up Timer.
        When set to 1 the Wake-Up Timer interrupt will be enabled.
        2
        enlbd
        Enable Low Battery Detect.
        When set to 1 the Low Battery Detect interrupt will be enabled.
        1
        enchiprdy
        Enable Chip Ready (XTAL).
        When set to 1 the Chip Ready interrupt will be enabled.
        0
        enpor
        Enable POR.
        When set to 1 the POR interrupt will be enabled.
      </Description>
    </Register>
    <Register address="07" name="Operating &amp; Function Control 1" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swres" />
      <Bit index="6" name="enlbd" />
      <Bit index="5" name="enwt" />
      <Bit index="4" name="x32ksel" />
      <Bit index="3" name="txon" />
      <Bit index="2" name="rxon" />
      <Bit index="1" name="pllon" />
      <Bit index="0" name="xton" />
      <Description>
        7
        Software Register Reset Bit.
        This bit may be used to reset all registers simultaneously to a DEFAULT state, without the need for sequentially writing to each individual register. The RESET is accomplished by setting swres = 1. This bit will be automatically cleared.
        6
        enlbd
        Enable Low Battery Detect.
        When this bit is set to 1 the Low Battery Detector circuit and threshold comparison will be enabled.
        5
        enwt
        Enable Wake-Up-Timer.
        Enabled when enwt = 1. If the Wake-up-Timer function is enabled it will operate in any mode and notify the microcontroller through the GPIO interrupt when the timer expires.
        4
        x32ksel
        32,768 kHz Crystal Oscillator Select.
        0:	RC oscillator
        1:	32kHz crystal
        3
        txon
        TX on in Manual Transmit Mode.
        Automatically cleared in FIFO mode once the packet is sent. Transmission can be aborted during packet transmission, however, when no data has been sent yet, transmission can only be aborted after the device is programmed to    unmodulated carrier    ("Register 71h. Modulation Mode Control 2").
        2
        rxon
        RX on in Manual Receiver Mode.
        Automatically cleared if Multiple Packets config. is disabled and a valid packet received.
        1
        pllon
        TUNE Mode (PLL is ON).
        When pllon = 1 the PLL will remain enabled in Idle State. This will for faster turn-around time at the cost of increased current consumption in Idle State.
        0
        xton
        READY Mode (Xtal is ON).
      </Description>
    </Register>
    <Register address="08" name="Operating &amp; Function Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="antdiv[2]" />
      <Bit index="6" name="antdiv[1]" />
      <Bit index="5" name="antdiv[0]" />
      <Bit index="4" name="rxmpk" />
      <Bit index="3" name="autotx" />
      <Bit index="2" name="enldm" />
      <Bit index="1" name="ffclrrx" />
      <Bit index="0" name="ffclrtx" />
      <Description>
        7:5
        Enable Antenna Diversity.
        The GPIO must be configured for Antenna Diversity for the algorithm to work properly.
        RX/TX state	non RX/TX state
        GPIO Ant1	GPIO Ant2	GPIO Ant1	GPIO Ant2
        000: 	0	1	0	0
        001:	1	0	0	0
        010: 	0	1	1	1
        011:	1	0	1	1
        100:	antenna diversity algorithm	0	0
        101: 	antenna diversity algorithm	1	1
        110:	ant. div. algorithm in beacon mode	0	0
        111: 	ant. div. algorithm in beacon mode 	1	1
        4
        rxmpk
        RX Multi Packet.
        When the chip is selected to use FIFO Mode (dtmod[1:0]) and RX Packet Handling (enpacrx) then it will fill up the FIFO with multiple valid packets if this bit is set, otherwise the transceiver will automatically leave the RX State after the first valid packet has been received.
        3
        autotx
        Automatic Transmission.
        When autotx = 1 the transceiver will enter automatically TX State when the FIFO is almost full. When the FIFO is empty it will automatically return to the Idle State.
        2
        enldm
        Enable Low Duty Cycle Mode.
        If this bit is set to 1 then the chip turns on the RX regularly. The frequency should be set in the Wake-Up Timer Period register, while the minimum ON time should be set in the Low-Duty Cycle Mode Duration register. The FIFO mode should be enabled also.
        1
        ffclrrx
        RX FIFO Reset/Clear.
        This has to be a two writes operation: Setting ffclrrx=1 followed by ffclrrx= 0 will clear the contents of the RX FIFO.
        0
        ffclrtx
        TX FIFO Reset/Clear.
        This has to be a two writes operation: Setting ffclrtx=1 followed by ffclrtx= 0 will clear the contents of the TX FIFO.
      </Description>
    </Register>
    <Register address="09" name="Crystal Oscillator Load Capacitance" size="8" defaultVal="7F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="xtalshft" />
      <Bit index="6" name="xlc[6]" />
      <Bit index="5" name="xlc[5]" />
      <Bit index="4" name="xlc[4]" />
      <Bit index="3" name="xlc[3]" />
      <Bit index="2" name="xlc[2]" />
      <Bit index="1" name="xlc[1]" />
      <Bit index="0" name="xlc[0]" />
      <Description>
        7
        Additional capacitance to course shift the frequency if xlc[6:0] is not sufficient. Not binary with xlc[6:0].
        6:0
        xlc[6:0]
        Tuning Capacitance for the 30MHz XTAL.
      </Description>
    </Register>
    <Register address="0A" name="Microcontroller Output Clock" size="8" defaultVal="06" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="clkt[1]" />
      <Bit index="4" name="clkt[0]" />
      <Bit index="3" name="enlfc" />
      <Bit index="2" name="mclk[2]" />
      <Bit index="1" name="mclk[1]" />
      <Bit index="0" name="mclk[0]" />
      <Description>
        5:4
        clkt[1:0]
        Clock Tail.
        If enlfc = 0 then it can be useful to provide a few extra cycles for the microcontroller to complete its operation. Setting the clkt[1:0] register will provide the addition cycles of the clock before it shuts off.
        00: 	0 cycle
        01: 	128 cycles
        10: 	256 cycles
        11: 	512 cycles
        3
        enlfc
        Enable Low Frequency Clock.
        When enlfc = 1 and the chip is in Sleep mode then the 32.768kHz clock will be provided to the microcontroller no matter what the selection of mclk[2:0] is. For example if mclk[2:0] =    000   , 30MHz will be available through the GPIO to output to the microcontroller in all Idle, TX, or RX states. When the chip is commanded to Sleep mode the 30MHz clock will become 32.768kHz.
        2:0
        mclk[2:0]
        Microcontroller Clock.
        Different clock frequencies may be selected for configurable GPIO clock output. All clock frequencies are created by dividing the XTAL except for the 32kHz clock which comes directly from the 32kHz RC Oscillator. The mclk[2:0] setting is only valid when xton = 1 except the 111.
        000: 	30 MHz
        001: 	15 MHz
        010: 	10 MHz
        011: 	4 MHz
        100: 	3 MHz
        101: 	2 MHz
        110: 	1 MHz
        111:	32.768 kHz
      </Description>
    </Register>
    <Register address="0B" name="GPIO0 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio0drv[1]" />
      <Bit index="6" name="gpio0drv[0]" />
      <Bit index="5" name="pup0" />
      <Bit index="4" name="gpio0[4]" />
      <Bit index="3" name="gpio0[3]" />
      <Bit index="2" name="gpio0[2]" />
      <Bit index="1" name="gpio0[1]" />
      <Bit index="0" name="gpio0[0]" />
      <Description>
        7:6
        GPIO Driving Capability Setting.
        5
        pup0
        Pullup Resistor Enable on GPIO0.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio0[4:0]
        GPIO0 pin Function Select.
        00000: 	Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	RX Data (output)
        10101:	RX State (output)
        10110:	RX FIFO Almost Full (output)
        10111:	Antenna 1 Switch used for antenna diversity (output)
        11000:	Antenna 2 Switch used for antenna diversity (output)
        11001:	Valid Preamble Detected (output)
        11010:	Invalid Preamble Detected (output)
        11011:	Sync Word Detected (output)
        11100:	Clear Channel Assessment (output)
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0C" name="GPIO1 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio1drv[1]" />
      <Bit index="6" name="gpio1drv[0]" />
      <Bit index="5" name="pup1" />
      <Bit index="4" name="gpio1[4]" />
      <Bit index="3" name="gpio1[3]" />
      <Bit index="2" name="gpio1[2]" />
      <Bit index="1" name="gpio1[1]" />
      <Bit index="0" name="gpio1[0]" />
      <Description>
        7:6
        GPIO Driving Capability Setting.
        5
        pup1
        Pullup Resistor Enable on GPIO1.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio1[4:0]
        GPIO1 pin Function Select.
        00000: 	Inverted Power-On-Reset (output)
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	RX Data (output)
        10101:	RX State (output)
        10110:	RX FIFO Almost Full (output)
        10111:	Antenna 1 Switch used for antenna diversity (output)
        11000:	Antenna 2 Switch used for antenna diversity (output)
        11001:	Valid Preamble Detected (output)
        11010:	Invalid Preamble Detected (output)
        11011:	Sync Word Detected (output)
        11100:	Clear Channel Assessment (output)
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0D" name="GPIO2 Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="gpio2drv[1]" />
      <Bit index="6" name="gpio2drv[0]" />
      <Bit index="5" name="pup2" />
      <Bit index="4" name="gpio2[4]" />
      <Bit index="3" name="gpio2[3]" />
      <Bit index="2" name="gpio2[2]" />
      <Bit index="1" name="gpio2[1]" />
      <Bit index="0" name="gpio2[0]" />
      <Description>
        7:6
        GPIO Driving Capability Setting.
        5
        pup2
        Pullup Resistor Enable on GPIO2.
        When set to 1 the a 200kuuresistor is connected internally between VDD and the pin if the GPIO is configured as a digital input.
        4:0
        gpio2[4:0]
        GPIO2 pin Function Select.
        00000: 	Microcontroller Clock
        00001: 	Wake-Up Timer: 1 when WUT has expired (output)
        00010: 	Low Battery Detect: 1 when battery is below threshold setting (output)
        00011: 	Direct Digital Input
        00100:	External Interrupt, falling edge (input)
        00101: 	External Interrupt, rising edge (input)
        00110: 	External Interrupt, state change (input)
        00111:	ADC Analog Input
        01000:	Reserved (Analog Test N Input)
        01001:	Reserved (Analog Test P Input)
        01010:	Direct Digital Output
        01011:	Reserved (Digital Test Output)
        01100:	Reserved (Analog Test N Output)
        01101:	Reserved (Analog Test P Output)
        01110:	Reference Voltage (output)
        01111:	TX/RX Data CLK output to be used in conjunction with TX/RX Data pin (output)
        10000:	TX Data input for direct modulation (input)
        10001:	External Retransmission Request (input)
        10010:	TX State (output)
        10011:	TX FIFO Almost Full (output)
        10100:	RX Data (output)
        10101:	RX State (output)
        10110:	RX FIFO Almost Full (output)
        10111:	Antenna 1 Switch used for antenna diversity (output)
        11000:	Antenna 2 Switch used for antenna diversity (output)
        11001:	Valid Preamble Detected (output)
        11010:	Invalid Preamble Detected (output)
        11011:	Sync Word Detected (output)
        11100:	Clear Channel Assessment (output)
        11101:	VDD
        else   :	GND
      </Description>
    </Register>
    <Register address="0E" name="I/O Port Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="extitst[2]" />
      <Bit index="5" name="extitst[1]" />
      <Bit index="4" name="extitst[0]" />
      <Bit index="3" name="itsdo" />
      <Bit index="2" name="dio2" />
      <Bit index="1" name="dio1" />
      <Bit index="0" name="dio0" />
      <Description>
        6
        extitst[2]
        External Interrupt Status.
        If the GPIO2 is programmed to be external interrupt sources then the status can be read here.
        5
        extitst[1]
        External Interrupt Status.
        If the GPIO1 is programmed to be external interrupt sources then the status can be read here.
        4
        extitst[0]
        External Interrupt Status.
        If the GPIO0 is programmed to be external interrupt sources then the status can be read here.
        3
        itsdo
        Interrupt Request Output on the SDO Pin.
        nIRQ output is present on the SDO pin if this bit is set and the nSEL input is inactive (high).
        2
        dio2
        Direct I/O for GPIO2.
        If the GPIO2 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO2 is configured to be a direct input then the value of the pin can be read here.
        1
        dio1
        Direct I/O for GPIO1.
        If the GPIO1 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO1 is configured to be a direct input then the value of the pin can be read here.
        0
        dio0
        Direct I/O for GPIO0.
        If the GPIO0 is configured to be a direct output then the value on the GPIO pin can be set here. If the GPIO0 is configured to be a direct input then the value of the pin can be read here.
      </Description>
    </Register>
    <Register address="0F" name="ADC Configuration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adcstart/adcdone" />
      <Bit index="6" name="adcsel[2]" />
      <Bit index="5" name="adcsel[1]" />
      <Bit index="4" name="adcsel[0]" />
      <Bit index="3" name="adcref[1]" />
      <Bit index="2" name="adcref[0]" />
      <Bit index="1" name="adcgain[1]" />
      <Bit index="0" name="adcgain[0]" />
      <Description>
        7
        ADC Measurement Start Bit.
        Reading this bit gives 1 if the ADC measurement cycle has been finished.
        6:4
        adcsel[2:0]
        ADC Input Source Selection.
        The internal 8-bit ADC input source can be selected as follows:
        000:	Internal Temperature Sensor
        001:	GPIO0, single-ended
        010:	GPIO1, single-ended
        011: 	GPIO2, single-ended
        100:	GPIO0(+)     GPIO1(   ), differential
        101:	GPIO1(+)     GPIO2(   ), differential
        110:	GPIO0(+)     GPIO2(   ), differential
        111:	GND
        3:2
        adcref[1:0]
        ADC Reference Voltage Selection.
        The reference voltage of the internal 8-bit ADC can be selected as follows:
        0X:	bandgap voltage (1.2V)
        10:	VDD / 3
        11: 	VDD / 2
        1:0
        adcgain[1:0]
        ADC Sensor Amplifier Gain Selection.
        The full scale range of the internal 8-bit ADC in differential mode (see adcsel) can be set as follows:
        adcref[0] = 0:	adcref[0] = 1:
        FS = 0.014 x (adcgain[1:0] + 1) x VDD 	FS = 0.021 x (adcgain[1:0] + 1) x VDD
      </Description>
    </Register>
    <Register address="10" name="ADC Sensor Amplifier Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="adcoffs[3]" />
      <Bit index="2" name="adcoffs[2]" />
      <Bit index="1" name="adcoffs[1]" />
      <Bit index="0" name="adcoffs[0]" />
      <Description>
        3:0
        adcoffs[3:0]
        ADC Sensor Amplifier Offset*.
        *Note:	 The offset can be calculated as Offset = adcoffs[2:0] x VDD / 1000; MSB = adcoffs[3] = Sign bit.
      </Description>
    </Register>
    <Register address="11" name="ADC Value" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adc[7]" />
      <Bit index="6" name="adc[6]" />
      <Bit index="5" name="adc[5]" />
      <Bit index="4" name="adc[4]" />
      <Bit index="3" name="adc[3]" />
      <Bit index="2" name="adc[2]" />
      <Bit index="1" name="adc[1]" />
      <Bit index="0" name="adc[0]" />
      <Description>Internal 8 bit ADC Output Value.</Description>
    </Register>
    <Register address="12" name="Temperature Sensor Control" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tsrange[1]" />
      <Bit index="6" name="tsrange[0]" />
      <Bit index="5" name="entsoffs" />
      <Bit index="4" name="entstrim" />
      <Bit index="3" name="tstrim[3]" />
      <Bit index="2" name="tstrim[2]" />
      <Bit index="1" name="tstrim[1]" />
      <Bit index="0" name="tstrim[0]" />
      <Description>
        7:6
        Temperature Sensor Range Selection.
        (FS range is 0..1024mV)
        00:	   40uoC .. 64uoC (full operating range), with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        01:	   40uoC .. 85uoC, with 1uoC resolution (1 LSB in the 8-bit ADC)
        11:	   0uoC .. 85uoC, with 0.5uoC resolution (1 LSB in the 8-bit ADC)
        10:	   40uoF .. 216uoF, with 1uoF resolution (1 LSB in the 8-bit ADC)
        5
        entsoffs
        Temperature Sensor Offset to Convert from K to   C.
        4
        entstrim
        Temperature Sensor Trim Enable.
        3:0
        tstrim[3:0]
        Temperature Sensor Trim Value.
      </Description>
    </Register>
    <Register address="13" name="Temperature Value Offset" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="tvoffs[7]" />
      <Bit index="6" name="tvoffs[6]" />
      <Bit index="5" name="tvoffs[5]" />
      <Bit index="4" name="tvoffs[4]" />
      <Bit index="3" name="tvoffs[3]" />
      <Bit index="2" name="tvoffs[2]" />
      <Bit index="1" name="tvoffs[1]" />
      <Bit index="0" name="tvoffs[0]" />
      <Description>
        Temperature Value Offset.
        This value is added to the measured temperature value. (MSB, tvoffs[8]: sign bit)
        Note:	If a new configuration is needed (e.g., for the WUT or the LDC), proper functionality is required. The function must first be disabled, then the settings changed, then enabled back on.
        Bit
        Name
        Function
        7:5
        Reserved
        4:0
        wtr[4:0]
        Wake Up Timer Exponent (R) Value*.
        Maximum value for R is decimal 20. A value greater than 20 will yield a result as if 20 were written. R Value = 0 can be written here.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms. R=0 is allowed, and the maximum value for R is decimal 20. A value greater than 20 will result in the same as if 20 was written.
      </Description>
    </Register>
    <Register address="14" name="Wake-Up Timer Period 1" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="wtr[4]" />
      <Bit index="3" name="wtr[3]" />
      <Bit index="2" name="wtr[2]" />
      <Bit index="1" name="wtr[1]" />
      <Bit index="0" name="wtr[0]" />
      <Description></Description>
    </Register>
    <Register address="15" name="Wake-Up Timer Period 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[15]" />
      <Bit index="6" name="wtm[14]" />
      <Bit index="5" name="wtm[13]" />
      <Bit index="4" name="wtm[12]" />
      <Bit index="3" name="wtm[11]" />
      <Bit index="2" name="wtm[10]" />
      <Bit index="1" name="wtm[9]" />
      <Bit index="0" name="wtm[8]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="16" name="Wake-Up Timer Period 3" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtm[7]" />
      <Bit index="6" name="wtm[6]" />
      <Bit index="5" name="wtm[5]" />
      <Bit index="4" name="wtm[4]" />
      <Bit index="3" name="wtm[3]" />
      <Bit index="2" name="wtm[2]" />
      <Bit index="1" name="wtm[1]" />
      <Bit index="0" name="wtm[0]" />
      <Description>
        Wake Up Timer Mantissa (M) Value*.
        M[7:0] = 0 is not valid here. Write at least decimal 1.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="17" name="Wake-Up Timer Value 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[15]" />
      <Bit index="6" name="wtv[14]" />
      <Bit index="5" name="wtv[13]" />
      <Bit index="4" name="wtv[12]" />
      <Bit index="3" name="wtv[11]" />
      <Bit index="2" name="wtv[10]" />
      <Bit index="1" name="wtv[9]" />
      <Bit index="0" name="wtv[8]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="18" name="Wake-Up Timer Value 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="wtv[7]" />
      <Bit index="6" name="wtv[6]" />
      <Bit index="5" name="wtv[5]" />
      <Bit index="4" name="wtv[4]" />
      <Bit index="3" name="wtv[3]" />
      <Bit index="2" name="wtv[2]" />
      <Bit index="1" name="wtv[1]" />
      <Bit index="0" name="wtv[0]" />
      <Description>
        Wake Up Timer Current Mantissa (M) Value*.
        *Note:	 The period of the wake-up timer can be calculated as TWUT=(4 x M x 2R) / 32.768ms.
      </Description>
    </Register>
    <Register address="19" name="Low-Duty Cycle Mode Duration" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldc[7]" />
      <Bit index="6" name="ldc[6]" />
      <Bit index="5" name="ldc[5]" />
      <Bit index="4" name="ldc[4]" />
      <Bit index="3" name="ldc[3]" />
      <Bit index="2" name="ldc[2]" />
      <Bit index="1" name="ldc[1]" />
      <Bit index="0" name="ldc[0]" />
      <Description>
        Low-Duty Cycle Mode Duration (LDC)*.
        If enabled, the LDC will start together when the WUT is supposed to start, and the duration of the LDC is specified by the address 19h and the equation that goes with it. In order for the LDC to work, the LDC value has to be smaller than the M value specified in registers 15h and 16h.
        LDC = 0 is not allowed here. Write at least decimal 1.
        *Note:	 The period of the low-duty cycle ON time can be calculated as TLDC_ON = (4 x LDC x 2R) / 32.768 ms. R is the same as in the wake-up timer setting in"Register 14h. Wake-Up Timer Period 1". The LDC works in conjunction with the WUT. The LDC period must be specified to be smaller than the WUT period. (i.e., the LDC register must be smaller than the M register). The LDC may not be programmed to 0.
      </Description>
    </Register>
    <Register address="1A" name="Low Battery Detector Threshold" size="8" defaultVal="14" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="lbdt[4]" />
      <Bit index="3" name="lbdt[3]" />
      <Bit index="2" name="lbdt[2]" />
      <Bit index="1" name="lbdt[1]" />
      <Bit index="0" name="lbdt[0]" />
      <Description>
        4:0
        lbdt[4:0]
        Low Battery Detector Threshold.
        This threshold is compared to Battery Voltage Level. If the Battery Voltage is less than the threshold the Low Battery Interrupt is set. Default = 2.7V.*
        *Note:	 The threshold can be calculated as Vthreshold = 1.7+lbdtx50mV.
      </Description>
    </Register>
    <Register address="1B" name="Battery Voltage Level" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="0" />
      <Bit index="5" name="0" />
      <Bit index="4" name="vbat[4]" />
      <Bit index="3" name="vbat[3]" />
      <Bit index="2" name="vbat[2]" />
      <Bit index="1" name="vbat[1]" />
      <Bit index="0" name="vbat[0]" />
      <Description>
        4:0
        vbat[4:0]
        Battery Voltage Level.
        The battery voltage is converted by a 5 bit ADC. In Sleep Mode the register is updated in every 1 s. In other states it measures continuously.
      </Description>
    </Register>
    <Register address="1C" name="IF Filter Bandwidth" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dwn3_bypass" />
      <Bit index="6" name="ndec[2]" />
      <Bit index="5" name="ndec[1]" />
      <Bit index="4" name="ndec[0]" />
      <Bit index="3" name="filset[3]" />
      <Bit index="2" name="filset[2]" />
      <Bit index="1" name="filset[1]" />
      <Bit index="0" name="filset[0]" />
      <Description>
        7
        Bypass Decimator by 3 (if set).
        6:4
        ndec_exp[2:0]
        IF Filter Decimation Rates.
        3:0
        filset[3:0]
        IF Filter Coefficient Sets.
        Defaults are for Rb = 40kbps and Fd = 20kHz so Bw = 80kHz.
      </Description>
    </Register>
    <Register address="1D" name="AFC Loop Gearshift Override" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afcbd" />
      <Bit index="6" name="enafc" />
      <Bit index="5" name="afcgearh[2]" />
      <Bit index="4" name="afcgearh[1]" />
      <Bit index="3" name="afcgearh[0]" />
      <Bit index="2" name="afcgearl[2]" />
      <Bit index="1" name="afcgearl[1]" />
      <Bit index="0" name="afcgearl[0]" />
      <Description>
        7
        If set, the tolerated AFC frequency error will be halved.
        6
        enafc
        AFC Enable.
        5:3
        afcgearh[2:0]
        AFC High Gear Setting.
        2:0
        afcgearl[2:0]
        AFC Low Gear Setting.
      </Description>
    </Register>
    <Register address="1E" name="AFC Timing Control" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="swait_timer[1]" />
      <Bit index="6" name="swait_timer[0]" />
      <Bit index="5" name="shwait[2]" />
      <Bit index="4" name="shwait[1]" />
      <Bit index="3" name="shwait[0]" />
      <Bit index="2" name="anwait[2]" />
      <Bit index="1" name="anwait[1]" />
      <Bit index="0" name="anwait[0]" />
      <Description>
        7:6
        Short Wait RSSI Timer.
        The second phase RSSI waiting timer offset.
        5:3
        shwait[2:0]
        Short Wait Periods after AFC Correction.
        Used before preamble is detected. Short wait = (RegValue + 1)x2Tb. If set to 0 then no AFC correction will occur before preamble detect, i.e. AFC will be disabled.
        2:0
        anwait[2:0]
        Antenna Switching Wait Time.
        Value corresponds to number of bits.
      </Description>
    </Register>
    <Register address="1F" name="Clock Recovery Gearshift Override" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="crfast[2]" />
      <Bit index="4" name="crfast[1]" />
      <Bit index="3" name="crfast[0]" />
      <Bit index="2" name="crslow[2]" />
      <Bit index="1" name="crslow[1]" />
      <Bit index="0" name="crslow[0]" />
      <Description>
        5:3
        crfast[2:0]
        Clock Recovery Fast Gearshift Value.
        2:0
        crslow[2:0]
        Clock Recovery Slow Gearshift Value.
        The gear-shift register controls BCR loop gain. Before the preamble is detected, BCR loop gain is as follows:
        Once the preamble is detected, internal state machine automatically shift BCR loop gain to the following:
        crfast = 3   b000 and crslow = 3   b101 are recommended for most applications. The value of    crslow    should be greater than    crfast   .
      </Description>
    </Register>
    <Register address="20" name="Clock Recovery Oversampling Ratio" size="8" defaultVal="64" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[7]" />
      <Bit index="6" name="rxosr[6]" />
      <Bit index="5" name="rxosr[5]" />
      <Bit index="4" name="rxosr[4]" />
      <Bit index="3" name="rxosr[3]" />
      <Bit index="2" name="rxosr[2]" />
      <Bit index="1" name="rxosr[1]" />
      <Bit index="0" name="rxosr[0]" />
      <Description>
        Oversampling Rate.
        3 LSBs are the fraction, default = 0110 0100 = 12.5 clock cycles per data bit
        The oversampling rate can be calculated as rxosr = 500kHz/(2ndec_expxRX_DR). The ndec_exp and the dwn3_bypass values found at Address: 1Ch     IF Filter Bandwidth register together with the receive data rate (Rb) are the parameters needed to calculate rxosr:
        The Rb unit used in this equation is in kbps. The enmanch is the Manchester Coding parameter (see Reg. 70h, enmach is 1 when Manchester coding is enabled, enmanch is 0 when disabled). The number found in the equation should be rounded to an integer. The integer can be translated to a hexadecimal.
      </Description>
    </Register>
    <Register address="21" name="Clock Recovery Offset 2" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxosr[10]" />
      <Bit index="6" name="rxosr[9]" />
      <Bit index="5" name="rxosr[8]" />
      <Bit index="4" name="stallctrl" />
      <Bit index="3" name="ncoff[19]" />
      <Bit index="2" name="ncoff[18]" />
      <Bit index="1" name="ncoff[17]" />
      <Bit index="0" name="ncoff[16]" />
      <Description>
        Oversampling Rate.
        Upper bits.
        4
        stallctrl
        Used for BCR Purposes.
        3:0
        ncoff[19:16]
        NCO Offset.
        See formula above.
        The offset can be calculated as follows:
      </Description>
    </Register>
    <Register address="22" name="Clock Recovery Offset 1" size="8" defaultVal="47" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[15]" />
      <Bit index="6" name="ncoff[14]" />
      <Bit index="5" name="ncoff[13]" />
      <Bit index="4" name="ncoff[12]" />
      <Bit index="3" name="ncoff[11]" />
      <Bit index="2" name="ncoff[10]" />
      <Bit index="1" name="ncoff[9]" />
      <Bit index="0" name="ncoff[8]" />
      <Description>
        NCO Offset.
        See formula above
      </Description>
    </Register>
    <Register address="23" name="Clock Recovery Offset 0" size="8" defaultVal="AE" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ncoff[7]" />
      <Bit index="6" name="ncoff[6]" />
      <Bit index="5" name="ncoff[5]" />
      <Bit index="4" name="ncoff[4]" />
      <Bit index="3" name="ncoff[3]" />
      <Bit index="2" name="ncoff[2]" />
      <Bit index="1" name="ncoff[1]" />
      <Bit index="0" name="ncoff[0]" />
      <Description>
        NCO Offset.
        See formula above
      </Description>
    </Register>
    <Register address="24" name="Clock Recovery Timing Loop Gain 1" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="rxncocomp" />
      <Bit index="3" name="crgain2x" />
      <Bit index="2" name="crgain[10]" />
      <Bit index="1" name="crgain[9]" />
      <Bit index="0" name="crgain[8]" />
      <Description>
        4
        rxncocomp
        Receive Compensation Enable for High Data Rate Offset.
        3
        cgainx2
        Multiplying the CR Gain by 2.
        2:0
        crgain[10:8]
        Clock Recovery Timing Loop Gain.
        The loop gain can be calculated as follows:
      </Description>
    </Register>
    <Register address="25" name="Clock Recovery Timing Loop Gain 0" size="8" defaultVal="8F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="crgain[7]" />
      <Bit index="6" name="crgain[6]" />
      <Bit index="5" name="crgain[5]" />
      <Bit index="4" name="crgain[4]" />
      <Bit index="3" name="crgain[3]" />
      <Bit index="2" name="crgain[2]" />
      <Bit index="1" name="crgain[1]" />
      <Bit index="0" name="crgain[0]" />
      <Description>Clock Recovery Timing Loop Gain.</Description>
    </Register>
    <Register address="26" name="Received Signal Strength Indicator" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssi[7]" />
      <Bit index="6" name="rssi[6]" />
      <Bit index="5" name="rssi[5]" />
      <Bit index="4" name="rssi[4]" />
      <Bit index="3" name="rssi[3]" />
      <Bit index="2" name="rssi[2]" />
      <Bit index="1" name="rssi[1]" />
      <Bit index="0" name="rssi[0]" />
      <Description>Received Signal Strength Indicator Value.</Description>
    </Register>
    <Register address="27" name="RSSI Threshold for Clear Channel Indicator" size="8" defaultVal="1E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rssith[7]" />
      <Bit index="6" name="rssith[6]" />
      <Bit index="5" name="rssith[5]" />
      <Bit index="4" name="rssith[4]" />
      <Bit index="3" name="rssith[3]" />
      <Bit index="2" name="rssith[2]" />
      <Bit index="1" name="rssith[1]" />
      <Bit index="0" name="rssith[0]" />
      <Description>
        RSSI Threshold.
        Interrupt is set if the RSSI value is above this threshold.
      </Description>
    </Register>
    <Register address="28" name="Antenna Diversity Register 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssi1[7]" />
      <Bit index="6" name="adrssia[6]" />
      <Bit index="5" name="adrssia[5]" />
      <Bit index="4" name="adrssia[4]" />
      <Bit index="3" name="adrssia[3]" />
      <Bit index="2" name="adrssia[2]" />
      <Bit index="1" name="adrssia[1]" />
      <Bit index="0" name="adrssia[0]" />
      <Description>Measured RSSI Value on Antenna 1.</Description>
    </Register>
    <Register address="29" name="Antenna Diversity Register 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="adrssib[7]" />
      <Bit index="6" name="adrssib[6]" />
      <Bit index="5" name="adrssib[5]" />
      <Bit index="4" name="adrssib[4]" />
      <Bit index="3" name="adrssib[3]" />
      <Bit index="2" name="adrssib[2]" />
      <Bit index="1" name="adrssib[1]" />
      <Bit index="0" name="adrssib[0]" />
      <Description>Measured RSSI Value on Antenna 2.</Description>
    </Register>
    <Register address="2A" name="AFC Limiter" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Afclim[7]" />
      <Bit index="6" name="Afclim[6]" />
      <Bit index="5" name="Afclim[5]" />
      <Bit index="4" name="Afclim[4]" />
      <Bit index="3" name="Afclim[3]" />
      <Bit index="2" name="Afclim[2]" />
      <Bit index="1" name="Afclim[1]" />
      <Bit index="0" name="Afclim[0]" />
      <Description>
        AFC Limiter.
        AFC limiter value.
        For the following registers (addresses 2Bh and 2Ch), use the following equation:
        where Rb's unit is in kHz and    enmanch    is the Manchester Enable bit (found at address 71h bit [1]).
      </Description>
    </Register>
    <Register address="2B" name="AFC Correction Read" size="8" defaultVal="00" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[8]" />
      <Bit index="5" name="afc_corr[7]" />
      <Bit index="4" name="afc_corr[6]" />
      <Bit index="3" name="afc_corr[5]" />
      <Bit index="2" name="afc_corr[4]" />
      <Bit index="1" name="afc_corr[3]" />
      <Bit index="0" name="afc_corr[2]" />
      <Description>
        AFC Correction Values.
        AFC loop correction values [9:2] (MSBs only). Values are updated once, after sync word is found during receiving. See also address 2Ch.
      </Description>
    </Register>
    <Register address="2C" name="OOK Counter Value 1" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="afc_corr[9]" />
      <Bit index="6" name="afc_corr[9]" />
      <Bit index="5" name="ookfrzen" />
      <Bit index="4" name="peakdeten" />
      <Bit index="3" name="madeten" />
      <Bit index="2" name="ookcnt[10]" />
      <Bit index="1" name="ookcnt[9]" />
      <Bit index="0" name="ookcnt[8]" />
      <Description>
        7:6
        AFC Correction Values.
        AFC loop correction values [1:0] (LSBs). Values are updated once, after sync word is found during receiving. See also address 2Bh.
        5
        ookfrzen
        OOK Freeze.
        OOK AGC freeze if this bit is set.
        4
        peakdeten
        Peak Detector Enable.
        Peak detector enable if high.
        3
        madeten
        MA_Enable.
        MA block enable if high.
        2:0
        ookcnt[2:0]
        OOK Counter [10:8].
        OOK counter value MSBs.
      </Description>
    </Register>
    <Register address="2D" name="OOK Counter Value 2" size="8" defaultVal="BC" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ookcnt[7]" />
      <Bit index="6" name="ookcnt[6]" />
      <Bit index="5" name="ookcnt[5]" />
      <Bit index="4" name="ookcnt[4]" />
      <Bit index="3" name="ookcnt[3]" />
      <Bit index="2" name="ookcnt[2]" />
      <Bit index="1" name="ookcnt[1]" />
      <Bit index="0" name="ookcnt[0]" />
      <Description>
        OOK Counter [7:0].
        OOK counter value LSBs.
      </Description>
    </Register>
    <Register address="2E" name="Slicer Peak Hold" size="8" defaultVal="26" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="attack[2]" />
      <Bit index="5" name="attack[1]" />
      <Bit index="4" name="attack[0]" />
      <Bit index="3" name="decay[3]" />
      <Bit index="2" name="decay[2]" />
      <Bit index="1" name="decay[1]" />
      <Bit index="0" name="decay[0]" />
      <Description>
        6:4
        attack[2:0]
        Attack.
        3:0
        decay[3:0]
        Decay.
      </Description>
    </Register>
    <Register address="30" name="Data Access Control" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="enpacrx" />
      <Bit index="6" name="lsbfrst" />
      <Bit index="5" name="crcdonly" />
      <Bit index="4" name="skip2ph" />
      <Bit index="3" name="enpactx" />
      <Bit index="2" name="encrc" />
      <Bit index="1" name="crc[1]" />
      <Bit index="0" name="crc[0]" />
      <Description>
        7
        Enable Packet RX Handling.
        If FIFO Mode (dtmod=10) is being used automatic packet handling may be enabled. Setting enpacrx=1 will enable automatic packet handling in the RX path. Register 30   4D allow for various configurations of the packet structure. Setting enpacrx=0 will not do any packet handling in the RX path. It will only receive everything after the sync word and fill up the RX FIFO.
        6
        lsbfrst
        LSB First Enable.
        The LSB of the data will be transmitted/received first if this bit is set.
        5
        crcdonly
        CRC Data Only Enable.
        When this bit is set to 1 the CRC is calculated on and checked against the packet data fields only.
        4
        skip2ph
        Skip 2nd Phase of Preamble Detection.
        If set, we skip the second phase of the preamble detection (under certain conditions) if antenna diversity is enabled.
        3
        enpactx
        Enable Packet TX Handling.
        If FIFO Mode (dtmod=10) is being used automatic packet handling may be enabled. Setting enpactx=1 will enable automatic packet handling in the TX path. Register 30   4D allow for various configurations of the packet structure. Setting enpactx=0 will not do any packet handling in the TX path. It will only transmit what is loaded to the FIFO.
        2
        encrc
        CRC Enable.
        Cyclic Redundancy Check generation is enabled if this bit is set.
        1:0
        crc[1:0]
        CRC Polynomial Selection.
        00:	CCITT
        01:	CRC-16 (IBM)
        10:	IEC-16
        11:	Biacheva
      </Description>
    </Register>
    <Register address="31" name="EzMAC status" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="0" />
      <Bit index="6" name="rxcrc1" />
      <Bit index="5" name="pksrch" />
      <Bit index="4" name="pkrx" />
      <Bit index="3" name="pkvalid" />
      <Bit index="2" name="crcerror" />
      <Bit index="1" name="pktx" />
      <Bit index="0" name="pksent" />
      <Description>
        6
        rxcrc1
        If high, it indicates the last CRC received is all one   s.
        May indicated Transmitter underflow in case of CRC error.
        5
        pksrch
        Packet Searching.
        When pksrch = 1 the radio is searching for a valid packet.
        4
        pkrx
        Packet Receiving.
        When pkrx = 1 the radio is currently receiving a valid packet.
        3
        pkvalid
        Valid Packet Received.
        When a pkvalid = 1 a valid packet has been received by the receiver. (Same bit as in register 03, but reading it does not reset the IRQ)
        2
        crcerror
        CRC Error.
        When crcerror = 1 a Cyclic Redundancy Check error has been detected. (Same bit as in register 03, but reading it does not reset the IRQ)
        1:0
        Reserved
        1
        pktx
        Packet Transmitting.
        When pktx = 1 the radio is currently transmitting a packet.
        0
        pksent
        Packet Sent.
        A pksent = 1 a packet has been sent by the radio. (Same bit as in register 03, but reading it does not reset the IRQ)
      </Description>
    </Register>
    <Register address="32" name="Header Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcen[3]" />
      <Bit index="6" name="bcen[2]" />
      <Bit index="5" name="bcen[1]" />
      <Bit index="4" name="bcen[0]" />
      <Bit index="3" name="hdch[3]" />
      <Bit index="2" name="hdch[2]" />
      <Bit index="1" name="hdch[1]" />
      <Bit index="0" name="hdch[0]" />
      <Description>
        7:4
        Broadcast Address (FFh) Check Enable.
        If it is enabled together with Header Byte Check then the header check is OK if the incoming header byte equals with the appropriate check byte or FFh). One hot encoding.
        0000:	No broadcast address enable.
        0001:	Broadcast address enable for header byte 0.
        0010:	Broadcast address enable for header byte 1.
        0011:	Broadcast address enable for header bytes 0 &amp; 1.
        0100:
        3:0
        hdch[3:0]
        Received Header Bytes to be Checked Against the Check Header Bytes.
        One hot encoding. The receiver will use hdch[2:0] to know the position of the Header Bytes.
        0000:	No Received Header check
        0001:	Received Header check for byte 0.
        0010:	Received Header check for bytes 1.
        0011:	Received header check for bytes 0 &amp; 1.
        0100:
      </Description>
    </Register>
    <Register address="33" name="Header Control 2" size="8" defaultVal="22" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="hdlen[2]" />
      <Bit index="5" name="hdlen[1]" />
      <Bit index="4" name="hdlen[0]" />
      <Bit index="3" name="fixpklen" />
      <Bit index="2" name="synclen[1]" />
      <Bit index="1" name="synclen[0]" />
      <Bit index="0" name="prealen[8]" />
      <Description>
        6:4
        hdlen[2:0]
        Header Length.
        Length of header used if packet handler is enabled for TX/RX (enpactx/rx). Headers are transmitted/received in descending order.
        000:	NoTX/RX header
        001: 	Header 3
        010: 	Header 3 and 2
        011: 	Header 3 and 2 and 1
        100: 	Header 3 and 2 and 1 and 0
        3
        fixpklen
        Fix Packet Length.
        When fixpklen = 1 the packet length (pklen[7:0]) is not included in the header. When fixpklen = 0 the packet length is included in the header.
        2:1
        synclen[1:0]
        Synchronization Word Length.
        The value in this register corresponds to the number of bytes used in the Synchronization Word. The synchronization word bytes are transmitted in descending order.
        00: 	Synchronization Word 3
        01: 	Synchronization Word 3 and 2
        10: 	Synchronization Word 3 and 2 and 1
        11: 	Synchronization Word 3 and 2 and 1 and 0
        0
        prealen[8]
        MSB of Preamble Length.
        See register Preamble Length.
      </Description>
    </Register>
    <Register address="34" name="Preamble Length" size="8" defaultVal="08" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="prealen[7]" />
      <Bit index="6" name="prealen[6]" />
      <Bit index="5" name="prealen[5]" />
      <Bit index="4" name="prealen[4]" />
      <Bit index="3" name="prealen[3]" />
      <Bit index="2" name="prealen[2]" />
      <Bit index="1" name="prealen[1]" />
      <Bit index="0" name="prealen[0]" />
      <Description>
        Preamble Length.
        The value in the prealen[8:0] register corresponds to the number of nibbles (4 bits) in the packet. For example prealen[8:0] =    000001000    corresponds to a preamble length of 32 bits (8x4bits) or 4 bytes. The maximum preamble length is prealen[8:0] = 111111111 which corresponds to a 255 bytes Preamble. Writing 0 will have the same result as if writing 1, which corresponds to one single nibble of preamble.
      </Description>
    </Register>
    <Register address="35" name="Preamble Detection Control" size="8" defaultVal="2A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="preath[4]" />
      <Bit index="6" name="preath[3]" />
      <Bit index="5" name="preath[2]" />
      <Bit index="4" name="preath[1]" />
      <Bit index="3" name="preath[0]" />
      <Bit index="2" name="rssi_off[2]" />
      <Bit index="1" name="rssi_off[1]" />
      <Bit index="0" name="rssi_off[0]" />
      <Description>
        7:3
        Number of nibbles processed during detection.
        2:0
        rssi_offset[2:0]
        rssi_offset[2:0]
        Value added as offset to RSSI calculation. Every increment in this register results in an increment of +4dB in the RSSI.
      </Description>
    </Register>
    <Register address="36" name="Sync Word 3" size="8" defaultVal="2D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[31]" />
      <Bit index="6" name="sync[30]" />
      <Bit index="5" name="sync[29]" />
      <Bit index="4" name="sync[28]" />
      <Bit index="3" name="sync[27]" />
      <Bit index="2" name="sync[26]" />
      <Bit index="1" name="sync[25]" />
      <Bit index="0" name="sync[24]" />
      <Description>
        Synchronization Word 3.
        4th byte of the synchronization word.
      </Description>
    </Register>
    <Register address="37" name="Sync Word 2" size="8" defaultVal="D4" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[23]" />
      <Bit index="6" name="sync[22]" />
      <Bit index="5" name="sync[21]" />
      <Bit index="4" name="sync[20]" />
      <Bit index="3" name="sync[19]" />
      <Bit index="2" name="sync[18]" />
      <Bit index="1" name="sync[17]" />
      <Bit index="0" name="sync[16]" />
      <Description>
        Synchronization Word 2.
        3rd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="38" name="Sync Word 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[15]" />
      <Bit index="6" name="sync[14]" />
      <Bit index="5" name="sync[13]" />
      <Bit index="4" name="sync[12]" />
      <Bit index="3" name="sync[11]" />
      <Bit index="2" name="sync[10]" />
      <Bit index="1" name="sync[9]" />
      <Bit index="0" name="sync[8]" />
      <Description>
        Synchronization Word 1.
        2nd byte of the synchronization word.
      </Description>
    </Register>
    <Register address="39" name="Sync Word 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="sync[7]" />
      <Bit index="6" name="sync[6]" />
      <Bit index="5" name="sync[5]" />
      <Bit index="4" name="sync[4]" />
      <Bit index="3" name="sync[3]" />
      <Bit index="2" name="sync[2]" />
      <Bit index="1" name="sync[1]" />
      <Bit index="0" name="sync[0]" />
      <Description>
        Synchronization Word 0.
        1st byte of the synchronization word.
      </Description>
    </Register>
    <Register address="3A" name="Transmit Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[31]" />
      <Bit index="6" name="txhd[30]" />
      <Bit index="5" name="txhd[29]" />
      <Bit index="4" name="txhd[28]" />
      <Bit index="3" name="txhd[27]" />
      <Bit index="2" name="txhd[26]" />
      <Bit index="1" name="txhd[25]" />
      <Bit index="0" name="txhd[24]" />
      <Description>
        Transmit Header 3.
        4th byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3B" name="Transmit Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[23]" />
      <Bit index="6" name="txhd[22]" />
      <Bit index="5" name="txhd[21]" />
      <Bit index="4" name="txhd[20]" />
      <Bit index="3" name="txhd[19]" />
      <Bit index="2" name="txhd[18]" />
      <Bit index="1" name="txhd[17]" />
      <Bit index="0" name="txhd[16]" />
      <Description>
        Transmit Header 2.
        3rd byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3C" name="Transmit Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[15]" />
      <Bit index="6" name="txhd[14]" />
      <Bit index="5" name="txhd[13]" />
      <Bit index="4" name="txhd[12]" />
      <Bit index="3" name="txhd[11]" />
      <Bit index="2" name="txhd[10]" />
      <Bit index="1" name="txhd[9]" />
      <Bit index="0" name="txhd[8]" />
      <Description>
        Transmit Header 1.
        2nd byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3D" name="Transmit Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txhd[7]" />
      <Bit index="6" name="txhd[6]" />
      <Bit index="5" name="txhd[5]" />
      <Bit index="4" name="txhd[4]" />
      <Bit index="3" name="txhd[3]" />
      <Bit index="2" name="txhd[2]" />
      <Bit index="1" name="txhd[1]" />
      <Bit index="0" name="txhd[0]" />
      <Description>
        Transmit Header 0.
        1st byte of the header to be transmitted.
      </Description>
    </Register>
    <Register address="3E" name="Transmit Packet Length" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pklen[7]" />
      <Bit index="6" name="pklen[6]" />
      <Bit index="5" name="pklen[5]" />
      <Bit index="4" name="pklen[4]" />
      <Bit index="3" name="pklen[3]" />
      <Bit index="2" name="pklen[2]" />
      <Bit index="1" name="pklen[1]" />
      <Bit index="0" name="pklen[0]" />
      <Description>
        Packet Length.
        The value in the pklen[7:0] register corresponds directly to the number of bytes in the Packet. For example pklen[7:0] =    00001000    corresponds to a packet length of 8 bytes. The maximum packet length is pklen[7:0] =    11111111   , a 255 byte packet. Writing 0 is possible, in this case we do not send any data in the packet. During RX, if fixpklen = 1, this will specify also the Packet Length for RX mode.
      </Description>
    </Register>
    <Register address="3F" name="Check Header 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[31]" />
      <Bit index="6" name="chhd[30]" />
      <Bit index="5" name="chhd[29]" />
      <Bit index="4" name="chhd[28]" />
      <Bit index="3" name="chhd[27]" />
      <Bit index="2" name="chhd[26]" />
      <Bit index="1" name="chhd[25]" />
      <Bit index="0" name="chhd[24]" />
      <Description>
        Check Header 3.
        4th byte of the check header.
      </Description>
    </Register>
    <Register address="40" name="Check Header 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[23]" />
      <Bit index="6" name="chhd[22]" />
      <Bit index="5" name="chhd[21]" />
      <Bit index="4" name="chhd[20]" />
      <Bit index="3" name="chhd[19]" />
      <Bit index="2" name="chhd[18]" />
      <Bit index="1" name="chhd[17]" />
      <Bit index="0" name="chhd[16]" />
      <Description>
        Check Header 2.
        3rd byte of the check header.
      </Description>
    </Register>
    <Register address="41" name="Check Header 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[15]" />
      <Bit index="6" name="chhd[14]" />
      <Bit index="5" name="chhd[13]" />
      <Bit index="4" name="chhd[12]" />
      <Bit index="3" name="chhd[11]" />
      <Bit index="2" name="chhd[10]" />
      <Bit index="1" name="chhd[9]" />
      <Bit index="0" name="chhd[8]" />
      <Description>
        Check Header 1.
        2nd byte of the check header.
      </Description>
    </Register>
    <Register address="42" name="Check Header 0" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="chhd[7]" />
      <Bit index="6" name="chhd[6]" />
      <Bit index="5" name="chhd[5]" />
      <Bit index="4" name="chhd[4]" />
      <Bit index="3" name="chhd[3]" />
      <Bit index="2" name="chhd[2]" />
      <Bit index="1" name="chhd[1]" />
      <Bit index="0" name="chhd[0]" />
      <Description>
        Check Header 0.
        1st byte of the check header.
      </Description>
    </Register>
    <Register address="43" name="Header Enable 3" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[31]" />
      <Bit index="6" name="hden[30]" />
      <Bit index="5" name="hden[29]" />
      <Bit index="4" name="hden[28]" />
      <Bit index="3" name="hden[27]" />
      <Bit index="2" name="hden[26]" />
      <Bit index="1" name="hden[25]" />
      <Bit index="0" name="hden[24]" />
      <Description>
        Header Enable 3.
        4th byte of the check header.
      </Description>
    </Register>
    <Register address="44" name="Header Enable 2" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[23]" />
      <Bit index="6" name="hden[22]" />
      <Bit index="5" name="hden[21]" />
      <Bit index="4" name="hden[20]" />
      <Bit index="3" name="hden[19]" />
      <Bit index="2" name="hden[18]" />
      <Bit index="1" name="hden[17]" />
      <Bit index="0" name="hden[16]" />
      <Description>
        Header Enable 2.
        3rd byte of the check header.
      </Description>
    </Register>
    <Register address="45" name="Header Enable 1" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[15]" />
      <Bit index="6" name="hden[14]" />
      <Bit index="5" name="hden[13]" />
      <Bit index="4" name="hden[12]" />
      <Bit index="3" name="hden[11]" />
      <Bit index="2" name="hden[10]" />
      <Bit index="1" name="hden[9]" />
      <Bit index="0" name="hden[8]" />
      <Description>
        Header Enable 1.
        2nd byte of the check header.
      </Description>
    </Register>
    <Register address="46" name="Header Enable 0" size="8" defaultVal="FF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="hden[7]" />
      <Bit index="6" name="hden[6]" />
      <Bit index="5" name="hden[5]" />
      <Bit index="4" name="hden[4]" />
      <Bit index="3" name="hden[3]" />
      <Bit index="2" name="hden[2]" />
      <Bit index="1" name="hden[1]" />
      <Bit index="0" name="hden[0]" />
      <Description>
        Header Enable 0.
        1st byte of the check header.
      </Description>
    </Register>
    <Register address="47" name="Received Header 3" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[31]" />
      <Bit index="6" name="rxhd[30]" />
      <Bit index="5" name="rxhd[29]" />
      <Bit index="4" name="rxhd[28]" />
      <Bit index="3" name="rxhd[27]" />
      <Bit index="2" name="rxhd[26]" />
      <Bit index="1" name="rxhd[25]" />
      <Bit index="0" name="rxhd[24]" />
      <Description>
        Received Header 3.
        4th byte of the received header.
      </Description>
    </Register>
    <Register address="48" name="Received Header 2" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[23]" />
      <Bit index="6" name="rxhd[22]" />
      <Bit index="5" name="rxhd[21]" />
      <Bit index="4" name="rxhd[20]" />
      <Bit index="3" name="rxhd[19]" />
      <Bit index="2" name="rxhd[18]" />
      <Bit index="1" name="rxhd[17]" />
      <Bit index="0" name="rxhd[16]" />
      <Description>
        Received Header 2.
        3rd byte of the received header.
      </Description>
    </Register>
    <Register address="49" name="Received Header 1" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[15]" />
      <Bit index="6" name="rxhd[14]" />
      <Bit index="5" name="rxhd[13]" />
      <Bit index="4" name="rxhd[12]" />
      <Bit index="3" name="rxhd[11]" />
      <Bit index="2" name="rxhd[10]" />
      <Bit index="1" name="rxhd[9]" />
      <Bit index="0" name="rxhd[8]" />
      <Description>
        Received Header 1.
        2nd byte of the received header.
      </Description>
    </Register>
    <Register address="4A" name="Received Header 0" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxhd[7]" />
      <Bit index="6" name="rxhd[6]" />
      <Bit index="5" name="rxhd[5]" />
      <Bit index="4" name="rxhd[4]" />
      <Bit index="3" name="rxhd[3]" />
      <Bit index="2" name="rxhd[2]" />
      <Bit index="1" name="rxhd[1]" />
      <Bit index="0" name="rxhd[0]" />
      <Description>
        Received Header 0.
        1st byte of the received header.
      </Description>
    </Register>
    <Register address="4B" name="Received Packet Length" size="8" defaultVal="-" isRead="1" isWrite="0" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rxplen[7]" />
      <Bit index="6" name="rxplen[6]" />
      <Bit index="5" name="rxplen[5]" />
      <Bit index="4" name="rxplen[4]" />
      <Bit index="3" name="rxplen[3]" />
      <Bit index="2" name="rxplen[2]" />
      <Bit index="1" name="rxplen[1]" />
      <Bit index="0" name="rxplen[0]" />
      <Description>
        Length Byte of the Received Packet during fixpklen = 0.
        (Specifies the number of Data bytes in the last received packet) This will be relevant ONLY if fixpklen (address 33h, bit[3]) is low during the receive time. If fixpklen is high, then the number of received Data Bytes can be read from the pklen register (address h3E).
      </Description>
    </Register>
    <Register address="4F" name="ADC8 Control" size="8" defaultVal="10" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="adc8[5]" />
      <Bit index="4" name="adc8[4]" />
      <Bit index="3" name="adc8[3]" />
      <Bit index="2" name="adc8[2]" />
      <Bit index="1" name="adc8[1]" />
      <Bit index="0" name="adc8[0]" />
      <Description>
        5:0
        adc8[5:0]
        ADC8 Control Bits.
      </Description>
    </Register>
    <Register address="50" name="Analog Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="atb[4]" />
      <Bit index="3" name="atb[3]" />
      <Bit index="2" name="atb[2]" />
      <Bit index="1" name="atb[1]" />
      <Bit index="0" name="atb[0]" />
      <Description>
        4:0
        atb[4:0]
        Analog Test Bus.
        The selection of internal analog testpoints that are muxed onto TESTp and TESTn.
        Table 31. Internal Analog Signals Available on the Analog Test Bus
        Addr
        hex
        ATBp
        ATBn
        0
        0
        1
        1
        MixIp
        MixIn
        2
        2
        MixQp
        MixQn
        3
        3
        PGA_Ip
        PGA_In
        4
        4
        PGA_Qp
        PGA_Qn
        5
        5
        vcmout
        vbn
        6
        6
        refmid
        vbiasp
        7
        7
        ADC_vcm
        ADC_vcmb
        8
        8
        ADC_ipoly10
        ADC_ref
        9
        9
        RefADC_p
        RefADC_m
        10
        A
        ADC_Res1Ip
        ADC_Res1In
        11
        B
        ADC_Res1Qp
        ADC_Res1Qn
        12
        C
        ADC_Res2Ip
        ADC_Res2In
        13
        D
        ADC_Res2Qp
        ADC_Res2Qn
        14
        E
        ADC_Res3Ip
        ADC_Res3In
        15
        F
        ADC_Res3Qp
        ADC_Res3Qn
        16
        10
        NC
        NC
        17
        11
        ADC_Cal_Ucap
        ADC_Cal_Ures
        18
        12
        I_CP_test
        PLL_IBG_05
        19
        13
        PLL_VBG
        VSS_VCO
        20
        14
        Vctrl_Test
        PLL_IPTAT_05
        21
        15
        PA_Vbias
        NC
        22
        16
        DIGBG
        DIGVFB
        23
        17
        IFBG
        IFVFB
        24
        18
        PLLBG
        PLLVREG
        25
        19
        IBias_10u
        IBias_5u
        26
        1A
        CLK_65K_Out
        AVSS
        27
        1B
        ADC8_VIN
        ADC8_VDAC
        28
        1C
        LBDcomp
        LBDcompref
        29
        1D
        TSBG
        TSVtemp
        30
        1E
        RFBG
        RFVREG
        31
        1F
        VCOBG
        VCOVREG
      </Description>
    </Register>
    <Register address="51" name="Digital Test Bus" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="ensctest" />
      <Bit index="5" name="dtb[5]" />
      <Bit index="4" name="dtb[4]" />
      <Bit index="3" name="dtb[3]" />
      <Bit index="2" name="dtb[2]" />
      <Bit index="1" name="dtb[1]" />
      <Bit index="0" name="dtb[0]" />
      <Description></Description>
    </Register>
    <Register address="52" name="TX Ramp Control" size="8" defaultVal="DF" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="ldorampen" />
      <Bit index="6" name="txmod[2]" />
      <Bit index="5" name="txmod[1]" />
      <Bit index="4" name="txmod[0]" />
      <Bit index="3" name="ldoramp[1]" />
      <Bit index="2" name="ldoramp[0]" />
      <Bit index="1" name="txramp[1]" />
      <Bit index="0" name="txramp[0]" />
      <Description>
        7
        PA LDO Ramp Enable.
        When this bit is set, the PA LDO ramp will ramp in conjunction with the ramp of the PA bias.  Ramping the LDO will increase modulation depth for OOK. Spectral improvements will occur when not ramping the LDO.
        6:4
        txmod[2:0]
        TX Modulation Delay.
        The time delay between PA enable and the beginning of the TX modulation to allow for PA ramp-up. It can be set from 0  s to 28   s in 4   s steps. This also works during PA ramp down.
        3:2
        ldoramp[1:0]
        TX LDO Ramp Time.
        The RF LDO is used to help ramp the PA to prevent VCO pulling and spectral splatter.
        00:	5   s
        01:	10   s
        10:	15   s
        11:	20   s
        1:0
        txramp[1:0]
        TX Ramp Time.
        The PA is ramped up slowly to prevent VCO pulling and spectral splatter. This register sets the time the PA is ramped up.
        00: 	5   s
        01: 	10   s
        10: 	15   s
        11: 	20   s
      </Description>
    </Register>
    <Register address="53" name="PLL Tune Time" size="8" defaultVal="52" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="pllts[4]" />
      <Bit index="6" name="pllts[3]" />
      <Bit index="5" name="pllts[2]" />
      <Bit index="4" name="pllts[1]" />
      <Bit index="3" name="pllts[0]" />
      <Bit index="2" name="pllt0[2]" />
      <Bit index="1" name="pllt0[1]" />
      <Bit index="0" name="pllt0[0]" />
      <Description>
        7:3
        PLL Soft Settling Time (TS).
        This register will set the settling time for the PLL from a previous locked frequency in Tune mode. The value is configurable between 0   s and 310  s, in 10   s intervals. The default plltime corresponds to 100  s. See formula above.
        2:0
        pllt0
        PLL Settling Time (TO).
        This register will set the time allowed for PLL settling after the calibrations are completed. The value is configurable between 0   s and 70  s, in 10  s steps. The default pllt0 corresponds to 20  s. See formula above.
      </Description>
    </Register>
    <Register address="54" name="Invalid Preamble Threshold and PA Misc" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="pa_duty[1]" />
      <Bit index="4" name="pa_duty[0]" />
      <Bit index="3" name="ldoramplv[1]" />
      <Bit index="2" name="ldoramplv[0]" />
      <Bit index="1" name="Ido_pa_boost" />
      <Bit index="0" name="pabias_boost" />
      <Description>
        5:4
        pa_duty[1:0]
        PA Duty Cycle Control.
        Shifting the duty cycle of the PA will effect PA efficiency and harmonics.
        3:2
        ldoramplv[1:0]
        PA LDO Ramp Level.
        The starting ramp level of the PA LDO. The ramp level will effect modulation depth and spectral splatter.
        1
        ldo_pa_boost
        LDO PA Boost.
        0
        pa_vbias_boost
        PA VBIAS Boost.
      </Description>
    </Register>
    <Register address="55" name="Calibration Control" size="8" defaultVal="44" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="xtalstarthalf" />
      <Bit index="5" name="adccaldone" />
      <Bit index="4" name="enrcfcal" />
      <Bit index="3" name="rccal" />
      <Bit index="2" name="vcocaldp" />
      <Bit index="1" name="vcocal" />
      <Bit index="0" name="skipvco" />
      <Description>
        6
        xtalstarthalf
        If Set, the Xtal Wake Time Period is Halved.
        5
        adccaldone
        Delta-sigma ADC Calibration Done.Reading this bit gives 1 if the calibration process has been finished.
        4
        enrcfcal
        RC Oscillator Fine Calibration Enable.
        If this bit is set to 1 then the RC oscillator performs fine calibration in every app. 30 s.
        3
        rccal
        RC Calibration Force.
        If setting rccal=1 will automatically perform a forced calibration of the 32kHz RC Oscillator. The RC OSC will automatically be calibrated if the Wake-Up-Timer is enabled or if in the Wake-on-Receiver state. The calibration takes 2ms. The 32kHz RC oscillator must be enabled to perform a calibration. Setting this signal from a 0 to 1 will initiate the calibration. This bit is cleared automatically.
        2
        vcocaldp
        VCO Calibration Double Precision Enable.
        When this bit is set to 1 then the VCO calibration measures longer thus calibrates more precisely.
        1
        vcocal
        VCO Calibration Force.
        If in Idle Mode and pllon=1, setting vcocal=1 will force a one time calibration of the synthesizer VCO. This bit is cleared automatically.
        0
        skipvco
        Skip VCO Calibration.
        Setting skipvco=1 will skip the VCO calibration when going from the Idle state to the TX or RX state.
      </Description>
    </Register>
    <Register address="56" name="Modem Test" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="bcrfbyp" />
      <Bit index="6" name="slicfbyp" />
      <Bit index="5" name="dttype" />
      <Bit index="4" name="oscdeten" />
      <Bit index="3" name="rssimasel" />
      <Bit index="2" name="refclksel" />
      <Bit index="1" name="refclkinv" />
      <Bit index="0" name="distogg" />
      <Description>
        7
        If set, BCR phase compensation will be bypassed.
        6
        slicfbyp
        If set, slicer phase compensation will be bypassed.
        5
        dttype
        Dithering Type.
        If low and dither enabled, we add +1/0, otherwise if high and dithering enabled, we add   1.
        4
        oscdeten
        If low, the ADC Oscillation Detection mechanism is allowed to work. If set, we disable the function.
        3
        rssimasel
        RSSI Moving Average Select.
        If 1 then the RSSI moving average read back is 8 bits. If 0 then the moving average is set to 4 bits.
        2
        refclksel
        Delta-Sigma Reference Clock Source Selection
        1:	10MHz
        0:	 PLL
        1
        refclkinv
        Delta-Sigma Reference Clock Inversion Enable.
        0
        distogg
        If reset, the discriminator toggling is disabled.
      </Description>
    </Register>
    <Register address="57" name="Chargepump Test" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pfdrst" />
      <Bit index="6" name="fbdiv_rst" />
      <Bit index="5" name="cpforceup" />
      <Bit index="4" name="cpforcedn" />
      <Bit index="3" name="cdconly" />
      <Bit index="2" name="cdccur[2]" />
      <Bit index="1" name="cdccur[1]" />
      <Bit index="0" name="cdccur[0]" />
      <Description>
        7
        Direct Control to Analog.
        6
        fbdiv_rst
        Direct Control to Analog.
        5
        cpforceup
        Charge Pump Force Up.
        4
        cpforcedn
        Charge Pump Force Down.
        3
        cdconly
        Charge Pump DC Offset Only.
        2:0
        cdcurr[2:0]
        Charge Pump DC Current Selection.
      </Description>
    </Register>
    <Register address="58" name="Chargepump Current Trimming/Override" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="cpcurr[1]" />
      <Bit index="6" name="cpcurr[0]" />
      <Bit index="5" name="cpcorrov" />
      <Bit index="4" name="cpcorr[4]" />
      <Bit index="3" name="cpcorr[3]" />
      <Bit index="2" name="cpcorr[2]" />
      <Bit index="1" name="cpcorr[1]" />
      <Bit index="0" name="cpcorr[0]" />
      <Description>
        7:6
        Charge Pump Current (Gain Setting).
        Changing these bits will change the BW of the PLL. The default setting is adequate for all data rates.
        5
        cpcorrov
        Charge Pump Correction Override Enable.
        4:0
        cpcorr[4:0]
        Charge Pump Correction Value.
        During read, you read what the Charge Pump sees. If cpcorrov = 1, then the value you write will go to the Charge Pump, and will also be the value you read. By default, cpcorr[4:0] wakes up as all Zeros.
      </Description>
    </Register>
    <Register address="59" name="Divider Current Trimming" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcorboosten" />
      <Bit index="6" name="fbdivhc" />
      <Bit index="5" name="d3trim[1]" />
      <Bit index="4" name="d3trim[0]" />
      <Bit index="3" name="d2trim[1]" />
      <Bit index="2" name="d2trim[0]" />
      <Bit index="1" name="d1p5trim[1]" />
      <Bit index="0" name="d1p5trim[0]" />
      <Description>
        7
        If this is Set, then vcocorr (reg 5A[5:2]) = 1111 during TX Mode and VCO CAL followed by TX.
        6
        fbdivhc
        Feedback (fractional) Divider High Current Enable (+5  A).
        5:4
        d3trim[1:0]
        Divider 3 Current Trim Value.
        3:2
        d2trim[1:0]
        Divider 2 Current Trim Value.
        1:0
        d1p5trim[1:0]
        Divider 1.5 (div-by-1.5) Current Trim Value.
      </Description>
    </Register>
    <Register address="5A" name="VCO Current Trimming" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txcurboosten" />
      <Bit index="6" name="vcocorrov" />
      <Bit index="5" name="vcocorr[3]" />
      <Bit index="4" name="vcocorr[2]" />
      <Bit index="3" name="vcocorr[1]" />
      <Bit index="2" name="vcocorr[0]" />
      <Bit index="1" name="vcocur[1]" />
      <Bit index="0" name="vcocur[0]" />
      <Description>
        7
        If this is Set, then vcocur = 11 during TX Mode and VCO CAL followed by TX.
        6
        vcocorrov
        VCO Current Correction Override.
        5:2
        vcocorr[3:0]
        VCO Current Correction Value.
        1:0
        vcocur[1:0]
        VCO Current Trim Value.
      </Description>
    </Register>
    <Register address="5B" name="VCO Calibration / Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="vcocalov/vcdone" />
      <Bit index="6" name="vcocal[6]" />
      <Bit index="5" name="vcocal[5]" />
      <Bit index="4" name="vcocal[4]" />
      <Bit index="3" name="vcocal[3]" />
      <Bit index="2" name="vcocal[2]" />
      <Bit index="1" name="vcocal[1]" />
      <Bit index="0" name="vcocal[0]" />
      <Description>
        7
        VCO Calibration Override/Done.
        When vcocalov=0 the internal VCO calibration results may be viewed by reading the vcocal register. When vcocalov=1 the VCO results may be overridden externally through the SPI by writing to the vcocal register. Reading this bit gives 1 if the calibration process has been finished.
        6:0
        vcocal[6:0]
        VCO Calibration Results.
      </Description>
    </Register>
    <Register address="5C" name="Synthesizer Test" size="8" defaultVal="0E" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="dsmdt" />
      <Bit index="6" name="0" />
      <Bit index="5" name="enoloop" />
      <Bit index="4" name="dsmod" />
      <Bit index="3" name="dsorder[1]" />
      <Bit index="2" name="dsorder[0]" />
      <Bit index="1" name="dsrstmod" />
      <Bit index="0" name="dsrst" />
      <Description>
        7
        Enable DSM Dithering.
        If low, dithering is disabled.
        6
        Reserved
        Will read 0.
        5
        enoloop
        Open Loop Mode Enable.
        4
        dsmod
        Delta-Sigma Modulus.
        0: 64000
        1: 65 536
        3:2
        dsorder[1:0]
        Delta-Sigma Order.
        00: 	0 order
        01: 	1st order
        10: 	2nd order
        11: 	Mash 111
        1
        dsrstmode
        Delta-Sigma Reset Mode.
        0
        dsrst
        Delta-Sigma Reset.
      </Description>
    </Register>
    <Register address="5D" name="Block Enable Override 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enmix" />
      <Bit index="6" name="enlna" />
      <Bit index="5" name="enpga" />
      <Bit index="4" name="enpa" />
      <Bit index="3" name="enbf5" />
      <Bit index="2" name="endv32" />
      <Bit index="1" name="enbf12" />
      <Bit index="0" name="enmx2" />
      <Description>
        7
        Mixer Enable Override.
        6
        enlna
        LNA Enable Override.
        5
        enpga
        PGA Enable Override.
        4
        enpa
        Power Amplifier Enable Override.
        3
        enbf5
        Buffer 5 Enable Override.
        2
        endv32
        Divider 3_2 Enable Override.
        1
        enbf12
        Buffer 1_2 Enable Override.
        0
        enmx2
        Multiplexer 2 Enable Override.
      </Description>
    </Register>
    <Register address="5E" name="Block Enable Override 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="ends" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="enmx3" />
      <Bit index="4" name="enbf4" />
      <Bit index="3" name="enbf3" />
      <Bit index="2" name="enbf11" />
      <Bit index="1" name="enbf2" />
      <Bit index="0" name="pllreset" />
      <Description>
        7
        Delta-Sigma Enable Override.
        6
        Reserved
        5
        enmx3
        Multiplexer 3 Enable Override.
        4
        enbf4
        Buffer 4 Enable Override.
        3
        enbf3
        Buffer 3 Enable Override.
        2
        enbf11
        Buffer 1_1 Enable Override.
        1
        enbf2
        Buffer 2 Enable Override.
        0
        pllreset
        PLL Reset Enable Override.
      </Description>
    </Register>
    <Register address="5F" name="Block Enable Override 3" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enfrdv" />
      <Bit index="6" name="endv31" />
      <Bit index="5" name="endv2" />
      <Bit index="4" name="endv1p5" />
      <Bit index="3" name="dvbshunt" />
      <Bit index="2" name="envco" />
      <Bit index="1" name="encp" />
      <Bit index="0" name="enbg" />
      <Description>
        7
        Fractional Divider Enable Override.
        6
        endv31
        Divider 3_1 Enable Override.
        5
        endv2
        Divider 2 Enable Override.
        4
        endv1p5
        Divider 1.5 (div-by-1.5) Enable Override.
        3
        dvbshunt
        VCO Bias Shunt Enable Override Mode.
        2
        envco
        VCO Enable Override.
        1
        encp
        Charge Pump Enable Override.
        0
        enbg
        Bandgap Enable Override.
      </Description>
    </Register>
    <Register address="60" name="Channel Filter Coefficient Address" size="8" defaultVal="50" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="chfiladd[3]" />
      <Bit index="2" name="chfiladd[2]" />
      <Bit index="1" name="chfiladd[1]" />
      <Bit index="0" name="chfiladd[0]" />
      <Description>
        3:0
        chfiladd[3:0]
        Channel Filter Coefficient Look-up Table Address.
        The address for channel filter coefficients used in the RX path.
      </Description>
    </Register>
    <Register address="61" name="Channel Filter Coefficient Value" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="chfilval[5]" />
      <Bit index="4" name="chfilval[4]" />
      <Bit index="3" name="chfilval[3]" />
      <Bit index="2" name="chfilval[2]" />
      <Bit index="1" name="chfilval[1]" />
      <Bit index="0" name="chfilval[0]" />
      <Description>
        5:0
        chfilval[5:0]
        Filter Coefficient Value in the Look-up Table Addressed by the chfiladd[3:0].
      </Description>
    </Register>
    <Register address="62" name="Crystal Oscillator / Control Test" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="pwst[2]" />
      <Bit index="6" name="pwst[1]" />
      <Bit index="5" name="pwst[0]" />
      <Bit index="4" name="clkhyst" />
      <Bit index="3" name="enbias2x" />
      <Bit index="2" name="enamp2x" />
      <Bit index="1" name="bufovr" />
      <Bit index="0" name="enbuf" />
      <Description>
        7:5
        Internal Power States of the Chip.
        LP:	000
        RDY:	001
        Tune:	011
        TX:	010
        RX:	111
        4
        clkhyst
        Clock Hysteresis Setting.
        3
        enbias2x
        2 Times Higher Bias Current Enable.
        2
        enamp2x
        2 Times Higher Amplification Enable.
        1
        bufovr
        Output Buffer Enable Override.
        If set to 1 then the enbuf bit controls the output buffer.
        0: output buffer is controlled by the state machine.
        1: output buffer is controlled by the enbuf bit.
        0
        enbuf
        Output Buffer Enable.
        This bit is active only if the bufovr bit is set to 1.
      </Description>
    </Register>
    <Register address="63" name="RC Oscillator Coarse Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rccov" />
      <Bit index="6" name="rcc[6]" />
      <Bit index="5" name="rcc[5]" />
      <Bit index="4" name="rcc[4]" />
      <Bit index="3" name="rcc[3]" />
      <Bit index="2" name="rcc[2]" />
      <Bit index="1" name="rcc[1]" />
      <Bit index="0" name="rcc[0]" />
      <Description>
        7
        RC Oscillator Coarse Calibration Override.
        When rccov=0 the internal Coarse Calibration results may be viewed by reading the rcccal register. When rccov=1 the Coarse results may be overridden externally through the SPI by writing to the rcccal register.
        6:0
        rcc[6:0]
        RC Oscillator Coarse Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="64" name="RC Oscillator Fine Calibration/Override" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="rcfov" />
      <Bit index="6" name="rcf[6]" />
      <Bit index="5" name="rcf[5]" />
      <Bit index="4" name="rcf[4]" />
      <Bit index="3" name="rcf[3]" />
      <Bit index="2" name="rcf[2]" />
      <Bit index="1" name="rcf[1]" />
      <Bit index="0" name="rcf[0]" />
      <Description>
        7
        RC Oscillator Fine Calibration Override.
        When rcfov=0 the internal Fine Calibration results may be viewed by reading the rcfcal register. When rcfov=1 the Fine results may be overridden externally through the SPI by writing to the rcfcal register.
        6:0
        rcf[6:0]
        RC Oscillator Fine Calibration Override Value/Results.
      </Description>
    </Register>
    <Register address="65" name="LDO Control Override" size="8" defaultVal="81" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enspor" />
      <Bit index="6" name="enbias" />
      <Bit index="5" name="envcoldo" />
      <Bit index="4" name="enifldo" />
      <Bit index="3" name="enrfldo" />
      <Bit index="2" name="enpllldo" />
      <Bit index="1" name="endigldo" />
      <Bit index="0" name="endigpwdn" />
      <Description>
        Smart POR Enable.
        6
        enbias
        Bias Enable.
        5
        envcoldo
        VCO LDO Enable.
        4
        enifldo
        IF LDO Enable.
        3
        enrfldo
        RF LDO Enable.
        2
        enpllldo
        PLL LDO Enable.
        1
        endigldo
        Digital LDO Enable.
        0
        endigpwdn
        Digital Power Domain Powerdown Enable in Idle Mode.
      </Description>
    </Register>
    <Register address="66" name="LDO Level Setting" size="8" defaultVal="02" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="enovr" />
      <Bit index="6" name="enxtal" />
      <Bit index="5" name="ents" />
      <Bit index="4" name="enrc32" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="diglvl[2]" />
      <Bit index="1" name="diglvl[1]" />
      <Bit index="0" name="diglvl[0]" />
      <Description>
        7
        Enable Overrides.
        If high, ovr values are output to the blocks and can enable or disable them, if low, some ovr value can only enable the blocks.
        6
        enxtal
        Xtal Override Enable Value.
        5
        ents
        Temperature Sensor Enable.
        4
        enrc32
        32K Oscillator Enable.
        3
        2:0
        diglvl
        Digital LDO Level Setting.
      </Description>
    </Register>
    <Register address="67" name="Deltasigma ADC Tuning 1" size="8" defaultVal="1F" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="adcrst" />
      <Bit index="6" name="enrefdac" />
      <Bit index="5" name="enadc" />
      <Bit index="4" name="adctuneovr" />
      <Bit index="3" name="adctune[3]" />
      <Bit index="2" name="adctune[2]" />
      <Bit index="1" name="adctune[1]" />
      <Bit index="0" name="adctune[0]" />
      <Description>
        7
        Delta-Sigma ADC Reset.
        Active low.
        6
        enrefdac
        Delta-Sigma ADC Reference DAC Enable Override.
        5
        enadc
        Delta-Sigma ADC Enable Override.
        4
        adctuneovr
        Resonator RC Calibration Value Override Enable.
        3:0
        adctune[3:0]
        Resonator RC Calibration Value.
      </Description>
    </Register>
    <Register address="68" name="Deltasigma ADC Tuning 2" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="envcm" />
      <Bit index="3" name="adcoloop" />
      <Bit index="2" name="adcref[2]" />
      <Bit index="1" name="adcref[1]" />
      <Bit index="0" name="adcref[0]" />
      <Description>
        4
        envcm
        Delta-Sigma ADC VCM Enable Override.
        3
        adcoloop
        Delta-Sigma ADC Open Loop Enable.
        2:0
        adcref[2:0]
        Delta-Sigma ADC Reference Voltage.
        000:	0.5 V
        001:	0.6 V
        010:	0.7 V

        111:	1.2 V
      </Description>
    </Register>
    <Register address="69" name="AGC Override 1" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sgi" />
      <Bit index="5" name="agcen" />
      <Bit index="4" name="lnagain" />
      <Bit index="3" name="pga3" />
      <Bit index="2" name="pga2" />
      <Bit index="1" name="pga1" />
      <Bit index="0" name="pga0" />
      <Description>
        6
        SGI
        Stop Increasing Gain for AGC Loop.
        Default = 0.
        5
        agcen
        Automatic Gain Control Enable.
        When this bit is set then the result of the control can be read out from bits [4:0], otherwise the gain can be controlled manually by writing into bits [4:0].
        4
        lnagain
        LNA Gain Select.
        0     min. gain = 5 dB	1    max. gain = 25 dB
        3:0
        pga[3:0]
        PGA Gain Override Value.
        000:	0 dB
        001:	3 dB
        010:	6 dB
        ...
        101:	24 dB max.
      </Description>
    </Register>
    <Register address="6A" name="AGC Override 2" size="8" defaultVal="9D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="agcovpm" />
      <Bit index="6" name="agcslow" />
      <Bit index="5" name="lnacomp[3]" />
      <Bit index="4" name="lnacomp[2]" />
      <Bit index="3" name="lnacomp[1]" />
      <Bit index="2" name="lnacomp[0]" />
      <Bit index="1" name="pgath[1]" />
      <Bit index="0" name="pgath[0]" />
      <Description>
        7
        If set, AGC will ignore the Preamble Detection.
        6
        agcslow
        AGC Slow Gain Increase Enable.
        When this bit is set then the AGC loop will slow down the gain increase in the receiver. The speed of the gain reduction is not affected.
        5:2
        lnacomp[3:0]
        LNA Gain Compensation.
        This bit is used for smoothing RSSI value when LNA gain is switched.
        1:0
        pgath[1:0]
        Window Comparator Reference Voltage Adjust in the PGA.
      </Description>
    </Register>
    <Register address="6B" name="GFSK FIR Filter Coefficient Address" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="firadd[2]" />
      <Bit index="1" name="firadd[1]" />
      <Bit index="0" name="firadd[0]" />
      <Description>
        2:0
        firadd[2:0]
        GFSK FIR Filter Coefficient Look-up Table Address.
        The address for Gaussian filter coefficients used in the TX path. The default GFSK setting is for BT=0.5. It is not needed to change or load the GFSK Coefficients if BT=0.5 is satisfactory for the system.
        000: 	i_coe0 (Default =d1)
        001: 	i_coe1 (Default =d3)
        010: 	i_coe2 (Default =d6)
        011: 	i_coe3 (Default =d10)
        100: 	i_coe4 (Default =d15)
        101: 	i_coe5 (Default =d19)
        110: 	i_coe6 (Default =d20)
      </Description>
    </Register>
    <Register address="6C" name="GFSK FIR Filter Coefficient Value" size="8" defaultVal="01" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="firval[5]" />
      <Bit index="4" name="firval[4]" />
      <Bit index="3" name="firval[3]" />
      <Bit index="2" name="firval[2]" />
      <Bit index="1" name="firval[1]" />
      <Bit index="0" name="firval[0]" />
      <Description>
        5:0
        firval[5:0]
        FIR Coefficient Value in the lOok-up Table Addressed by the firadd[2:0].
        The default coefficient can be read or modified.
      </Description>
    </Register>
    <Register address="6D" name="TX Power" size="8" defaultVal="18" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="papeakval" />
      <Bit index="6" name="papeaken" />
      <Bit index="5" name="papeaklvl[1]" />
      <Bit index="4" name="papeaklvl[0]" />
      <Bit index="3" name="Ina_sw" />
      <Bit index="2" name="txpow[2]" />
      <Bit index="1" name="txpow[1]" />
      <Bit index="0" name="txpow[0]" />
      <Description>
        7
        papeakval
        PA Peak Detector Value, Read only
        Reading a 1 in this register when the papeaken=1 then the PA drain voltage is too high and the match network needs adjusting for optimal efficiency.
        6
        papeaken
        PA Peak Detector Enable.
        5:4
        papeaklvl[0]
        PA Peak Detect Level (direct from register).
        00=6.5
        01=7
        10=7.5
        11=8
        00 = default
        3
        lna_sw
        LNA Switch Controller.
        If set, lna_sw control from the digital will go high during TX modes, and low during other times. If reset, the digital control signal is low at all times.
        2:0
        txpow[2:0]
        TX Output Power.
        The output power is configurable from    8dBm to +13dBm in ~3dBm steps. txpow[2:0]=111 corresponds to +13dBm and 000 to    8dBm.
      </Description>
    </Register>
    <Register address="6E" name="TX Data Rate 1" size="8" defaultVal="0A" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[15]" />
      <Bit index="6" name="txdr[14]" />
      <Bit index="5" name="txdr[13]" />
      <Bit index="4" name="txdr[12]" />
      <Bit index="3" name="txdr[11]" />
      <Bit index="2" name="txdr[10]" />
      <Bit index="1" name="txdr[9]" />
      <Bit index="0" name="txdr[8]" />
      <Description>
        Data Rate Upper Byte.
        See formula above.
        The data rate can be calculated as: TX_DR=103xtxdr[15:0] / 216 [kbps] (if address 70[5]=0) or
      </Description>
    </Register>
    <Register address="6F" name="TX Data Rate 0" size="8" defaultVal="3D" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="txdr[7]" />
      <Bit index="6" name="txdr[6]" />
      <Bit index="5" name="txdr[5]" />
      <Bit index="4" name="txdr[4]" />
      <Bit index="3" name="txdr[3]" />
      <Bit index="2" name="txdr[2]" />
      <Bit index="1" name="txdr[1]" />
      <Bit index="0" name="txdr[0]" />
      <Description>
        Data Rate Lower Byte.
        See formula above. Defaults = 40kbps.
      </Description>
    </Register>
    <Register address="70" name="Modulation Mode Control 1" size="8" defaultVal="0C" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txdtrtscale" />
      <Bit index="4" name="enphpwdn" />
      <Bit index="3" name="manppol" />
      <Bit index="2" name="enmaninv" />
      <Bit index="1" name="enmanch" />
      <Bit index="0" name="enwhite" />
      <Description>
        5
        txdtrtscale
        This bit should be set for Data Rates below 30kbps.
        4
        enphpwdn
        If set, the Packet Handler will be powered down when chip is in low power mode.
        3
        manppol
        Manchester Preamble Polarity (will transmit a series of 1 if set, or series of 0 if reset).
        This bit affects ONLY the transmitter side, not the receiver. This is valid ONLY if Manchester Mode is enabled.
        2
        enmaninv
        Manchester Data Inversion is Enabled if this bit is set.
        1
        enmanch
        Manchester Coding is Enabled if this bit is set.
        0
        enwhite
        Data Whitening is Enabled if this bit is set.
      </Description>
    </Register>
    <Register address="71" name="Modulation Mode Control 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="trclk[1]" />
      <Bit index="6" name="trclk[0]" />
      <Bit index="5" name="dtmod[1]" />
      <Bit index="4" name="dtmod[0]" />
      <Bit index="3" name="eninv" />
      <Bit index="2" name="fd[8]" />
      <Bit index="1" name="modtyp[1]" />
      <Bit index="0" name="modtyp[0]" />
      <Description>
        7:6
        TX Data Clock Configuration.
        00:	No TX Data CLK is available (asynchronous mode     Can only work with modulations FSK or OOK).
        01:	TX Data CLK is available via the GPIO (one of the GPIO   s should be programmed as well).
        10:	TX Data CLK is available via the SDO pin.
        11:	TX Data CLK is available via the nIRQ pin.
        5:4
        dtmod[1:0]
        Modulation Source.
        00: 	Direct Mode using TX_Data function via the GPIO pin 	(one of the GPIO   s should be programmed accordingly as well)
        01: 	Direct Mode using TX_Data function via the SDI pin (only when nSEL is high)
        10: 	FIFO Mode
        11: 	PN9 (internally generated)
        3
        eninv
        Invert TX and RX Data.
        2
        fd[8]
        MSB of Frequency Deviation Setting, see"Register 72h. Frequency Deviation".
        1:0
        modtyp[1:0]
        Modulation Type.
        00:	Unmodulated carrier
        01:	OOK
        10:	FSK
        11:	GFSK (enable TX Data CLK (trclk[1:0]) when direct mode is used)
      </Description>
    </Register>
    <Register address="72" name="Frequency Deviation" size="8" defaultVal="20" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fd[7]" />
      <Bit index="6" name="fd[6]" />
      <Bit index="5" name="fd[5]" />
      <Bit index="4" name="fd[4]" />
      <Bit index="3" name="fd[3]" />
      <Bit index="2" name="fd[2]" />
      <Bit index="1" name="fd[1]" />
      <Bit index="0" name="fd[0]" />
      <Description>
        Frequency Deviation Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="73" name="Frequency Offset 1" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fo[7]" />
      <Bit index="6" name="fo[6]" />
      <Bit index="5" name="fo[5]" />
      <Bit index="4" name="fo[4]" />
      <Bit index="3" name="fo[3]" />
      <Bit index="2" name="fo[2]" />
      <Bit index="1" name="fo[1]" />
      <Bit index="0" name="fo[0]" />
      <Description>
        Frequency Offset Setting.
        The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value. Reading from this register will give the AFC correction last results, not this register value.
      </Description>
    </Register>
    <Register address="74" name="Frequency Offset 2" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="Reserved" />
      <Bit index="1" name="fo[9]" />
      <Bit index="0" name="fo[8]" />
      <Description>
        1:0
        fo[9:8]
        Upper Bits of the Frequency Offset Setting.
        fo[9] is the sign bit. The frequency offset can be calculated as Offset=156.25Hz x (hbsel + 1) x fo[7:0]. fo[9:0] is a twos complement value. Reading from this register will give the AFC correction last results, not this register value.
      </Description>
    </Register>
    <Register address="75" name="Frequency Band Select" size="8" defaultVal="75" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="sbsel" />
      <Bit index="5" name="hbsel" />
      <Bit index="4" name="fb[4]" />
      <Bit index="3" name="fb[3]" />
      <Bit index="2" name="fb[2]" />
      <Bit index="1" name="fb[1]" />
      <Bit index="0" name="fb[0]" />
      <Description>
        6
        sbsel
        Side Band Select.
        5
        hbsel
        High Band Select.
        Setting hbsel = 1 will choose the frequency range from 480   960MHz (high bands). Setting hbsel = 0 will choose the frequency range from 240   479.9MHz (low bands).
        4:0
        fb[4:0]
        Frequency Band Select.
        Every increment corresponds to a 10MHz Band for the Low Bands and a 20MHz Band for the High Bands. Setting fb[4:0]=00000 corresponds to the 240   250MHz Band for hbsel=0 and the 480   500MHz Band for hbsel=1. Setting fb[4:0]=00001 corresponds to the 250   260MHz Band for hbsel=0 and the 500   520MHz Band for hbsel=1.
        The RF carrier frequency can be calculated as follows:
        fcarrier = (fb+24+(fc+fo) / 64000)x10000x(hbsel+1) + (fhchxfhsx10) [kHz],
      </Description>
    </Register>
    <Register address="76" name="Nominal Carrier Frequency 1" size="8" defaultVal="BB" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[15]" />
      <Bit index="6" name="fc[14]" />
      <Bit index="5" name="fc[13]" />
      <Bit index="4" name="fc[12]" />
      <Bit index="3" name="fc[11]" />
      <Bit index="2" name="fc[10]" />
      <Bit index="1" name="fc[9]" />
      <Bit index="0" name="fc[8]" />
      <Description>
        Nominal Carrier Frequency Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="77" name="Nominal Carrier Frequency 0" size="8" defaultVal="80" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fc[7]" />
      <Bit index="6" name="fc[6]" />
      <Bit index="5" name="fc[5]" />
      <Bit index="4" name="fc[4]" />
      <Bit index="3" name="fc[3]" />
      <Bit index="2" name="fc[2]" />
      <Bit index="1" name="fc[1]" />
      <Bit index="0" name="fc[0]" />
      <Description>
        Nominal Carrier Frequency Setting.
        See formula above.
      </Description>
    </Register>
    <Register address="78" name="Miscellaneous Settings" size="8" defaultVal="19" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="ifsw_en" />
      <Bit index="3" name="Alt_PA_Seq" />
      <Bit index="2" name="rcosc[2]" />
      <Bit index="1" name="rcosc[1]" />
      <Bit index="0" name="rcosc[0]" />
      <Description>
        4
        ifsw_en
        Enable for IF SW between PA and IF.
        3
        alt_pa_seq
        Alternative PA sequencing.
        If set, we will enable the alternative PA sequence. By default, this is not enabled.
        2:0
        rcosc_cal[2:0]
        rcosc_cal[2:0].
        Fine changes on the RC OSC Calibration target frequency, to help compensate for    calibration biases.    This register should not be changed by costumers.
      </Description>
    </Register>
    <Register address="79" name="Frequency Hopping Channel Select" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhch[7]" />
      <Bit index="6" name="fhch[6]" />
      <Bit index="5" name="fhch[5]" />
      <Bit index="4" name="fhch[4]" />
      <Bit index="3" name="fhch[3]" />
      <Bit index="2" name="fhch[2]" />
      <Bit index="1" name="fhch[1]" />
      <Bit index="0" name="fhch[0]" />
      <Description>Frequency Hopping Channel Number.</Description>
    </Register>
    <Register address="7A" name="Frequency Hopping Step Size" size="8" defaultVal="00" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="1" isDigitalReg="0" isMiscReg="1" isStatusReg="0" />
      <Bit index="7" name="fhs[7]" />
      <Bit index="6" name="fhs[6]" />
      <Bit index="5" name="fhs[5]" />
      <Bit index="4" name="fhs[4]" />
      <Bit index="3" name="fhs[3]" />
      <Bit index="2" name="fhs[2]" />
      <Bit index="1" name="fhs[1]" />
      <Bit index="0" name="fhs[0]" />
      <Description>
        Frequency Hopping Step Size in 10kHz Increments.
        See formula for the nominal carrier frequency at"Register 76h. Nominal Carrier Frequency".
      </Description>
    </Register>
    <Register address="7B" name="Turn Around and 15.4 Length Compliance" size="8" defaultVal="03" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="1" isRFReg="0" isDigitalReg="0" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="15.4 Length" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="Reserved" />
      <Bit index="4" name="Reserved" />
      <Bit index="3" name="Reserved" />
      <Bit index="2" name="turn_around_en" />
      <Bit index="1" name="Phase[1]" />
      <Bit index="0" name="Phase[0]" />
      <Description>
        7
        15.4 Packet Length Compliance.
        If set, then PK Length definition for both TX and RX will also include the CRC bytes, If reset, then the Length refers ONLY to the DATA payload. For example, writing    9    to this register when it is set, means we are sending/expecting    7    bytes of DATA, and the other    2    should be the CRC (CRC should be enabled separately).
        6:3
        Reserved
        2
        turn_around_en
        Turn Around Enable.
        Enabling for the turn around functionality.
        1:0
        phase[1:0]
        Turn Around Phase.
        The RX to TX and vice-versa change in frequency will happen (if bit [2] is set) at the last byte, and these two registers set the bit position in which the frequency shifts should occur. Make sure it does not happen to early otherwise the last bits will be missed.
      </Description>
    </Register>
    <Register address="7C" name="TX FIFO Control 1" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txafthr[5]" />
      <Bit index="4" name="txafthr[4]" />
      <Bit index="3" name="txafthr[3]" />
      <Bit index="2" name="txafthr[2]" />
      <Bit index="1" name="txafthr[1]" />
      <Bit index="0" name="txafthr[0]" />
      <Description>
        5:0
        txafthr[5:0]
        TX FIFO Almost Full Threshold.
      </Description>
    </Register>
    <Register address="7D" name="TX FIFO Control 2" size="8" defaultVal="04" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="txaethr[5]" />
      <Bit index="4" name="txaethr[4]" />
      <Bit index="3" name="txaethr[3]" />
      <Bit index="2" name="txaethr[2]" />
      <Bit index="1" name="txaethr[1]" />
      <Bit index="0" name="txaethr[0]" />
      <Description>
        5:0
        txfaethr[5:0]
        TX FIFO Almost Empty Threshold.
      </Description>
    </Register>
    <Register address="7E" name="RX FIFO Control" size="8" defaultVal="37" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="Reserved" />
      <Bit index="6" name="Reserved" />
      <Bit index="5" name="rxafthr[5]" />
      <Bit index="4" name="rxafthr[4]" />
      <Bit index="3" name="rxafthr[3]" />
      <Bit index="2" name="rxafthr[2]" />
      <Bit index="1" name="rxafthr[1]" />
      <Bit index="0" name="rxafthr[0]" />
      <Description>
        5:0
        rxafthr[5:0]
        RX FIFO Almost Full Threshold.
      </Description>
    </Register>
    <Register address="7F" name="FIFO Access" size="8" defaultVal="-" isRead="1" isWrite="1" mode="0">
      <Classification isTestReg="0" isRFReg="0" isDigitalReg="1" isMiscReg="0" isStatusReg="0" />
      <Bit index="7" name="fifod[7]" />
      <Bit index="6" name="fifod[6]" />
      <Bit index="5" name="fifod[5]" />
      <Bit index="4" name="fifod[4]" />
      <Bit index="3" name="fifod[3]" />
      <Bit index="2" name="fifod[2]" />
      <Bit index="1" name="fifod[1]" />
      <Bit index="0" name="fifod[0]" />
      <Description>
        FIFO Data.
        A Write (R/W=1) to this Address will begin a Burst Write to the TX FIFO. The FIFO will be loaded in the same manner as a Burst SPI Write but the SPI address will not be incremented. To conclude the TX FIFO Write the SEL pin should be brought HIGH. A Read (R/W=0) to this address will begin a burst read of the RX FIFO, in the same manner.
      </Description>
    </Register>
  </SPIDevice>
</SPITools>